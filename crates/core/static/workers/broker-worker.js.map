{"version":3,"file":"broker-worker.js","sources":["broker-worker.ts"],"sourcesContent":["/// <reference lib=\"webworker\" />\n\n// SharedWorker to broker messages between iframes within the same tab\n// Each tab gets its own worker instance via unique query string\n\ninterface BrokerMessage {\n  type: string;\n  fromIframe: string;\n  toIframe?: string; // Optional - if not specified, broadcast to all iframes\n  data: any;\n  messageId?: string; // For request-response correlation\n  isResponse?: boolean; // To distinguish responses from regular messages\n}\n\ninterface IframeConnection {\n  port: MessagePort;\n  iframeType: string; // 'button', 'register', etc.\n}\n\nclass MessageBroker {\n  private connections: IframeConnection[] = [];\n\n  constructor() {\n    console.log('SharedWorker: Message broker initialized');\n  }\n\n  addConnection(port: MessagePort, iframeType: string) {\n    const connection: IframeConnection = {\n      port,\n      iframeType,\n    };\n\n    this.connections.push(connection);\n\n    console.log(`SharedWorker: Added ${iframeType} connection`);\n    console.log(`SharedWorker: Now has ${this.connections.length} connections`);\n\n    // Set up message handling for this connection\n    port.onmessage = (event) => {\n      this.handleMessage(event.data, connection);\n    };\n\n    // Clean up when connection closes\n    port.onmessageerror = () => {\n      this.removeConnection(connection);\n    };\n  }\n\n  removeConnection(connection: IframeConnection) {\n    const index = this.connections.indexOf(connection);\n    if (index > -1) {\n      this.connections.splice(index, 1);\n      console.log(`SharedWorker: Removed ${connection.iframeType} connection`);\n    }\n  }\n\n  handleMessage(message: BrokerMessage, fromConnection: IframeConnection) {\n    console.log(`SharedWorker: Message from ${fromConnection.iframeType}:`, message);\n\n    // Handle responses - these should be routed back to the original requester\n    if (message.isResponse && message.messageId) {\n      // For responses, we need to route back to the original sender\n      // The original sender is determined by looking at the message history\n      // Since we don't track request origins, we'll broadcast responses to all other connections\n      // and let the client-side broker handle the correlation\n      this.routeMessage(message, fromConnection, true);\n      return;\n    }\n\n    // Handle regular messages and requests\n    this.routeMessage(message, fromConnection, false);\n  }\n\n  private routeMessage(\n    message: BrokerMessage,\n    fromConnection: IframeConnection,\n    isResponse: boolean\n  ) {\n    // Route message to appropriate iframe(s)\n    for (const connection of this.connections) {\n      // Don't send message back to sender (unless it's a response being routed)\n      if (connection === fromConnection && !isResponse) {\n        continue;\n      }\n\n      // For responses, broadcast to all other connections and let client handle correlation\n      if (isResponse) {\n        if (connection === fromConnection) {\n          continue; // Don't send response back to the responder\n        }\n      } else {\n        // For regular messages/requests, apply normal routing rules\n        // If toIframe is specified, only send to that iframe type\n        if (message.toIframe && connection.iframeType !== message.toIframe) {\n          continue;\n        }\n      }\n\n      try {\n        connection.port.postMessage({\n          ...message,\n          fromIframe: fromConnection.iframeType,\n        });\n        console.log(\n          `SharedWorker: Forwarded ${isResponse ? 'response' : 'message'} to ${connection.iframeType}`\n        );\n      } catch (error) {\n        console.error(`SharedWorker: Failed to send message to ${connection.iframeType}:`, error);\n        // Remove dead connection\n        this.removeConnection(connection);\n      }\n    }\n  }\n}\n\nconst broker = new MessageBroker();\n\n// Handle new connections\nself.addEventListener('connect', (event: Event) => {\n  const connectEvent = event as MessageEvent;\n  const port = connectEvent.ports[0];\n\n  // Wait for initial message with iframe type\n  port.onmessage = (initEvent) => {\n    const { type, iframeType } = initEvent.data;\n\n    if (type === 'init' && iframeType) {\n      broker.addConnection(port, iframeType);\n    } else {\n      console.error('SharedWorker: Invalid init message:', initEvent.data);\n      port.close();\n    }\n  };\n\n  port.start();\n});\n\n// Export types for TypeScript consumers\nexport type { BrokerMessage, IframeConnection };\n"],"names":["MessageBroker","__publicField","port","iframeType","connection","event","index","message","fromConnection","isResponse","error","broker","initEvent","type"],"mappings":"oKAmBA,MAAMA,CAAc,CAGlB,aAAc,CAFNC,EAAA,mBAAkC,CAAA,GAGxC,QAAQ,IAAI,0CAA0C,CACxD,CAEA,cAAcC,EAAmBC,EAAoB,CACnD,MAAMC,EAA+B,CACnC,KAAAF,EACA,WAAAC,CAAA,EAGF,KAAK,YAAY,KAAKC,CAAU,EAEhC,QAAQ,IAAI,uBAAuBD,CAAU,aAAa,EAC1D,QAAQ,IAAI,yBAAyB,KAAK,YAAY,MAAM,cAAc,EAG1ED,EAAK,UAAaG,GAAU,CAC1B,KAAK,cAAcA,EAAM,KAAMD,CAAU,CAC3C,EAGAF,EAAK,eAAiB,IAAM,CAC1B,KAAK,iBAAiBE,CAAU,CAClC,CACF,CAEA,iBAAiBA,EAA8B,CAC7C,MAAME,EAAQ,KAAK,YAAY,QAAQF,CAAU,EAC7CE,EAAQ,KACV,KAAK,YAAY,OAAOA,EAAO,CAAC,EAChC,QAAQ,IAAI,yBAAyBF,EAAW,UAAU,aAAa,EAE3E,CAEA,cAAcG,EAAwBC,EAAkC,CAItE,GAHA,QAAQ,IAAI,8BAA8BA,EAAe,UAAU,IAAKD,CAAO,EAG3EA,EAAQ,YAAcA,EAAQ,UAAW,CAK3C,KAAK,aAAaA,EAASC,EAAgB,EAAI,EAC/C,MACF,CAGA,KAAK,aAAaD,EAASC,EAAgB,EAAK,CAClD,CAEQ,aACND,EACAC,EACAC,EACA,CAEA,UAAWL,KAAc,KAAK,YAE5B,GAAI,EAAAA,IAAeI,GAAkB,CAACC,GAKtC,IAAIA,GACF,GAAIL,IAAeI,EACjB,iBAKED,EAAQ,UAAYH,EAAW,aAAeG,EAAQ,SACxD,SAIJ,GAAI,CACFH,EAAW,KAAK,YAAY,CAC1B,GAAGG,EACH,WAAYC,EAAe,UAAA,CAC5B,EACD,QAAQ,IACN,2BAA2BC,EAAa,WAAa,SAAS,OAAOL,EAAW,UAAU,EAAA,CAE9F,OAASM,EAAO,CACd,QAAQ,MAAM,2CAA2CN,EAAW,UAAU,IAAKM,CAAK,EAExF,KAAK,iBAAiBN,CAAU,CAClC,EAEJ,CACF,CAEA,MAAMO,EAAS,IAAIX,EAGnB,KAAK,iBAAiB,UAAYK,GAAiB,CAEjD,MAAMH,EADeG,EACK,MAAM,CAAC,EAGjCH,EAAK,UAAaU,GAAc,CAC9B,KAAM,CAAE,KAAAC,EAAM,WAAAV,CAAA,EAAeS,EAAU,KAEnCC,IAAS,QAAUV,EACrBQ,EAAO,cAAcT,EAAMC,CAAU,GAErC,QAAQ,MAAM,sCAAuCS,EAAU,IAAI,EACnEV,EAAK,MAAA,EAET,EAEAA,EAAK,MAAA,CACP,CAAC"}