{"version":3,"file":"connect.js","sources":["../../../node_modules/@noble/ed25519/index.js","connect.ts"],"sourcesContent":["/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\n/**\n * 4KB JS implementation of ed25519 EdDSA signatures.\n * Compliant with RFC8032, FIPS 186-5 & ZIP215.\n * @module\n * @example\n * ```js\nimport * as ed from '@noble/ed25519';\n(async () => {\n  const privKey = ed.utils.randomPrivateKey();\n  const message = Uint8Array.from([0xab, 0xbc, 0xcd, 0xde]);\n  const pubKey = await ed.getPublicKeyAsync(privKey); // Sync methods are also present\n  const signature = await ed.signAsync(message, privKey);\n  const isValid = await ed.verifyAsync(signature, message, pubKey);\n})();\n```\n */\n/**\n * Curve params. ed25519 is twisted edwards curve. Equation is −x² + y² = -a + dx²y².\n * * P = `2n**255n - 19n` // field over which calculations are done\n * * N = `2n**252n + 27742317777372353535851937790883648493n` // group order, amount of curve points\n * * h = 8 // cofactor\n * * a = `Fp.create(BigInt(-1))` // equation param\n * * d = -121665/121666 a.k.a. `Fp.neg(121665 * Fp.inv(121666))` // equation param\n * * Gx, Gy are coordinates of Generator / base point\n */\nconst ed25519_CURVE = {\n    p: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffedn,\n    n: 0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3edn,\n    h: 8n,\n    a: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffecn,\n    d: 0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3n,\n    Gx: 0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51an,\n    Gy: 0x6666666666666666666666666666666666666666666666666666666666666658n,\n};\nconst { p: P, n: N, Gx, Gy, a: _a, d: _d } = ed25519_CURVE;\nconst h = 8n; // cofactor\nconst L = 32; // field / group byte length\nconst L2 = 64;\n// Helpers and Precomputes sections are reused between libraries\n// ## Helpers\n// ----------\n// error helper, messes-up stack trace\nconst err = (m = '') => {\n    throw new Error(m);\n};\nconst isBig = (n) => typeof n === 'bigint'; // is big integer\nconst isStr = (s) => typeof s === 'string'; // is string\nconst isBytes = (a) => a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n/** assert is Uint8Array (of specific length) */\nconst abytes = (a, l) => !isBytes(a) || (typeof l === 'number' && l > 0 && a.length !== l)\n    ? err('Uint8Array expected')\n    : a;\n/** create Uint8Array */\nconst u8n = (len) => new Uint8Array(len);\nconst u8fr = (buf) => Uint8Array.from(buf);\nconst padh = (n, pad) => n.toString(16).padStart(pad, '0');\nconst bytesToHex = (b) => Array.from(abytes(b))\n    .map((e) => padh(e, 2))\n    .join('');\nconst C = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 }; // ASCII characters\nconst _ch = (ch) => {\n    if (ch >= C._0 && ch <= C._9)\n        return ch - C._0; // '2' => 50-48\n    if (ch >= C.A && ch <= C.F)\n        return ch - (C.A - 10); // 'B' => 66-(65-10)\n    if (ch >= C.a && ch <= C.f)\n        return ch - (C.a - 10); // 'b' => 98-(97-10)\n    return;\n};\nconst hexToBytes = (hex) => {\n    const e = 'hex invalid';\n    if (!isStr(hex))\n        return err(e);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        return err(e);\n    const array = u8n(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        // treat each char as ASCII\n        const n1 = _ch(hex.charCodeAt(hi)); // parse first char, multiply it by 16\n        const n2 = _ch(hex.charCodeAt(hi + 1)); // parse second char\n        if (n1 === undefined || n2 === undefined)\n            return err(e);\n        array[ai] = n1 * 16 + n2; // example: 'A9' => 10*16 + 9\n    }\n    return array;\n};\n/** normalize hex or ui8a to ui8a */\nconst toU8 = (a, len) => abytes(isStr(a) ? hexToBytes(a) : u8fr(abytes(a)), len);\nconst cr = () => globalThis?.crypto; // WebCrypto is available in all modern environments\nconst subtle = () => cr()?.subtle ?? err('crypto.subtle must be defined');\n// prettier-ignore\nconst concatBytes = (...arrs) => {\n    const r = u8n(arrs.reduce((sum, a) => sum + abytes(a).length, 0)); // create u8a of summed length\n    let pad = 0; // walk through each array,\n    arrs.forEach(a => { r.set(a, pad); pad += a.length; }); // ensure they have proper type\n    return r;\n};\n/** WebCrypto OS-level CSPRNG (random number generator). Will throw when not available. */\nconst randomBytes = (len = L) => {\n    const c = cr();\n    return c.getRandomValues(u8n(len));\n};\nconst big = BigInt;\nconst arange = (n, min, max, msg = 'bad number: out of range') => isBig(n) && min <= n && n < max ? n : err(msg);\n/** modular division */\nconst M = (a, b = P) => {\n    const r = a % b;\n    return r >= 0n ? r : b + r;\n};\nconst modN = (a) => M(a, N);\n/** Modular inversion using eucledian GCD (non-CT). No negative exponent for now. */\n// prettier-ignore\nconst invert = (num, md) => {\n    if (num === 0n || md <= 0n)\n        err('no inverse n=' + num + ' mod=' + md);\n    let a = M(num, md), b = md, x = 0n, y = 1n, u = 1n, v = 0n;\n    while (a !== 0n) {\n        const q = b / a, r = b % a;\n        const m = x - u * q, n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    return b === 1n ? M(x, md) : err('no inverse'); // b is gcd at this point\n};\nconst callHash = (name) => {\n    // @ts-ignore\n    const fn = etc[name];\n    if (typeof fn !== 'function')\n        err('hashes.' + name + ' not set');\n    return fn;\n};\nconst apoint = (p) => (p instanceof Point ? p : err('Point expected'));\n// ## End of Helpers\n// -----------------\nconst B256 = 2n ** 256n;\n/** Point in XYZT extended coordinates. */\nclass Point {\n    static BASE;\n    static ZERO;\n    ex;\n    ey;\n    ez;\n    et;\n    constructor(ex, ey, ez, et) {\n        const max = B256;\n        this.ex = arange(ex, 0n, max);\n        this.ey = arange(ey, 0n, max);\n        this.ez = arange(ez, 1n, max);\n        this.et = arange(et, 0n, max);\n        Object.freeze(this);\n    }\n    static fromAffine(p) {\n        return new Point(p.x, p.y, 1n, M(p.x * p.y));\n    }\n    /** RFC8032 5.1.3: Uint8Array to Point. */\n    static fromBytes(hex, zip215 = false) {\n        const d = _d;\n        // Copy array to not mess it up.\n        const normed = u8fr(abytes(hex, L));\n        // adjust first LE byte = last BE byte\n        const lastByte = hex[31];\n        normed[31] = lastByte & ~0x80;\n        const y = bytesToNumLE(normed);\n        // zip215=true:           0 <= y < 2^256\n        // zip215=false, RFC8032: 0 <= y < 2^255-19\n        const max = zip215 ? B256 : P;\n        arange(y, 0n, max);\n        const y2 = M(y * y); // y²\n        const u = M(y2 - 1n); // u=y²-1\n        const v = M(d * y2 + 1n); // v=dy²+1\n        let { isValid, value: x } = uvRatio(u, v); // (uv³)(uv⁷)^(p-5)/8; square root\n        if (!isValid)\n            err('bad point: y not sqrt'); // not square root: bad point\n        const isXOdd = (x & 1n) === 1n; // adjust sign of x coordinate\n        const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n        if (!zip215 && x === 0n && isLastByteOdd)\n            err('bad point: x==0, isLastByteOdd'); // x=0, x_0=1\n        if (isLastByteOdd !== isXOdd)\n            x = M(-x);\n        return new Point(x, y, 1n, M(x * y)); // Z=1, T=xy\n    }\n    /** Checks if the point is valid and on-curve. */\n    assertValidity() {\n        const a = _a;\n        const d = _d;\n        const p = this;\n        if (p.is0())\n            throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n        // Equation in affine coordinates: ax² + y² = 1 + dx²y²\n        // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX² + Y²)Z² = Z⁴ + dX²Y²\n        const { ex: X, ey: Y, ez: Z, et: T } = p;\n        const X2 = M(X * X); // X²\n        const Y2 = M(Y * Y); // Y²\n        const Z2 = M(Z * Z); // Z²\n        const Z4 = M(Z2 * Z2); // Z⁴\n        const aX2 = M(X2 * a); // aX²\n        const left = M(Z2 * M(aX2 + Y2)); // (aX² + Y²)Z²\n        const right = M(Z4 + M(d * M(X2 * Y2))); // Z⁴ + dX²Y²\n        if (left !== right)\n            throw new Error('bad point: equation left != right (1)');\n        // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n        const XY = M(X * Y);\n        const ZT = M(Z * T);\n        if (XY !== ZT)\n            throw new Error('bad point: equation left != right (2)');\n        return this;\n    }\n    /** Equality check: compare points P&Q. */\n    equals(other) {\n        const { ex: X1, ey: Y1, ez: Z1 } = this;\n        const { ex: X2, ey: Y2, ez: Z2 } = apoint(other); // checks class equality\n        const X1Z2 = M(X1 * Z2);\n        const X2Z1 = M(X2 * Z1);\n        const Y1Z2 = M(Y1 * Z2);\n        const Y2Z1 = M(Y2 * Z1);\n        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n    is0() {\n        return this.equals(I);\n    }\n    /** Flip point over y coordinate. */\n    negate() {\n        return new Point(M(-this.ex), this.ey, this.ez, M(-this.et));\n    }\n    /** Point doubling. Complete formula. Cost: `4M + 4S + 1*a + 6add + 1*2`. */\n    double() {\n        const { ex: X1, ey: Y1, ez: Z1 } = this;\n        const a = _a;\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n        const A = M(X1 * X1);\n        const B = M(Y1 * Y1);\n        const C = M(2n * M(Z1 * Z1));\n        const D = M(a * A);\n        const x1y1 = X1 + Y1;\n        const E = M(M(x1y1 * x1y1) - A - B);\n        const G = D + B;\n        const F = G - C;\n        const H = D - B;\n        const X3 = M(E * F);\n        const Y3 = M(G * H);\n        const T3 = M(E * H);\n        const Z3 = M(F * G);\n        return new Point(X3, Y3, Z3, T3);\n    }\n    /** Point addition. Complete formula. Cost: `8M + 1*k + 8add + 1*2`. */\n    add(other) {\n        const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;\n        const { ex: X2, ey: Y2, ez: Z2, et: T2 } = apoint(other); // doesn't check if other on-curve\n        const a = _a;\n        const d = _d;\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-3\n        const A = M(X1 * X2);\n        const B = M(Y1 * Y2);\n        const C = M(T1 * d * T2);\n        const D = M(Z1 * Z2);\n        const E = M((X1 + Y1) * (X2 + Y2) - A - B);\n        const F = M(D - C);\n        const G = M(D + C);\n        const H = M(B - a * A);\n        const X3 = M(E * F);\n        const Y3 = M(G * H);\n        const T3 = M(E * H);\n        const Z3 = M(F * G);\n        return new Point(X3, Y3, Z3, T3);\n    }\n    /**\n     * Point-by-scalar multiplication. Scalar must be in range 1 <= n < CURVE.n.\n     * Uses {@link wNAF} for base point.\n     * Uses fake point to mitigate side-channel leakage.\n     * @param n scalar by which point is multiplied\n     * @param safe safe mode guards against timing attacks; unsafe mode is faster\n     */\n    multiply(n, safe = true) {\n        if (!safe && (n === 0n || this.is0()))\n            return I;\n        arange(n, 1n, N);\n        if (n === 1n)\n            return this;\n        if (this.equals(G))\n            return wNAF(n).p;\n        // init result point & fake point\n        let p = I;\n        let f = G;\n        for (let d = this; n > 0n; d = d.double(), n >>= 1n) {\n            // if bit is present, add to point\n            // if not present, add to fake, for timing safety\n            if (n & 1n)\n                p = p.add(d);\n            else if (safe)\n                f = f.add(d);\n        }\n        return p;\n    }\n    /** Convert point to 2d xy affine point. (X, Y, Z) ∋ (x=X/Z, y=Y/Z) */\n    toAffine() {\n        const { ex: x, ey: y, ez: z } = this;\n        // fast-paths for ZERO point OR Z=1\n        if (this.equals(I))\n            return { x: 0n, y: 1n };\n        const iz = invert(z, P);\n        // (Z * Z^-1) must be 1, otherwise bad math\n        if (M(z * iz) !== 1n)\n            err('invalid inverse');\n        // x = X*Z^-1; y = Y*Z^-1\n        return { x: M(x * iz), y: M(y * iz) };\n    }\n    toBytes() {\n        const { x, y } = this.assertValidity().toAffine();\n        const b = numTo32bLE(y);\n        // store sign in first LE byte\n        b[31] |= x & 1n ? 0x80 : 0;\n        return b;\n    }\n    toHex() {\n        return bytesToHex(this.toBytes());\n    } // encode to hex string\n    clearCofactor() {\n        return this.multiply(big(h), false);\n    }\n    isSmallOrder() {\n        return this.clearCofactor().is0();\n    }\n    isTorsionFree() {\n        // multiply by big number CURVE.n\n        let p = this.multiply(N / 2n, false).double(); // ensures the point is not \"bad\".\n        if (N % 2n)\n            p = p.add(this); // P^(N+1) // P*N == (P*(N/2))*2+P\n        return p.is0();\n    }\n    static fromHex(hex, zip215) {\n        return Point.fromBytes(toU8(hex), zip215);\n    }\n    get x() {\n        return this.toAffine().x;\n    }\n    get y() {\n        return this.toAffine().y;\n    }\n    toRawBytes() {\n        return this.toBytes();\n    }\n}\n/** Generator / base point */\nconst G = new Point(Gx, Gy, 1n, M(Gx * Gy));\n/** Identity / zero point */\nconst I = new Point(0n, 1n, 1n, 0n);\n// Static aliases\nPoint.BASE = G;\nPoint.ZERO = I;\nconst numTo32bLE = (num) => hexToBytes(padh(arange(num, 0n, B256), L2)).reverse();\nconst bytesToNumLE = (b) => big('0x' + bytesToHex(u8fr(abytes(b)).reverse()));\nconst pow2 = (x, power) => {\n    // pow2(x, 4) == x^(2^4)\n    let r = x;\n    while (power-- > 0n) {\n        r *= r;\n        r %= P;\n    }\n    return r;\n};\n// prettier-ignore\nconst pow_2_252_3 = (x) => {\n    const x2 = (x * x) % P; // x^2,       bits 1\n    const b2 = (x2 * x) % P; // x^3,       bits 11\n    const b4 = (pow2(b2, 2n) * b2) % P; // x^(2^4-1), bits 1111\n    const b5 = (pow2(b4, 1n) * x) % P; // x^(2^5-1), bits 11111\n    const b10 = (pow2(b5, 5n) * b5) % P; // x^(2^10)\n    const b20 = (pow2(b10, 10n) * b10) % P; // x^(2^20)\n    const b40 = (pow2(b20, 20n) * b20) % P; // x^(2^40)\n    const b80 = (pow2(b40, 40n) * b40) % P; // x^(2^80)\n    const b160 = (pow2(b80, 80n) * b80) % P; // x^(2^160)\n    const b240 = (pow2(b160, 80n) * b80) % P; // x^(2^240)\n    const b250 = (pow2(b240, 10n) * b10) % P; // x^(2^250)\n    const pow_p_5_8 = (pow2(b250, 2n) * x) % P; // < To pow to (p+3)/8, multiply it by x.\n    return { pow_p_5_8, b2 };\n};\nconst RM1 = 0x2b8324804fc1df0b2b4d00993dfbd7a72f431806ad2fe478c4ee1b274a0ea0b0n; // √-1\n// for sqrt comp\n// prettier-ignore\nconst uvRatio = (u, v) => {\n    const v3 = M(v * v * v); // v³\n    const v7 = M(v3 * v3 * v); // v⁷\n    const pow = pow_2_252_3(u * v7).pow_p_5_8; // (uv⁷)^(p-5)/8\n    let x = M(u * v3 * pow); // (uv³)(uv⁷)^(p-5)/8\n    const vx2 = M(v * x * x); // vx²\n    const root1 = x; // First root candidate\n    const root2 = M(x * RM1); // Second root candidate; RM1 is √-1\n    const useRoot1 = vx2 === u; // If vx² = u (mod p), x is a square root\n    const useRoot2 = vx2 === M(-u); // If vx² = -u, set x <-- x * 2^((p-1)/4)\n    const noRoot = vx2 === M(-u * RM1); // There is no valid root, vx² = -u√-1\n    if (useRoot1)\n        x = root1;\n    if (useRoot2 || noRoot)\n        x = root2; // We return root2 anyway, for const-time\n    if ((M(x) & 1n) === 1n)\n        x = M(-x); // edIsNegative\n    return { isValid: useRoot1 || useRoot2, value: x };\n};\n// N == L, just weird naming\nconst modL_LE = (hash) => modN(bytesToNumLE(hash)); // modulo L; but little-endian\nconst sha512a = (...m) => etc.sha512Async(...m); // Async SHA512\nconst sha512s = (...m) => callHash('sha512Sync')(...m);\n// RFC8032 5.1.5\nconst hash2extK = (hashed) => {\n    // slice creates a copy, unlike subarray\n    const head = hashed.slice(0, L);\n    head[0] &= 248; // Clamp bits: 0b1111_1000\n    head[31] &= 127; // 0b0111_1111\n    head[31] |= 64; // 0b0100_0000\n    const prefix = hashed.slice(L, L2); // private key \"prefix\"\n    const scalar = modL_LE(head); // modular division over curve order\n    const point = G.multiply(scalar); // public key point\n    const pointBytes = point.toBytes(); // point serialized to Uint8Array\n    return { head, prefix, scalar, point, pointBytes };\n};\n// RFC8032 5.1.5; getPublicKey async, sync. Hash priv key and extract point.\nconst getExtendedPublicKeyAsync = (priv) => sha512a(toU8(priv, L)).then(hash2extK);\nconst getExtendedPublicKey = (priv) => hash2extK(sha512s(toU8(priv, L)));\n/** Creates 32-byte ed25519 public key from 32-byte private key. Async. */\nconst getPublicKeyAsync = (priv) => getExtendedPublicKeyAsync(priv).then((p) => p.pointBytes);\n/** Creates 32-byte ed25519 public key from 32-byte private key. To use, set `etc.sha512Sync` first. */\nconst getPublicKey = (priv) => getExtendedPublicKey(priv).pointBytes;\nconst hashFinishA = (res) => sha512a(res.hashable).then(res.finish);\nconst hashFinishS = (res) => res.finish(sha512s(res.hashable));\nconst _sign = (e, rBytes, msg) => {\n    // sign() shared code\n    const { pointBytes: P, scalar: s } = e;\n    const r = modL_LE(rBytes); // r was created outside, reduce it modulo L\n    const R = G.multiply(r).toBytes(); // R = [r]B\n    const hashable = concatBytes(R, P, msg); // dom2(F, C) || R || A || PH(M)\n    const finish = (hashed) => {\n        // k = SHA512(dom2(F, C) || R || A || PH(M))\n        const S = modN(r + modL_LE(hashed) * s); // S = (r + k * s) mod L; 0 <= s < l\n        return abytes(concatBytes(R, numTo32bLE(S)), L2); // 64-byte sig: 32b R.x + 32b LE(S)\n    };\n    return { hashable, finish };\n};\n/**\n * Signs message (NOT message hash) using private key. Async.\n * Follows RFC8032 5.1.6.\n */\nconst signAsync = async (msg, privKey) => {\n    const m = toU8(msg);\n    const e = await getExtendedPublicKeyAsync(privKey);\n    const rBytes = await sha512a(e.prefix, m); // r = SHA512(dom2(F, C) || prefix || PH(M))\n    return hashFinishA(_sign(e, rBytes, m)); // gen R, k, S, then 64-byte signature\n};\n/**\n * Signs message (NOT message hash) using private key. To use, set `hashes.sha512` first.\n * Follows RFC8032 5.1.6.\n */\nconst sign = (msg, privKey) => {\n    const m = toU8(msg);\n    const e = getExtendedPublicKey(privKey);\n    const rBytes = sha512s(e.prefix, m); // r = SHA512(dom2(F, C) || prefix || PH(M))\n    return hashFinishS(_sign(e, rBytes, m)); // gen R, k, S, then 64-byte signature\n};\nconst veriOpts = { zip215: true };\nconst _verify = (sig, msg, pub, opts = veriOpts) => {\n    sig = toU8(sig, L2); // Signature hex str/Bytes, must be 64 bytes\n    msg = toU8(msg); // Message hex str/Bytes\n    pub = toU8(pub, L);\n    const { zip215 } = opts; // switch between zip215 and rfc8032 verif\n    let A;\n    let R;\n    let s;\n    let SB;\n    let hashable = Uint8Array.of();\n    try {\n        A = Point.fromHex(pub, zip215); // public key A decoded\n        R = Point.fromHex(sig.slice(0, L), zip215); // 0 <= R < 2^256: ZIP215 R can be >= P\n        s = bytesToNumLE(sig.slice(L, L2)); // Decode second half as an integer S\n        SB = G.multiply(s, false); // in the range 0 <= s < L\n        hashable = concatBytes(R.toBytes(), A.toBytes(), msg); // dom2(F, C) || R || A || PH(M)\n    }\n    catch (error) { }\n    const finish = (hashed) => {\n        // k = SHA512(dom2(F, C) || R || A || PH(M))\n        if (SB == null)\n            return false; // false if try-catch catched an error\n        if (!zip215 && A.isSmallOrder())\n            return false; // false for SBS: Strongly Binding Signature\n        const k = modL_LE(hashed); // decode in little-endian, modulo L\n        const RkA = R.add(A.multiply(k, false)); // [8]R + [8][k]A'\n        return RkA.add(SB.negate()).clearCofactor().is0(); // [8][S]B = [8]R + [8][k]A'\n    };\n    return { hashable, finish };\n};\n/** Verifies signature on message and public key. Async. Follows RFC8032 5.1.7. */\nconst verifyAsync = async (s, m, p, opts = veriOpts) => hashFinishA(_verify(s, m, p, opts));\n/** Verifies signature on message and public key. To use, set `hashes.sha512` first. Follows RFC8032 5.1.7. */\nconst verify = (s, m, p, opts = veriOpts) => hashFinishS(_verify(s, m, p, opts));\n/** Math, hex, byte helpers. Not in `utils` because utils share API with noble-curves. */\nconst etc = {\n    sha512Async: async (...messages) => {\n        const s = subtle();\n        const m = concatBytes(...messages);\n        return u8n(await s.digest('SHA-512', m.buffer));\n    },\n    sha512Sync: undefined,\n    bytesToHex: bytesToHex,\n    hexToBytes: hexToBytes,\n    concatBytes: concatBytes,\n    mod: M,\n    invert: invert,\n    randomBytes: randomBytes,\n};\n/** ed25519-specific key utilities. */\nconst utils = {\n    getExtendedPublicKeyAsync: getExtendedPublicKeyAsync,\n    getExtendedPublicKey: getExtendedPublicKey,\n    randomPrivateKey: () => randomBytes(L),\n    precompute: (w = 8, p = G) => {\n        p.multiply(3n);\n        w;\n        return p;\n    }, // no-op\n};\n// ## Precomputes\n// --------------\nconst W = 8; // W is window size\nconst scalarBits = 256;\nconst pwindows = Math.ceil(scalarBits / W) + 1; // 33 for W=8\nconst pwindowSize = 2 ** (W - 1); // 128 for W=8\nconst precompute = () => {\n    const points = [];\n    let p = G;\n    let b = p;\n    for (let w = 0; w < pwindows; w++) {\n        b = p;\n        points.push(b);\n        for (let i = 1; i < pwindowSize; i++) {\n            b = b.add(p);\n            points.push(b);\n        } // i=1, bc we skip 0\n        p = b.double();\n    }\n    return points;\n};\nlet Gpows = undefined; // precomputes for base point G\n// const-time negate\nconst ctneg = (cnd, p) => {\n    const n = p.negate();\n    return cnd ? n : p;\n};\n/**\n * Precomputes give 12x faster getPublicKey(), 10x sign(), 2x verify() by\n * caching multiples of G (base point). Cache is stored in 32MB of RAM.\n * Any time `G.multiply` is done, precomputes are used.\n * Not used for getSharedSecret, which instead multiplies random pubkey `P.multiply`.\n *\n * w-ary non-adjacent form (wNAF) precomputation method is 10% slower than windowed method,\n * but takes 2x less RAM. RAM reduction is possible by utilizing `.subtract`.\n *\n * !! Precomputes can be disabled by commenting-out call of the wNAF() inside Point#multiply().\n */\nconst wNAF = (n) => {\n    const comp = Gpows || (Gpows = precompute());\n    let p = I;\n    let f = G; // f must be G, or could become I in the end\n    const pow_2_w = 2 ** W; // 256 for W=8\n    const maxNum = pow_2_w; // 256 for W=8\n    const mask = big(pow_2_w - 1); // 255 for W=8 == mask 0b11111111\n    const shiftBy = big(W); // 8 for W=8\n    for (let w = 0; w < pwindows; w++) {\n        let wbits = Number(n & mask); // extract W bits.\n        n >>= shiftBy; // shift number by W bits.\n        if (wbits > pwindowSize) {\n            wbits -= maxNum;\n            n += 1n;\n        } // split if bits > max: +224 => 256-32\n        const off = w * pwindowSize;\n        const offF = off; // offsets, evaluate both\n        const offP = off + Math.abs(wbits) - 1;\n        const isEven = w % 2 !== 0; // conditions, evaluate both\n        const isNeg = wbits < 0;\n        if (wbits === 0) {\n            // off == I: can't add it. Adding random offF instead.\n            f = f.add(ctneg(isEven, comp[offF])); // bits are 0: add garbage to fake point\n        }\n        else {\n            p = p.add(ctneg(isNeg, comp[offP])); // bits are 1: add to result point\n        }\n    }\n    return { p, f }; // return both real and fake points for JIT\n};\n// !! Remove the export to easily use in REPL / browser console\nexport { ed25519_CURVE as CURVE, etc, Point as ExtendedPoint, getPublicKey, getPublicKeyAsync, Point, sign, signAsync, utils, verify, verifyAsync, };\n","/// <reference lib=\"DOM\" />\nimport { authenticate } from '@proven-network/common';\nimport { MessageBroker, getWindowIdFromUrl } from '@proven-network/common';\nimport { hexToBytes } from '@noble/curves/abstract/utils';\nimport {\n  Anonymize,\n  Identify,\n  WhoAmI,\n  WhoAmIResult,\n  AnonymizeResponse,\n  IdentifyResponse,\n  RpcResponse,\n} from '@proven-network/common';\nimport { signAsync, getPublicKeyAsync } from '@noble/ed25519';\nimport { getSession } from '@proven-network/common';\n\nclass ConnectClient {\n  applicationId: string;\n  broker: MessageBroker;\n  windowId: string;\n\n  constructor() {\n    // Extract application ID from URL path\n    this.applicationId = globalThis.location.pathname.split('/')[2] || 'unknown';\n\n    // Extract window ID from URL fragment\n    this.windowId = getWindowIdFromUrl() || 'unknown';\n\n    // Initialize broker synchronously - will throw if it fails\n    this.broker = new MessageBroker(this.windowId, 'connect');\n\n    this.initializeBroker();\n  }\n\n  async initializeBroker() {\n    try {\n      await this.broker.connect();\n\n      // Set up message handlers\n      this.broker.on('registration_complete', async (message) => {\n        console.debug('Connect: Registration completed', message.data);\n\n        // Handle successful registration\n        if (message.data.prfResult) {\n          await this.handleSuccessfulAuth(message.data.prfResult);\n        }\n      });\n    } catch (error) {\n      console.error('Connect: Failed to initialize broker:', error);\n      throw new Error(\n        `Connect: Failed to initialize broker: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  async handleSuccessfulAuth(prfResult: Uint8Array) {\n    console.debug('Connect: Authentication successful, sending identify RPC');\n\n    // Send identify RPC request\n    try {\n      const session = await getSession(this.applicationId);\n\n      if (!session) {\n        throw new Error('Session not found');\n      }\n\n      const sessionId = hexToBytes(session.sessionId.replace(/-/g, ''));\n\n      // Get the public key from the PRF result\n      const publicKey = await getPublicKeyAsync(prfResult);\n\n      // Sign the session ID with the PRF result\n      const sessionIdSignature = await signAsync(sessionId, prfResult);\n\n      const identifyRequest: Identify = {\n        type: 'Identify',\n        data: {\n          passkey_prf_public_key_bytes: publicKey,\n          session_id_signature_bytes: sessionIdSignature,\n        },\n      };\n\n      const response = await this.broker.request<{\n        success: boolean;\n        data?: IdentifyResponse;\n        error?: string;\n      }>('rpc_request', identifyRequest, 'rpc');\n\n      console.debug('Connect: Identify RPC response:', response);\n\n      if (!response.success) {\n        throw new Error(response.error || 'Identify request failed');\n      }\n\n      if (!response.data || response.data.type !== 'Identify') {\n        throw new Error('Invalid response format from Identify');\n      }\n\n      const identifyResult = response.data.data;\n      if (identifyResult.result !== 'success') {\n        throw new Error(identifyResult.data as string);\n      }\n\n      // Only update UI after successful identify RPC\n      console.debug('Connect: Identify successful, updating UI');\n      await this.updateAuthUI();\n    } catch (error) {\n      console.error('Connect: Failed to send identify RPC request:', error);\n    }\n  }\n\n  // Auth state methods\n  async isSignedIn(): Promise<boolean> {\n    try {\n      const whoAmIRequest: WhoAmI = { type: 'WhoAmI', data: null };\n      const response = await this.broker.request<{\n        success: boolean;\n        data?: RpcResponse<WhoAmIResult>;\n        error?: string;\n      }>('rpc_request', whoAmIRequest, 'rpc');\n\n      if (!response.success) {\n        console.error('Connect: WhoAmI request failed:', response.error);\n        return false;\n      }\n\n      if (!response.data || response.data.type !== 'WhoAmI') {\n        console.error('Connect: Invalid WhoAmI response format');\n        return false;\n      }\n\n      const whoAmIResult = response.data.data;\n      console.debug('Connect: WhoAmI response:', whoAmIResult);\n\n      // Check if the user is identified (signed in)\n      return whoAmIResult.result === 'identified';\n    } catch (error) {\n      console.error('Connect: Failed to check auth status:', error);\n      return false;\n    }\n  }\n\n  async signOut(): Promise<void> {\n    try {\n      const anonymizeRequest: Anonymize = { type: 'Anonymize', data: null };\n      const response = await this.broker.request<{\n        success: boolean;\n        data?: AnonymizeResponse;\n        error?: string;\n      }>('rpc_request', anonymizeRequest, 'rpc');\n\n      console.debug('Connect: Anonymize RPC response:', response);\n\n      if (!response.success) {\n        throw new Error(response.error || 'Anonymize request failed');\n      }\n\n      if (!response.data || response.data.type !== 'Anonymize') {\n        throw new Error('Invalid response format from Anonymize');\n      }\n\n      const anonymizeResult = response.data.data;\n      if (anonymizeResult.result !== 'success') {\n        throw new Error(anonymizeResult.data as string);\n      }\n\n      await this.updateAuthUI();\n    } catch (error) {\n      console.error('Connect: Failed to sign out:', error);\n    }\n  }\n\n  async updateAuthUI() {\n    const userSignedIn = await this.isSignedIn();\n    const signedOutView = document.getElementById('signed-out-view');\n    const signedInView = document.getElementById('signed-in-view');\n    const container = document.getElementById('auth-container');\n\n    if (userSignedIn) {\n      signedOutView!.style.display = 'none';\n      signedInView!.style.display = 'block';\n    } else {\n      signedOutView!.style.display = 'block';\n      signedInView!.style.display = 'none';\n      this.resetSignInButton();\n    }\n\n    // Show the container now that we've set the correct state\n    container!.classList.add('ready');\n  }\n\n  resetSignInButton() {\n    const button = document.getElementById('auth-button') as HTMLButtonElement;\n    if (button) {\n      button.textContent = 'Sign In';\n      button.disabled = false;\n    }\n  }\n\n  async handleSignIn() {\n    const button = document.getElementById('auth-button') as HTMLButtonElement;\n    button.disabled = true;\n    button.textContent = 'Signing in...';\n\n    try {\n      const prfResult = await authenticate();\n      console.debug('Authentication successful with PRF result');\n      await this.handleSuccessfulAuth(prfResult);\n    } catch (error) {\n      console.error('Authentication error:', error);\n\n      // Check if this is a \"no credentials\" error\n      const errorMessage = (error as Error).message?.toLowerCase() || '';\n      const isNoCredentialsError =\n        (error as Error).name === 'NotAllowedError' && errorMessage.includes('immediate');\n\n      if (isNoCredentialsError) {\n        console.debug('No credentials found, opening registration modal');\n        // Send message directly to sdk via broker\n        await this.broker.send('open_registration_modal', null, 'sdk');\n        this.resetSignInButton();\n      } else {\n        // Other error (user cancelled, PRF not available, etc.)\n        let errorMessage = 'Sign-in failed';\n        if ((error as Error).name === 'NotAllowedError') {\n          errorMessage = 'Sign-in was cancelled';\n        } else if ((error as Error).message) {\n          errorMessage = (error as Error).message;\n        }\n\n        this.resetSignInButton();\n      }\n    }\n  }\n\n  // Initialize the client when the page loads\n  static init() {\n    const client = new ConnectClient();\n\n    // Set up event listeners\n    window.addEventListener('load', () => {\n      const authButton = document.getElementById('auth-button');\n      const signoutButton = document.getElementById('signout-button');\n\n      if (authButton) {\n        authButton.addEventListener('click', () => client.handleSignIn());\n      }\n\n      if (signoutButton) {\n        signoutButton.addEventListener('click', () => client.signOut());\n      }\n\n      // Initialize UI state\n      client.updateAuthUI().catch(console.error);\n    });\n\n    // Make client available globally for debugging\n    (globalThis as any).buttonClient = client;\n  }\n}\n\n// Initialize when the page loads\nif (globalThis.addEventListener) {\n  globalThis.addEventListener('DOMContentLoaded', ConnectClient.init);\n} else {\n  // Fallback for cases where DOMContentLoaded has already fired\n  ConnectClient.init();\n}\n"],"names":["ed25519_CURVE","P","N","Gx","Gy","_a","_d","h","L","L2","err","m","isBig","isStr","s","isBytes","a","abytes","l","u8n","len","u8fr","buf","padh","pad","bytesToHex","b","e","C","_ch","ch","hexToBytes","hex","hl","al","array","ai","hi","n1","n2","toU8","cr","subtle","concatBytes","arrs","r","sum","randomBytes","big","arange","min","max","msg","M","modN","invert","num","md","x","u","q","apoint","p","Point","B256","_Point","ex","ey","ez","et","__publicField","zip215","d","normed","lastByte","y","bytesToNumLE","y2","v","isValid","uvRatio","isXOdd","isLastByteOdd","X","Y","Z","T","X2","Y2","Z2","Z4","aX2","left","right","XY","ZT","other","X1","Y1","Z1","X1Z2","X2Z1","Y1Z2","Y2Z1","I","A","B","D","x1y1","E","G","F","H","X3","Y3","T3","Z3","T1","T2","n","safe","wNAF","f","z","iz","numTo32bLE","pow2","power","pow_2_252_3","b2","b4","b5","b10","b20","b40","b80","b160","b240","b250","RM1","v3","v7","pow","vx2","root1","root2","useRoot1","useRoot2","noRoot","modL_LE","hash","sha512a","etc","hash2extK","hashed","head","prefix","scalar","point","pointBytes","getExtendedPublicKeyAsync","priv","getPublicKeyAsync","hashFinishA","res","_sign","rBytes","R","S","signAsync","privKey","messages","W","scalarBits","pwindows","pwindowSize","precompute","points","w","Gpows","ctneg","cnd","comp","pow_2_w","maxNum","mask","shiftBy","wbits","off","offF","offP","isEven","isNeg","ConnectClient","getWindowIdFromUrl","MessageBroker","message","error","prfResult","session","getSession","sessionId","publicKey","sessionIdSignature","identifyRequest","response","identifyResult","whoAmIRequest","whoAmIResult","anonymizeRequest","anonymizeResult","userSignedIn","signedOutView","signedInView","container","button","authenticate","errorMessage","client","authButton","signoutButton"],"mappings":"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","x_google_ignoreList":[0]}