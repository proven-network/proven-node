{"version":3,"file":"rpc.js","sources":["rpc.ts"],"sourcesContent":["/// <reference lib=\"DOM\" />\nimport { createSession, getSession } from '@proven-network/common';\nimport { CoseSign1Decoder, CoseSign1Encoder } from '@proven-network/common';\nimport { bytesToHex, hexToBytes } from '@noble/curves/abstract/utils';\nimport { MessageBroker, getWindowIdFromUrl } from '@proven-network/common';\n\n// Generic message types for broker communication\ntype RpcRequest = {\n  type: 'rpc_request';\n  data: any; // The raw RPC call data to be signed\n};\n\ntype RpcResponse = {\n  success: boolean;\n  data?: any;\n  error?: string;\n};\n\nclass RpcClient {\n  worker: SharedWorker | null = null;\n  session: any;\n  coseEncoder: any;\n  coseDecoder: any;\n  broker: MessageBroker;\n  windowId: string;\n  pendingRequests = new Map<\n    number,\n    { resolve: (data: any) => void; reject: (error: Error) => void }\n  >();\n  private requestCounter = 0;\n  private initializationPromise: Promise<void> | null = null;\n  private isInitialized = false;\n  private queuedRequests: Array<{\n    rpcCallData: any;\n    resolve: (response: RpcResponse) => void;\n    reject: (error: Error) => void;\n  }> = [];\n\n  constructor() {\n    // Extract window ID from URL fragment\n    this.windowId = getWindowIdFromUrl() || 'unknown';\n\n    // Initialize broker synchronously - will throw if it fails\n    this.broker = new MessageBroker(this.windowId, 'rpc');\n\n    // Initialize broker immediately but defer session initialization\n    this.initializeBroker();\n  }\n\n  private async ensureInitialized(): Promise<void> {\n    if (this.isInitialized) {\n      return;\n    }\n\n    if (this.initializationPromise) {\n      return this.initializationPromise;\n    }\n\n    this.initializationPromise = this.initializeSession();\n    return this.initializationPromise;\n  }\n\n  private async initializeSession(): Promise<void> {\n    const urlParams = new URLSearchParams(window.location.search);\n    const applicationId = urlParams.get('app') || 'application_id';\n\n    try {\n      console.debug('RPC: Initializing session...');\n\n      let session = await getSession(applicationId);\n\n      if (!session) {\n        console.debug('RPC: Creating new session...');\n        session = await createSession(applicationId);\n        console.debug('RPC: Session created!', session);\n      }\n\n      this.session = session;\n      await this.setupCose();\n      await this.setupWorkerCommunication();\n\n      this.isInitialized = true;\n      console.debug('RPC: Client initialized successfully');\n\n      // Process any queued requests\n      await this.processQueuedRequests();\n    } catch (error) {\n      console.error('RPC: Failed to initialize session:', error);\n      this.initializationPromise = null; // Allow retry\n      throw error;\n    }\n  }\n\n  private async processQueuedRequests(): Promise<void> {\n    console.debug(`RPC: Processing ${this.queuedRequests.length} queued requests`);\n\n    const requests = [...this.queuedRequests];\n    this.queuedRequests = [];\n\n    for (const request of requests) {\n      try {\n        const response = await this.executeRpcRequest(request.rpcCallData);\n        request.resolve(response);\n      } catch (error) {\n        request.reject(error instanceof Error ? error : new Error('Unknown error'));\n      }\n    }\n  }\n\n  async setupCose() {\n    const externalAad = hexToBytes(this.session.sessionId.replace(/-/g, ''));\n\n    this.coseEncoder = CoseSign1Encoder(this.session.signingKey, externalAad);\n    this.coseDecoder = CoseSign1Decoder(this.session.verifyingKey, externalAad);\n  }\n\n  async setupWorkerCommunication() {\n    this.worker = new SharedWorker(`../workers/rpc-worker.js?session=${this.session.sessionId}`);\n\n    this.worker.port.start();\n    this.worker.port.onmessage = (e) => {\n      this.handleWorkerMessage(e.data);\n    };\n  }\n\n  private async initializeBroker() {\n    try {\n      await this.broker.connect();\n\n      // Set up generic message handler for rpc_request requests\n      this.broker.on('rpc_request', async (message, respond) => {\n        if (respond) {\n          try {\n            const result = await this.handleRpcRequest(message.data);\n            respond(result);\n          } catch (error) {\n            respond({\n              success: false,\n              error: error instanceof Error ? error.message : 'Unknown error',\n            });\n          }\n        }\n      });\n\n      console.debug('RPC: Broker initialized successfully');\n    } catch (error) {\n      console.error('RPC: Failed to initialize broker:', error);\n      throw new Error(\n        `RPC: Failed to initialize broker: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  private getNextRequestId(): number {\n    return ++this.requestCounter;\n  }\n\n  async handleRpcRequest(rpcCallData: any): Promise<RpcResponse> {\n    // Check if we're initialized\n    if (!this.isInitialized) {\n      // If not initialized, either queue the request or start initialization\n      return new Promise((resolve, reject) => {\n        // Queue this request\n        this.queuedRequests.push({\n          rpcCallData,\n          resolve,\n          reject,\n        });\n\n        // Start initialization if not already started\n        this.ensureInitialized().catch((error) => {\n          // If initialization fails, reject all queued requests\n          const requests = [...this.queuedRequests];\n          this.queuedRequests = [];\n\n          for (const request of requests) {\n            request.reject(error);\n          }\n        });\n      });\n    }\n\n    // If we're initialized, execute the request directly\n    return this.executeRpcRequest(rpcCallData);\n  }\n\n  private async executeRpcRequest(rpcCallData: any): Promise<RpcResponse> {\n    try {\n      const requestId = this.getNextRequestId();\n\n      // Sign the RPC call data with COSE\n      const encodedData = await this.coseEncoder.encode(rpcCallData, {\n        seq: requestId,\n      });\n\n      // Create promise for the response\n      const responsePromise = new Promise<any>((resolve, reject) => {\n        this.pendingRequests.set(requestId, { resolve, reject });\n\n        // Set timeout\n        setTimeout(() => {\n          if (this.pendingRequests.has(requestId)) {\n            this.pendingRequests.delete(requestId);\n            reject(new Error('Request timeout'));\n          }\n        }, 30000); // 30 second timeout\n      });\n\n      // Send to worker\n      if (this.worker) {\n        this.worker.port.postMessage({\n          type: 'send',\n          nonce: requestId,\n          data: encodedData,\n        });\n      } else {\n        throw new Error('Worker not initialized');\n      }\n\n      // Wait for response\n      const responseData = await responsePromise;\n\n      return {\n        success: true,\n        data: responseData,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      };\n    }\n  }\n\n  async handleWorkerMessage(message: any) {\n    if (message.type === 'ws-message' || message.type === 'http-response') {\n      try {\n        // Decode COSE message\n        const data = new Uint8Array(message.data);\n        const decodedResult = await this.coseDecoder.decodeAndVerify(data);\n\n        if (decodedResult.isOk()) {\n          const { seq } = decodedResult.value.headers;\n          if (typeof seq === 'number') {\n            const pendingRequest = this.pendingRequests.get(seq);\n            if (pendingRequest) {\n              this.pendingRequests.delete(seq);\n              pendingRequest.resolve(decodedResult.value.payload);\n            }\n          }\n        } else {\n          console.error('RPC: Failed to decode COSE message:', decodedResult.error);\n        }\n      } catch (error) {\n        console.error('RPC: Error handling response message:', error);\n      }\n    } else if (message.type === 'http-error') {\n      // Handle HTTP errors\n      const pendingRequest = this.pendingRequests.get(message.nonce);\n      if (pendingRequest) {\n        this.pendingRequests.delete(message.nonce);\n        pendingRequest.reject(new Error(message.error));\n      }\n    }\n  }\n\n  // Initialize the client when the page loads\n  static init() {\n    const client = new RpcClient();\n\n    // Make client available globally for debugging\n    (globalThis as any).rpcClient = client;\n  }\n}\n\n// Initialize when the page loads\nif (globalThis.addEventListener) {\n  globalThis.addEventListener('DOMContentLoaded', RpcClient.init);\n} else {\n  // Fallback for cases where DOMContentLoaded has already fired\n  RpcClient.init();\n}\n"],"names":["RpcClient","__publicField","getWindowIdFromUrl","MessageBroker","applicationId","session","getSession","createSession","error","requests","request","response","externalAad","hexToBytes","CoseSign1Encoder","CoseSign1Decoder","message","respond","result","rpcCallData","resolve","reject","requestId","encodedData","responsePromise","data","decodedResult","seq","pendingRequest","client"],"mappings":"8SAkBA,MAAMA,CAAU,CAoBd,aAAc,CAnBdC,EAAA,cAA8B,MAC9BA,EAAA,gBACAA,EAAA,oBACAA,EAAA,oBACAA,EAAA,eACAA,EAAA,iBACAA,EAAA,2BAAsB,KAIdA,EAAA,sBAAiB,GACjBA,EAAA,6BAA8C,MAC9CA,EAAA,qBAAgB,IAChBA,EAAA,sBAIH,CAAA,GAIH,KAAK,SAAWC,KAAwB,UAGxC,KAAK,OAAS,IAAIC,EAAc,KAAK,SAAU,KAAK,EAGpD,KAAK,iBAAA,CACP,CAEA,MAAc,mBAAmC,CAC/C,GAAI,MAAK,cAIT,OAAI,KAAK,sBACA,KAAK,uBAGd,KAAK,sBAAwB,KAAK,kBAAA,EAC3B,KAAK,sBACd,CAEA,MAAc,mBAAmC,CAE/C,MAAMC,EADY,IAAI,gBAAgB,OAAO,SAAS,MAAM,EAC5B,IAAI,KAAK,GAAK,iBAE9C,GAAI,CACF,QAAQ,MAAM,8BAA8B,EAE5C,IAAIC,EAAU,MAAMC,EAAWF,CAAa,EAEvCC,IACH,QAAQ,MAAM,8BAA8B,EAC5CA,EAAU,MAAME,EAAcH,CAAa,EAC3C,QAAQ,MAAM,wBAAyBC,CAAO,GAGhD,KAAK,QAAUA,EACf,MAAM,KAAK,UAAA,EACX,MAAM,KAAK,yBAAA,EAEX,KAAK,cAAgB,GACrB,QAAQ,MAAM,sCAAsC,EAGpD,MAAM,KAAK,sBAAA,CACb,OAASG,EAAO,CACd,cAAQ,MAAM,qCAAsCA,CAAK,EACzD,KAAK,sBAAwB,KACvBA,CACR,CACF,CAEA,MAAc,uBAAuC,CACnD,QAAQ,MAAM,mBAAmB,KAAK,eAAe,MAAM,kBAAkB,EAE7E,MAAMC,EAAW,CAAC,GAAG,KAAK,cAAc,EACxC,KAAK,eAAiB,CAAA,EAEtB,UAAWC,KAAWD,EACpB,GAAI,CACF,MAAME,EAAW,MAAM,KAAK,kBAAkBD,EAAQ,WAAW,EACjEA,EAAQ,QAAQC,CAAQ,CAC1B,OAASH,EAAO,CACdE,EAAQ,OAAOF,aAAiB,MAAQA,EAAQ,IAAI,MAAM,eAAe,CAAC,CAC5E,CAEJ,CAEA,MAAM,WAAY,CAChB,MAAMI,EAAcC,EAAW,KAAK,QAAQ,UAAU,QAAQ,KAAM,EAAE,CAAC,EAEvE,KAAK,YAAcC,EAAiB,KAAK,QAAQ,WAAYF,CAAW,EACxE,KAAK,YAAcG,EAAiB,KAAK,QAAQ,aAAcH,CAAW,CAC5E,CAEA,MAAM,0BAA2B,CAC/B,KAAK,OAAS,IAAI,aAAa,oCAAoC,KAAK,QAAQ,SAAS,EAAE,EAE3F,KAAK,OAAO,KAAK,MAAA,EACjB,KAAK,OAAO,KAAK,UAAa,GAAM,CAClC,KAAK,oBAAoB,EAAE,IAAI,CACjC,CACF,CAEA,MAAc,kBAAmB,CAC/B,GAAI,CACF,MAAM,KAAK,OAAO,QAAA,EAGlB,KAAK,OAAO,GAAG,cAAe,MAAOI,EAASC,IAAY,CACxD,GAAIA,EACF,GAAI,CACF,MAAMC,EAAS,MAAM,KAAK,iBAAiBF,EAAQ,IAAI,EACvDC,EAAQC,CAAM,CAChB,OAASV,EAAO,CACdS,EAAQ,CACN,QAAS,GACT,MAAOT,aAAiB,MAAQA,EAAM,QAAU,eAAA,CACjD,CACH,CAEJ,CAAC,EAED,QAAQ,MAAM,sCAAsC,CACtD,OAASA,EAAO,CACd,cAAQ,MAAM,oCAAqCA,CAAK,EAClD,IAAI,MACR,qCAAqCA,aAAiB,MAAQA,EAAM,QAAU,eAAe,EAAA,CAEjG,CACF,CAEQ,kBAA2B,CACjC,MAAO,EAAE,KAAK,cAChB,CAEA,MAAM,iBAAiBW,EAAwC,CAE7D,OAAK,KAAK,cAwBH,KAAK,kBAAkBA,CAAW,EAtBhC,IAAI,QAAQ,CAACC,EAASC,IAAW,CAEtC,KAAK,eAAe,KAAK,CACvB,YAAAF,EACA,QAAAC,EACA,OAAAC,CAAA,CACD,EAGD,KAAK,kBAAA,EAAoB,MAAOb,GAAU,CAExC,MAAMC,EAAW,CAAC,GAAG,KAAK,cAAc,EACxC,KAAK,eAAiB,CAAA,EAEtB,UAAWC,KAAWD,EACpBC,EAAQ,OAAOF,CAAK,CAExB,CAAC,CACH,CAAC,CAKL,CAEA,MAAc,kBAAkBW,EAAwC,CACtE,GAAI,CACF,MAAMG,EAAY,KAAK,iBAAA,EAGjBC,EAAc,MAAM,KAAK,YAAY,OAAOJ,EAAa,CAC7D,IAAKG,CAAA,CACN,EAGKE,EAAkB,IAAI,QAAa,CAACJ,EAASC,IAAW,CAC5D,KAAK,gBAAgB,IAAIC,EAAW,CAAE,QAAAF,EAAS,OAAAC,EAAQ,EAGvD,WAAW,IAAM,CACX,KAAK,gBAAgB,IAAIC,CAAS,IACpC,KAAK,gBAAgB,OAAOA,CAAS,EACrCD,EAAO,IAAI,MAAM,iBAAiB,CAAC,EAEvC,EAAG,GAAK,CACV,CAAC,EAGD,GAAI,KAAK,OACP,KAAK,OAAO,KAAK,YAAY,CAC3B,KAAM,OACN,MAAOC,EACP,KAAMC,CAAA,CACP,MAED,OAAM,IAAI,MAAM,wBAAwB,EAM1C,MAAO,CACL,QAAS,GACT,KAJmB,MAAMC,CAInB,CAEV,OAAShB,EAAO,CACd,MAAO,CACL,QAAS,GACT,MAAOA,aAAiB,MAAQA,EAAM,QAAU,eAAA,CAEpD,CACF,CAEA,MAAM,oBAAoBQ,EAAc,CACtC,GAAIA,EAAQ,OAAS,cAAgBA,EAAQ,OAAS,gBACpD,GAAI,CAEF,MAAMS,EAAO,IAAI,WAAWT,EAAQ,IAAI,EAClCU,EAAgB,MAAM,KAAK,YAAY,gBAAgBD,CAAI,EAEjE,GAAIC,EAAc,OAAQ,CACxB,KAAM,CAAE,IAAAC,CAAA,EAAQD,EAAc,MAAM,QACpC,GAAI,OAAOC,GAAQ,SAAU,CAC3B,MAAMC,EAAiB,KAAK,gBAAgB,IAAID,CAAG,EAC/CC,IACF,KAAK,gBAAgB,OAAOD,CAAG,EAC/BC,EAAe,QAAQF,EAAc,MAAM,OAAO,EAEtD,CACF,MACE,QAAQ,MAAM,sCAAuCA,EAAc,KAAK,CAE5E,OAASlB,EAAO,CACd,QAAQ,MAAM,wCAAyCA,CAAK,CAC9D,SACSQ,EAAQ,OAAS,aAAc,CAExC,MAAMY,EAAiB,KAAK,gBAAgB,IAAIZ,EAAQ,KAAK,EACzDY,IACF,KAAK,gBAAgB,OAAOZ,EAAQ,KAAK,EACzCY,EAAe,OAAO,IAAI,MAAMZ,EAAQ,KAAK,CAAC,EAElD,CACF,CAGA,OAAO,MAAO,CACZ,MAAMa,EAAS,IAAI7B,EAGlB,WAAmB,UAAY6B,CAClC,CACF,CAGI,WAAW,iBACb,WAAW,iBAAiB,mBAAoB7B,EAAU,IAAI,EAG9DA,EAAU,KAAA"}