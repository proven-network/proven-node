{"version":3,"file":"bridge.js","sources":["bridge.ts"],"sourcesContent":["/// <reference lib=\"DOM\" />\nimport {\n  MessageBroker,\n  getWindowIdFromUrl,\n  ExecuteMessage,\n  ParentToBridgeMessage,\n  BridgeToParentMessage,\n  ResponseMessage,\n  OpenModalMessage,\n  CloseModalMessage,\n} from '@proven-network/common';\nimport { bytesToHex } from '@noble/curves/abstract/utils';\nimport type {\n  WhoAmI,\n  WhoAmIResult,\n  ExecuteHash,\n  Execute,\n  ExecuteLog,\n  ExecutionResult,\n  ExecuteError,\n  ExecuteResult,\n  ExecuteHashResult,\n  RpcResponse,\n} from '@proven-network/common';\n\n// WhoAmIMessage is still local to the bridge\nexport type WhoAmIMessage = {\n  type: 'whoAmI';\n  nonce: number;\n};\n\n// Local type that combines imported ParentToBridgeMessage with local WhoAmIMessage\ntype LocalParentToBridgeMessage = ParentToBridgeMessage | WhoAmIMessage;\n\nfunction isParentMessage(data: unknown): data is LocalParentToBridgeMessage {\n  if (\n    typeof data !== 'object' ||\n    data === null ||\n    !('type' in data) ||\n    !('nonce' in data) ||\n    typeof (data as any).nonce !== 'number'\n  ) {\n    return false;\n  }\n\n  const message = data as any;\n\n  if (message.type === 'whoAmI') {\n    return true;\n  }\n\n  if (message.type === 'execute') {\n    return (\n      'data' in message &&\n      typeof message.data === 'object' &&\n      message.data !== null &&\n      typeof message.data.manifestId === 'string' &&\n      typeof message.data.handler === 'string'\n    );\n  }\n\n  return false;\n}\n\nclass BridgeClient {\n  broker: MessageBroker;\n  windowId: string;\n  manifestCache: Map<string, any>; // Cache for manifests\n  hashMapping: Map<string, string>; // Map from manifest hash to CodePackage hash\n\n  constructor() {\n    // Extract window ID from URL fragment\n    this.windowId = getWindowIdFromUrl() || 'unknown';\n\n    // Initialize broker synchronously - will throw if it fails\n    this.broker = new MessageBroker(this.windowId, 'sdk');\n\n    // Initialize caches\n    this.manifestCache = new Map();\n    this.hashMapping = new Map();\n\n    // Load hash mapping from sessionStorage\n    this.loadHashMappingFromStorage();\n\n    this.initializeBroker();\n    this.setupParentListener();\n  }\n\n  async initializeBroker() {\n    try {\n      await this.broker.connect();\n\n      // Set up message handlers for modal events\n      this.broker.on('open_registration_modal', (message) => {\n        this.forwardToParent({\n          type: 'open_registration_modal',\n        });\n      });\n\n      this.broker.on('close_registration_modal', (message) => {\n        this.forwardToParent({\n          type: 'close_registration_modal',\n        });\n      });\n\n      console.debug('Bridge: Broker initialized successfully');\n    } catch (error) {\n      console.error('Bridge: Failed to initialize broker:', error);\n      throw new Error(\n        `Bridge: Failed to initialize broker: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  setupParentListener() {\n    // Listen for messages from parent SDK\n    window.addEventListener('message', (event: MessageEvent) => {\n      // Only handle messages from parent window\n      if (event.source === parent && isParentMessage(event.data)) {\n        this.handleParentMessage(event.data);\n      }\n    });\n  }\n\n  async handleParentMessage(message: ParentToBridgeMessage) {\n    try {\n      console.debug('Bridge: Received message from parent:', message);\n\n      if (message.type === 'whoAmI') {\n        await this.handleWhoAmI(message);\n      } else if (message.type === 'execute') {\n        await this.handleExecute(message);\n      } else {\n        // This should never happen due to our type guard, but TypeScript requires it\n        const exhaustiveCheck: never = message;\n        throw new Error(`Unknown message type: ${(exhaustiveCheck as any).type}`);\n      }\n    } catch (error) {\n      console.error('Bridge: Error handling parent message:', error);\n      this.forwardToParent({\n        type: 'response',\n        nonce: message.nonce,\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      });\n    }\n  }\n\n  async handleWhoAmI(message: WhoAmIMessage) {\n    try {\n      const rpcCall: WhoAmI = { type: 'WhoAmI', data: null };\n\n      const response = await this.broker.request<{\n        success: boolean;\n        data?: RpcResponse<WhoAmIResult>;\n        error?: string;\n      }>('rpc_request', rpcCall, 'rpc');\n\n      if (response.success && response.data?.type === 'WhoAmI') {\n        this.forwardToParent({\n          type: 'response',\n          nonce: message.nonce,\n          success: true,\n          data: response.data.data, // Extract the WhoAmIResult from the tagged response\n        });\n      } else {\n        this.forwardToParent({\n          type: 'response',\n          nonce: message.nonce,\n          success: false,\n          error: response.error || 'WhoAmI response is missing or malformed',\n        });\n      }\n    } catch (error) {\n      this.forwardToParent({\n        type: 'response',\n        nonce: message.nonce,\n        success: false,\n        error: error instanceof Error ? error.message : 'Failed to execute WhoAmI',\n      });\n    }\n  }\n\n  async handleExecute(message: ExecuteMessage) {\n    try {\n      const { manifestId, manifest, handler, args } = message.data;\n\n      if (!manifestId || !handler) {\n        throw new Error('ManifestId and handler are required for execute');\n      }\n\n      // Cache manifest if provided\n      if (manifest) {\n        console.debug('Bridge: Caching manifest', manifestId);\n        this.manifestCache.set(manifestId, manifest);\n      }\n\n      // Get manifest from cache\n      const cachedManifest = this.manifestCache.get(manifestId);\n      if (!cachedManifest) {\n        throw new Error(`Manifest ${manifestId} not found in cache`);\n      }\n\n      // Calculate manifest hash for hash mapping lookup\n      const manifestHash = await this.hashManifest(cachedManifest);\n      const storedCodePackageHash = this.getCodePackageHash(manifestHash);\n\n      // Try ExecuteHash first if we have a stored CodePackage hash\n      if (storedCodePackageHash) {\n        console.debug('Bridge: Trying ExecuteHash with stored CodePackage hash');\n\n        const hashRpcCall: ExecuteHash = {\n          type: 'ExecuteHash',\n          data: {\n            args: args || [],\n            handler_specifier: handler,\n            module_hash: storedCodePackageHash,\n          },\n        };\n\n        const hashResponse = await this.broker.request<{\n          success: boolean;\n          data?: RpcResponse<ExecuteHashResult>;\n          error?: string;\n        }>('rpc_request', hashRpcCall, 'rpc');\n\n        if (hashResponse.success && hashResponse.data?.type === 'ExecuteHash') {\n          const executeHashResult = hashResponse.data.data;\n\n          if (executeHashResult.result === 'success') {\n            const executionResult = executeHashResult.data as ExecutionResult;\n            this.handleExecutionResult(executionResult, message.nonce);\n            return;\n          } else if (executeHashResult.result === 'failure') {\n            this.forwardToParent({\n              type: 'response',\n              nonce: message.nonce,\n              success: false,\n              error: executeHashResult.data as string,\n            });\n            return;\n          }\n          // If result is \"error\" (HashUnknown), fall through to Execute\n        }\n\n        console.debug('Bridge: ExecuteHash failed or unknown, falling back to Execute');\n      } else {\n        console.debug('Bridge: No stored CodePackage hash, using Execute directly');\n      }\n\n      // Fall back to full Execute\n      await this.executeWithFullManifest(\n        message,\n        cachedManifest,\n        handler,\n        args || [],\n        manifestHash\n      );\n    } catch (error) {\n      this.forwardToParent({\n        type: 'response',\n        nonce: message.nonce,\n        success: false,\n        error: error instanceof Error ? error.message : 'Failed to execute handler',\n      });\n    }\n  }\n\n  async executeWithFullManifest(\n    originalMessage: LocalParentToBridgeMessage,\n    manifest: any,\n    handler: string,\n    args: any[],\n    manifestHash: string\n  ) {\n    try {\n      const fullRpcCall = {\n        type: 'Execute',\n        data: {\n          manifest: manifest,\n          handler_specifier: handler,\n          args: args,\n        },\n      } as any;\n\n      const response = await this.broker.request<{\n        success: boolean;\n        data?: RpcResponse<ExecuteResult>;\n        error?: string;\n      }>('rpc_request', fullRpcCall, 'rpc');\n\n      if (!response.success) {\n        throw new Error(response.error || 'Failed to execute full manifest');\n      }\n\n      if (!response.data || response.data.type !== 'Execute') {\n        throw new Error('Invalid response format from Execute');\n      }\n\n      const executeResult = response.data.data;\n\n      if (executeResult.result === 'success') {\n        // Handle new response format with CodePackage hash\n        const successData = executeResult.data as any;\n\n        if (successData.execution_result && successData.code_package_hash) {\n          // Store the hash mapping for future ExecuteHash calls\n          this.storeHashMapping(manifestHash, successData.code_package_hash);\n          console.debug('Bridge: Stored hash mapping', {\n            manifestHash,\n            codePackageHash: successData.code_package_hash,\n          });\n\n          // Forward the execution result\n          this.handleExecutionResult(successData.execution_result, originalMessage.nonce);\n        } else {\n          // Fallback for legacy format\n          this.handleExecutionResult(successData, originalMessage.nonce);\n        }\n      } else if (executeResult.result === 'failure' || executeResult.result === 'error') {\n        this.forwardToParent({\n          type: 'response',\n          nonce: originalMessage.nonce,\n          success: false,\n          error: executeResult.data as string,\n        });\n      } else {\n        this.forwardToParent({\n          type: 'response',\n          nonce: originalMessage.nonce,\n          success: false,\n          error: 'Unexpected response format from Execute',\n        });\n      }\n    } catch (error) {\n      this.forwardToParent({\n        type: 'response',\n        nonce: originalMessage.nonce,\n        success: false,\n        error: error instanceof Error ? error.message : 'Failed to retry with full script',\n      });\n    }\n  }\n\n  handleExecutionResult(result: ExecutionResult, nonce: number) {\n    // Send the full ExecutionResult back to the SDK to handle\n    this.forwardToParent({\n      type: 'response',\n      nonce: nonce,\n      success: true,\n      data: result,\n    });\n  }\n\n  async hashManifest(manifest: any): Promise<string> {\n    const manifestString = JSON.stringify(manifest);\n    const rawHash = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(manifestString));\n    return bytesToHex(new Uint8Array(rawHash));\n  }\n\n  /**\n   * Load hash mapping from sessionStorage\n   */\n  loadHashMappingFromStorage(): void {\n    try {\n      const stored = sessionStorage.getItem('proven_hash_mapping');\n      if (stored) {\n        const parsed = JSON.parse(stored);\n        this.hashMapping = new Map(Object.entries(parsed));\n        console.debug('Bridge: Loaded hash mapping from storage', this.hashMapping.size, 'entries');\n      }\n    } catch (error) {\n      console.warn('Bridge: Failed to load hash mapping from storage:', error);\n    }\n  }\n\n  /**\n   * Save hash mapping to sessionStorage\n   */\n  saveHashMappingToStorage(): void {\n    try {\n      const obj = Object.fromEntries(this.hashMapping);\n      sessionStorage.setItem('proven_hash_mapping', JSON.stringify(obj));\n      console.debug('Bridge: Saved hash mapping to storage', this.hashMapping.size, 'entries');\n    } catch (error) {\n      console.warn('Bridge: Failed to save hash mapping to storage:', error);\n    }\n  }\n\n  /**\n   * Store manifest hash to CodePackage hash mapping\n   */\n  storeHashMapping(manifestHash: string, codePackageHash: string): void {\n    this.hashMapping.set(manifestHash, codePackageHash);\n    this.saveHashMappingToStorage();\n  }\n\n  /**\n   * Get CodePackage hash for a manifest hash\n   */\n  getCodePackageHash(manifestHash: string): string | undefined {\n    return this.hashMapping.get(manifestHash);\n  }\n\n  processExecuteLogs(logs: ExecuteLog[]) {\n    logs.forEach((log) => {\n      if (log.level === 'log') {\n        console.log(...log.args);\n      } else if (log.level === 'error') {\n        console.error(...log.args);\n      } else if (log.level === 'warn') {\n        console.warn(...log.args);\n      } else if (log.level === 'debug') {\n        console.debug(...log.args);\n      } else if (log.level === 'info') {\n        console.info(...log.args);\n      }\n    });\n  }\n\n  forwardToParent(message: BridgeToParentMessage) {\n    console.debug('Bridge: Forwarding to parent:', message);\n    parent.postMessage(message, '*');\n  }\n\n  // Initialize the client when the page loads\n  static init() {\n    const client = new BridgeClient();\n\n    // Make client available globally for debugging\n    (globalThis as any).bridgeClient = client;\n  }\n}\n\n// Initialize when the page loads\nif (globalThis.addEventListener) {\n  globalThis.addEventListener('DOMContentLoaded', BridgeClient.init);\n} else {\n  // Fallback for cases where DOMContentLoaded has already fired\n  BridgeClient.init();\n}\n"],"names":["isParentMessage","data","message","BridgeClient","__publicField","getWindowIdFromUrl","MessageBroker","error","event","exhaustiveCheck","rpcCall","response","_a","manifestId","manifest","handler","args","cachedManifest","manifestHash","storedCodePackageHash","hashRpcCall","hashResponse","executeHashResult","executionResult","originalMessage","fullRpcCall","executeResult","successData","result","nonce","manifestString","rawHash","bytesToHex","stored","parsed","obj","codePackageHash","logs","log","client"],"mappings":"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"}