{"version":3,"file":"sessions.js","sources":["../../../packages/node_modules/@noble/curves/esm/utils.js","../../../packages/common/src/pems/mock.ts","../../../packages/common/src/pems/us-east-2.ts","../../../packages/common/src/helpers/sessions.ts"],"sourcesContent":["/**\n * Hex, bytes and number utilities.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { abytes as abytes_, bytesToHex as bytesToHex_, concatBytes as concatBytes_, hexToBytes as hexToBytes_, isBytes as isBytes_, } from '@noble/hashes/utils.js';\nexport { abytes, anumber, bytesToHex, bytesToUtf8, concatBytes, hexToBytes, isBytes, randomBytes, utf8ToBytes, } from '@noble/hashes/utils.js';\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nexport function abool(title, value) {\n    if (typeof value !== 'boolean')\n        throw new Error(title + ' boolean expected, got ' + value);\n}\n// Used in weierstrass, der\nexport function numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? '0' + hex : hex;\n}\nexport function hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian\n}\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex_(bytes));\n}\nexport function bytesToNumberLE(bytes) {\n    abytes_(bytes);\n    return hexToNumber(bytesToHex_(Uint8Array.from(bytes).reverse()));\n}\nexport function numberToBytesBE(n, len) {\n    return hexToBytes_(n.toString(16).padStart(len * 2, '0'));\n}\nexport function numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n) {\n    return hexToBytes_(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nexport function ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes_(hex);\n        }\n        catch (e) {\n            throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);\n        }\n    }\n    else if (isBytes_(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(title + ' must be hex string or Uint8Array');\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\n// export const utf8ToBytes: typeof utf8ToBytes_ = utf8ToBytes_;\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\n// export const bytesToUtf8: typeof bytesToUtf8_ = bytesToUtf8_;\n// Is positive bigint\nconst isPosBig = (n) => typeof n === 'bigint' && _0n <= n;\nexport function inRange(n, min, max) {\n    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nexport function aInRange(title, n, min, max) {\n    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n    // consider P=256n, min=0n, max=P\n    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n    // - our way is the cleanest:               `inRange('x', x, 0n, P)\n    if (!inRange(n, min, max))\n        throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n * TODO: merge with nLength in modular\n */\nexport function bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nexport function bitSet(n, pos, value) {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n) => (_1n << BigInt(n)) - _1n;\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    const u8n = (len) => new Uint8Array(len); // creates Uint8Array\n    const u8of = (byte) => Uint8Array.of(byte); // another shortcut\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n(0)) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8of(0x00), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8of(0x01), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes_(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || isBytes_(val),\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nexport function validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error('invalid validator function');\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error('param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\nexport function isHash(val) {\n    return typeof val === 'function' && Number.isSafeInteger(val.outputLen);\n}\nexport function _validateObject(object, fields, optFields = {}) {\n    if (!object || typeof object !== 'object')\n        throw new Error('expected valid options object');\n    function checkField(fieldName, expectedType, isOpt) {\n        const val = object[fieldName];\n        if (isOpt && val === undefined)\n            return;\n        const current = typeof val;\n        if (current !== expectedType || val === null)\n            throw new Error(`param \"${fieldName}\" is invalid: expected ${expectedType}, got ${current}`);\n    }\n    Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));\n    Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));\n}\n/**\n * throws not implemented error\n */\nexport const notImplemented = () => {\n    throw new Error('not implemented');\n};\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nexport function memoized(fn) {\n    const map = new WeakMap();\n    return (arg, ...args) => {\n        const val = map.get(arg);\n        if (val !== undefined)\n            return val;\n        const computed = fn(arg, ...args);\n        map.set(arg, computed);\n        return computed;\n    };\n}\n//# sourceMappingURL=utils.js.map","export const mockCertificate = `\\\n-----BEGIN CERTIFICATE-----\nMIIBjjCCARWgAwIBAgIBATAKBggqhkjOPQQDAzAAMB4XDTI0MTAyNzAxNDczMVoX\nDTI1MTAyNzAxNDczMVowADB2MBAGByqGSM49AgEGBSuBBAAiA2IABAAuSxbKLkQq\nvFHa0q+ct9kouwn5B6kCeGTn5VmTNnmYG9pds3rkr/WidPT3LKK5gnrOt9FX2V6v\nf16GbOtS/i9hHT3i41jYz0nD4+OmaDGTi0FHYwJhTsEheb6x5UG6l6NjMGEwHQYD\nVR0OBBYEFFQKaJf/+HeQ3Tk0xby4me/HHSw1MB8GA1UdIwQYMBaAFHDu1pj5kfzt\ndwEPhZiNP21un0KyMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgEGMAoG\nCCqGSM49BAMDA2cAMGQCMBC+g8z2waAiMRz1BKcQSn4RL2wFdg9XyLu452p/h2R3\n82oNsHxhf/K4sQQetdp6DwIwUW8E3tfHO2Plj+sOr/4Qsa2E/ebxhckyMsz7Xc2X\nu58+L9aAnTHZV5N+bciiWdZk\n-----END CERTIFICATE-----`;\n","export const usEast2Certificate = `\\\n-----BEGIN CERTIFICATE-----\nMIICETCCAZagAwIBAgIRAPkxdWgbkK/hHUbMtOTn+FYwCgYIKoZIzj0EAwMwSTEL\nMAkGA1UEBhMCVVMxDzANBgNVBAoMBkFtYXpvbjEMMAoGA1UECwwDQVdTMRswGQYD\nVQQDDBJhd3Mubml0cm8tZW5jbGF2ZXMwHhcNMTkxMDI4MTMyODA1WhcNNDkxMDI4\nMTQyODA1WjBJMQswCQYDVQQGEwJVUzEPMA0GA1UECgwGQW1hem9uMQwwCgYDVQQL\nDANBV1MxGzAZBgNVBAMMEmF3cy5uaXRyby1lbmNsYXZlczB2MBAGByqGSM49AgEG\nBSuBBAAiA2IABPwCVOumCMHzaHDimtqQvkY4MpJzbolL//Zy2YlES1BR5TSksfbb\n48C8WBoyt7F2Bw7eEtaaP+ohG2bnUs990d0JX28TcPQXCEPZ3BABIeTPYwEoCWZE\nh8l5YoQwTcU/9KNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUkCW1DdkF\nR+eWw5b6cp3PmanfS5YwDgYDVR0PAQH/BAQDAgGGMAoGCCqGSM49BAMDA2kAMGYC\nMQCjfy+Rocm9Xue4YnwWmNJVA44fA0P5W2OpYow9OYCVRaEevL8uO1XYru5xtMPW\nrfMCMQCi85sWBbJwKKXdS6BptQFuZbT73o/gBh1qUxl/nNr12UO8Yfwr6wPLb+6N\nIwLz3/Y=\n-----END CERTIFICATE-----`;\n","import * as ed25519 from '@noble/ed25519';\nimport { bytesToHex, hexToBytes, equalBytes } from '@noble/curves/abstract/utils';\nimport { decode as cborDecode } from 'cbor-x';\nimport { X509Certificate, X509ChainBuilder } from '@peculiar/x509';\nimport { Sign1 } from '@auth0/cose';\nimport { mockCertificate } from '../pems/mock';\nimport { usEast2Certificate } from '../pems/us-east-2';\n\ntype PcrIndex = 0 | 1 | 2 | 3 | 4 | 8;\nexport type Pcrs = Record<PcrIndex, string>;\n\nexport type ExpectedPcrs = Partial<Pcrs>;\n\nexport type Session = {\n  sessionId: string;\n  pcrs: Pcrs;\n  signingKey: Uint8Array;\n  verifyingKey: Uint8Array;\n};\n\nexport type SerializableSession = {\n  sessionId: string;\n  pcrs: Pcrs;\n  signingKey: string;\n  verifyingKey: string;\n};\n\nlet session: Session | null = null;\n\nexport const createSession = async (applicationId: string) => {\n  const signingKey = ed25519.utils.randomPrivateKey();\n  const publicKeyInput = await ed25519.getPublicKeyAsync(signingKey);\n\n  const nonceInput = new Uint8Array(32);\n  crypto.getRandomValues(nonceInput);\n\n  const body = new FormData();\n  body.append('public_key', new Blob([publicKeyInput], { type: 'application/octet-stream' }));\n  body.append('nonce', new Blob([nonceInput], { type: 'application/octet-stream' }));\n  body.append('application_id', applicationId);\n\n  const response = await fetch(`/session`, {\n    method: 'POST',\n    body,\n  });\n\n  if (!response.ok) {\n    throw new Error('Failed to fetch attestation document.');\n  }\n\n  const data = new Uint8Array(await response.arrayBuffer());\n\n  const coseElements = (await cborDecode(data)) as Uint8Array[];\n  const {\n    cabundle,\n    certificate,\n    nonce,\n    pcrs: rawPcrs,\n    public_key: verifyingKeyBytes,\n    user_data: sessionIdBytes,\n  } = (await cborDecode(coseElements[2]!)) as {\n    cabundle: Uint8Array[];\n    certificate: Uint8Array;\n    nonce: Uint8Array;\n    pcrs: { [index: number]: Uint8Array };\n    public_key: Uint8Array;\n    user_data: Uint8Array;\n  };\n\n  const leaf = new X509Certificate(certificate);\n\n  if (!equalBytes(nonceInput, nonce)) {\n    throw new Error('Attestation nonce does not match expected value.');\n  }\n\n  if (leaf.notAfter < new Date()) {\n    throw new Error('Attestation document certificate has expired.');\n  }\n\n  const publicKey = await crypto.subtle.importKey(\n    'spki',\n    new Uint8Array(leaf.publicKey.rawData),\n    { name: 'ECDSA', namedCurve: 'P-384' },\n    true,\n    ['verify']\n  );\n  await Sign1.decode(data).verify(publicKey);\n\n  const hostname = globalThis.location.hostname;\n  const knownCa = new X509Certificate(\n    hostname === 'localhost' || hostname.endsWith('.local') ? mockCertificate : usEast2Certificate\n  );\n\n  const chain = await new X509ChainBuilder({\n    certificates: cabundle.map((cert) => new X509Certificate(cert)),\n  }).build(leaf);\n\n  if (!chain[chain.length - 1]?.equal(knownCa)) {\n    throw new Error('x509 certificate chain does not have expected certificate authority.');\n  }\n\n  const pcrs: Pcrs = {\n    0: bytesToHex(rawPcrs[0]!),\n    1: bytesToHex(rawPcrs[1]!),\n    2: bytesToHex(rawPcrs[2]!),\n    3: bytesToHex(rawPcrs[3]!),\n    4: bytesToHex(rawPcrs[4]!),\n    8: bytesToHex(rawPcrs[8]!),\n  };\n\n  // TODO: get from options or generate from cargo version for testing\n  const expectedPcrs: ExpectedPcrs = {\n    0: '30f2c9b7736afa4af8e80acf549cb5c9511c2198f0174bf461a5c547ad3bfbd04dd6370968444bfdf64a34e5dda2a684',\n    1: '0ab829f12a94d68545fe4a331fb80ccd2cd0e16b5c84f854a4b7f3c3c32a386dd6aed3f1117e3831bc21ac124a5e9ec8',\n    2: 'ba73cd68537fb4a9e704df621505420055ee049177c50a59643cad88736fcee578139cf76549cdb9d37169a13276578b',\n  };\n\n  // verify expected PCRs or throw error\n  expectedPcrs &&\n    Object.entries(expectedPcrs).forEach(([index, expectedValue]) => {\n      if (pcrs[index as unknown as keyof Pcrs] !== expectedValue) {\n        throw new Error(\n          `PCR${index} does not match expected value. Expected: ${expectedValue} Actual: ${pcrs[index as unknown as keyof Pcrs]}`\n        );\n      }\n    });\n\n  // Restore UUID with dashes from sessionIdBytes\n  const sessionId = bytesToHex(sessionIdBytes).replace(\n    /^([0-9a-fA-F]{8})([0-9a-fA-F]{4})([0-9a-fA-F]{4})([0-9a-fA-F]{4})([0-9a-fA-F]{12})$/,\n    '$1-$2-$3-$4-$5'\n  );\n\n  session = {\n    sessionId,\n    pcrs,\n    signingKey,\n    verifyingKey: verifyingKeyBytes,\n  };\n\n  const serializableSession: SerializableSession = {\n    sessionId: session.sessionId,\n    pcrs: session.pcrs,\n    signingKey: bytesToHex(session.signingKey),\n    verifyingKey: bytesToHex(session.verifyingKey),\n  };\n\n  localStorage.setItem('currentSession:' + applicationId, JSON.stringify(serializableSession));\n\n  return session;\n};\n\nexport const getSession = async (applicationId: string) => {\n  if (session) {\n    return session;\n  }\n\n  const sessionData = localStorage.getItem('currentSession:' + applicationId);\n  if (!sessionData) {\n    return null;\n  }\n\n  const { sessionId, pcrs, signingKey, verifyingKey } = JSON.parse(\n    sessionData\n  ) as SerializableSession;\n\n  session = {\n    sessionId,\n    pcrs,\n    signingKey: hexToBytes(signingKey),\n    verifyingKey: hexToBytes(verifyingKey),\n  };\n\n  return session;\n};\n"],"names":["equalBytes","a","b","diff","i","mockCertificate","usEast2Certificate","session","createSession","applicationId","signingKey","ed25519.utils","publicKeyInput","ed25519.getPublicKeyAsync","nonceInput","body","response","data","coseElements","cborDecode","cabundle","certificate","nonce","rawPcrs","verifyingKeyBytes","sessionIdBytes","leaf","X509Certificate","publicKey","Sign1","hostname","knownCa","chain","X509ChainBuilder","cert","_a","pcrs","bytesToHex","expectedPcrs","index","expectedValue","serializableSession","getSession","sessionData","sessionId","verifyingKey","hexToBytes"],"mappings":"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","x_google_ignoreList":[0]}