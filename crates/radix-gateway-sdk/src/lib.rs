#[allow(unused_imports)]
pub use progenitor_client::{ByteStream, Error, ResponseValue};
#[allow(unused_imports)]
use progenitor_client::{encode_path, RequestBuilderExt};
#[allow(unused_imports)]
use reqwest::header::{HeaderMap, HeaderValue};
/// Types used as operation parameters and responses.
#[allow(clippy::all)]
pub mod types {
    /// Error types.
    pub mod error {
        /// Error from a TryFrom or FromStr implementation.
        pub struct ConversionError(::std::borrow::Cow<'static, str>);
        impl ::std::error::Error for ConversionError {}
        impl ::std::fmt::Display for ConversionError {
            fn fmt(
                &self,
                f: &mut ::std::fmt::Formatter<'_>,
            ) -> Result<(), ::std::fmt::Error> {
                ::std::fmt::Display::fmt(&self.0, f)
            }
        }
        impl ::std::fmt::Debug for ConversionError {
            fn fmt(
                &self,
                f: &mut ::std::fmt::Formatter<'_>,
            ) -> Result<(), ::std::fmt::Error> {
                ::std::fmt::Debug::fmt(&self.0, f)
            }
        }
        impl From<&'static str> for ConversionError {
            fn from(value: &'static str) -> Self {
                Self(value.into())
            }
        }
        impl From<String> for ConversionError {
            fn from(value: String) -> Self {
                Self(value.into())
            }
        }
    }
    ///AccountAuthorizedDepositorBadgeType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ResourceBadge",
    ///    "NonFungibleBadge"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum AccountAuthorizedDepositorBadgeType {
        ResourceBadge,
        NonFungibleBadge,
    }
    impl From<&AccountAuthorizedDepositorBadgeType>
    for AccountAuthorizedDepositorBadgeType {
        fn from(value: &AccountAuthorizedDepositorBadgeType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for AccountAuthorizedDepositorBadgeType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::ResourceBadge => write!(f, "ResourceBadge"),
                Self::NonFungibleBadge => write!(f, "NonFungibleBadge"),
            }
        }
    }
    impl std::str::FromStr for AccountAuthorizedDepositorBadgeType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ResourceBadge" => Ok(Self::ResourceBadge),
                "NonFungibleBadge" => Ok(Self::NonFungibleBadge),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for AccountAuthorizedDepositorBadgeType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for AccountAuthorizedDepositorBadgeType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for AccountAuthorizedDepositorBadgeType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///Account resource preferences collection
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Account resource preferences collection",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ResultSetCursorMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "items"
    ///      ],
    ///      "properties": {
    ///        "items": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/AccountAuthorizedDepositorsResponseItem"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct AccountAuthorizedDepositorsCollection {
        pub items: Vec<AccountAuthorizedDepositorsResponseItem>,
        ///If specified, contains a cursor to query next page of the `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_cursor: Option<String>,
        ///Total number of items in underlying collection, fragment of which is available in `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_count: Option<i64>,
    }
    impl From<&AccountAuthorizedDepositorsCollection>
    for AccountAuthorizedDepositorsCollection {
        fn from(value: &AccountAuthorizedDepositorsCollection) -> Self {
            value.clone()
        }
    }
    impl AccountAuthorizedDepositorsCollection {
        pub fn builder() -> builder::AccountAuthorizedDepositorsCollection {
            Default::default()
        }
    }
    ///AccountAuthorizedDepositorsNonFungibleBadge
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/AccountAuthorizedDepositorsResponseItemBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "last_updated_at_state_version",
    ///        "non_fungible_id",
    ///        "resource_address"
    ///      ],
    ///      "properties": {
    ///        "badge_type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "NonFungibleBadge"
    ///          ]
    ///        },
    ///        "last_updated_at_state_version": {
    ///          "$ref": "#/components/schemas/LastUpdatedAtStateVersion"
    ///        },
    ///        "non_fungible_id": {
    ///          "$ref": "#/components/schemas/NonFungibleId"
    ///        },
    ///        "resource_address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct AccountAuthorizedDepositorsNonFungibleBadge {
        pub badge_type: AccountAuthorizedDepositorsNonFungibleBadgeBadgeType,
        pub last_updated_at_state_version: LastUpdatedAtStateVersion,
        pub non_fungible_id: NonFungibleId,
        pub resource_address: Address,
    }
    impl From<&AccountAuthorizedDepositorsNonFungibleBadge>
    for AccountAuthorizedDepositorsNonFungibleBadge {
        fn from(value: &AccountAuthorizedDepositorsNonFungibleBadge) -> Self {
            value.clone()
        }
    }
    impl AccountAuthorizedDepositorsNonFungibleBadge {
        pub fn builder() -> builder::AccountAuthorizedDepositorsNonFungibleBadge {
            Default::default()
        }
    }
    ///AccountAuthorizedDepositorsNonFungibleBadgeBadgeType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "NonFungibleBadge"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum AccountAuthorizedDepositorsNonFungibleBadgeBadgeType {
        NonFungibleBadge,
    }
    impl From<&AccountAuthorizedDepositorsNonFungibleBadgeBadgeType>
    for AccountAuthorizedDepositorsNonFungibleBadgeBadgeType {
        fn from(value: &AccountAuthorizedDepositorsNonFungibleBadgeBadgeType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for AccountAuthorizedDepositorsNonFungibleBadgeBadgeType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::NonFungibleBadge => write!(f, "NonFungibleBadge"),
            }
        }
    }
    impl std::str::FromStr for AccountAuthorizedDepositorsNonFungibleBadgeBadgeType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "NonFungibleBadge" => Ok(Self::NonFungibleBadge),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str>
    for AccountAuthorizedDepositorsNonFungibleBadgeBadgeType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String>
    for AccountAuthorizedDepositorsNonFungibleBadgeBadgeType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String>
    for AccountAuthorizedDepositorsNonFungibleBadgeBadgeType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///AccountAuthorizedDepositorsResourceBadge
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/AccountAuthorizedDepositorsResponseItemBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "last_updated_at_state_version",
    ///        "resource_address"
    ///      ],
    ///      "properties": {
    ///        "badge_type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "ResourceBadge"
    ///          ]
    ///        },
    ///        "last_updated_at_state_version": {
    ///          "$ref": "#/components/schemas/LastUpdatedAtStateVersion"
    ///        },
    ///        "resource_address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct AccountAuthorizedDepositorsResourceBadge {
        pub badge_type: AccountAuthorizedDepositorsResourceBadgeBadgeType,
        pub last_updated_at_state_version: LastUpdatedAtStateVersion,
        pub resource_address: Address,
    }
    impl From<&AccountAuthorizedDepositorsResourceBadge>
    for AccountAuthorizedDepositorsResourceBadge {
        fn from(value: &AccountAuthorizedDepositorsResourceBadge) -> Self {
            value.clone()
        }
    }
    impl AccountAuthorizedDepositorsResourceBadge {
        pub fn builder() -> builder::AccountAuthorizedDepositorsResourceBadge {
            Default::default()
        }
    }
    ///AccountAuthorizedDepositorsResourceBadgeBadgeType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ResourceBadge"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum AccountAuthorizedDepositorsResourceBadgeBadgeType {
        ResourceBadge,
    }
    impl From<&AccountAuthorizedDepositorsResourceBadgeBadgeType>
    for AccountAuthorizedDepositorsResourceBadgeBadgeType {
        fn from(value: &AccountAuthorizedDepositorsResourceBadgeBadgeType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for AccountAuthorizedDepositorsResourceBadgeBadgeType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::ResourceBadge => write!(f, "ResourceBadge"),
            }
        }
    }
    impl std::str::FromStr for AccountAuthorizedDepositorsResourceBadgeBadgeType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ResourceBadge" => Ok(Self::ResourceBadge),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str>
    for AccountAuthorizedDepositorsResourceBadgeBadgeType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String>
    for AccountAuthorizedDepositorsResourceBadgeBadgeType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String>
    for AccountAuthorizedDepositorsResourceBadgeBadgeType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///AccountAuthorizedDepositorsResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/AccountAuthorizedDepositorsResourceBadge"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/AccountAuthorizedDepositorsNonFungibleBadge"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum AccountAuthorizedDepositorsResponseItem {
        ResourceBadge(AccountAuthorizedDepositorsResourceBadge),
        NonFungibleBadge(AccountAuthorizedDepositorsNonFungibleBadge),
    }
    impl From<&AccountAuthorizedDepositorsResponseItem>
    for AccountAuthorizedDepositorsResponseItem {
        fn from(value: &AccountAuthorizedDepositorsResponseItem) -> Self {
            value.clone()
        }
    }
    impl From<AccountAuthorizedDepositorsResourceBadge>
    for AccountAuthorizedDepositorsResponseItem {
        fn from(value: AccountAuthorizedDepositorsResourceBadge) -> Self {
            Self::ResourceBadge(value)
        }
    }
    impl From<AccountAuthorizedDepositorsNonFungibleBadge>
    for AccountAuthorizedDepositorsResponseItem {
        fn from(value: AccountAuthorizedDepositorsNonFungibleBadge) -> Self {
            Self::NonFungibleBadge(value)
        }
    }
    ///AccountAuthorizedDepositorsResponseItemBase
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "badge_type"
    ///  ],
    ///  "properties": {
    ///    "badge_type": {
    ///      "$ref": "#/components/schemas/AccountAuthorizedDepositorBadgeType"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct AccountAuthorizedDepositorsResponseItemBase {
        pub badge_type: AccountAuthorizedDepositorBadgeType,
    }
    impl From<&AccountAuthorizedDepositorsResponseItemBase>
    for AccountAuthorizedDepositorsResponseItemBase {
        fn from(value: &AccountAuthorizedDepositorsResponseItemBase) -> Self {
            value.clone()
        }
    }
    impl AccountAuthorizedDepositorsResponseItemBase {
        pub fn builder() -> builder::AccountAuthorizedDepositorsResponseItemBase {
            Default::default()
        }
    }
    ///Default deposit rule set to an account.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Default deposit rule set to an account.",
    ///  "type": "string",
    ///  "enum": [
    ///    "Accept",
    ///    "Reject",
    ///    "AllowExisting"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum AccountDefaultDepositRule {
        Accept,
        Reject,
        AllowExisting,
    }
    impl From<&AccountDefaultDepositRule> for AccountDefaultDepositRule {
        fn from(value: &AccountDefaultDepositRule) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for AccountDefaultDepositRule {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Accept => write!(f, "Accept"),
                Self::Reject => write!(f, "Reject"),
                Self::AllowExisting => write!(f, "AllowExisting"),
            }
        }
    }
    impl std::str::FromStr for AccountDefaultDepositRule {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "Accept" => Ok(Self::Accept),
                "Reject" => Ok(Self::Reject),
                "AllowExisting" => Ok(Self::AllowExisting),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for AccountDefaultDepositRule {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for AccountDefaultDepositRule {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for AccountDefaultDepositRule {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///Deciding factors used to calculate response.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Deciding factors used to calculate response.",
    ///  "type": "object",
    ///  "required": [
    ///    "default_deposit_rule"
    ///  ],
    ///  "properties": {
    ///    "default_deposit_rule": {
    ///      "$ref": "#/components/schemas/AccountDefaultDepositRule"
    ///    },
    ///    "is_badge_authorized_depositor": {
    ///      "description": "Whether the input badge belongs to the account's set of authorized depositors. This field will only be present if any badge was passed in the request.",
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "resource_specific_details": {
    ///      "description": "Returns deciding factors for each resource. Contains only information about resources presented in the request, not all resource preference rules for queried account.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/AccountDepositPreValidationDecidingFactorsResourceSpecificDetailsItem"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct AccountDepositPreValidationDecidingFactors {
        pub default_deposit_rule: AccountDefaultDepositRule,
        ///Whether the input badge belongs to the account's set of authorized depositors. This field will only be present if any badge was passed in the request.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_badge_authorized_depositor: Option<bool>,
        ///Returns deciding factors for each resource. Contains only information about resources presented in the request, not all resource preference rules for queried account.
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub resource_specific_details: Vec<
            AccountDepositPreValidationDecidingFactorsResourceSpecificDetailsItem,
        >,
    }
    impl From<&AccountDepositPreValidationDecidingFactors>
    for AccountDepositPreValidationDecidingFactors {
        fn from(value: &AccountDepositPreValidationDecidingFactors) -> Self {
            value.clone()
        }
    }
    impl AccountDepositPreValidationDecidingFactors {
        pub fn builder() -> builder::AccountDepositPreValidationDecidingFactors {
            Default::default()
        }
    }
    ///AccountDepositPreValidationDecidingFactorsResourceSpecificDetailsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "is_xrd",
    ///    "resource_address",
    ///    "vault_exists"
    ///  ],
    ///  "properties": {
    ///    "is_xrd": {
    ///      "type": "boolean"
    ///    },
    ///    "resource_address": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "resource_preference_rule": {
    ///      "$ref": "#/components/schemas/AccountResourcePreferenceRule"
    ///    },
    ///    "vault_exists": {
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct AccountDepositPreValidationDecidingFactorsResourceSpecificDetailsItem {
        pub is_xrd: bool,
        pub resource_address: Address,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub resource_preference_rule: Option<AccountResourcePreferenceRule>,
        pub vault_exists: bool,
    }
    impl From<&AccountDepositPreValidationDecidingFactorsResourceSpecificDetailsItem>
    for AccountDepositPreValidationDecidingFactorsResourceSpecificDetailsItem {
        fn from(
            value: &AccountDepositPreValidationDecidingFactorsResourceSpecificDetailsItem,
        ) -> Self {
            value.clone()
        }
    }
    impl AccountDepositPreValidationDecidingFactorsResourceSpecificDetailsItem {
        pub fn builder() -> builder::AccountDepositPreValidationDecidingFactorsResourceSpecificDetailsItem {
            Default::default()
        }
    }
    ///AccountDepositPreValidationNonFungibleBadge
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/TransactionAccountDepositPreValidationAuthorizedDepositorBadgeBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "non_fungible_id"
    ///      ],
    ///      "properties": {
    ///        "badge_type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "NonFungibleBadge"
    ///          ]
    ///        },
    ///        "non_fungible_id": {
    ///          "$ref": "#/components/schemas/NonFungibleId"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct AccountDepositPreValidationNonFungibleBadge {
        pub badge_type: AccountDepositPreValidationNonFungibleBadgeBadgeType,
        pub non_fungible_id: NonFungibleId,
        pub resource_address: Address,
    }
    impl From<&AccountDepositPreValidationNonFungibleBadge>
    for AccountDepositPreValidationNonFungibleBadge {
        fn from(value: &AccountDepositPreValidationNonFungibleBadge) -> Self {
            value.clone()
        }
    }
    impl AccountDepositPreValidationNonFungibleBadge {
        pub fn builder() -> builder::AccountDepositPreValidationNonFungibleBadge {
            Default::default()
        }
    }
    ///AccountDepositPreValidationNonFungibleBadgeBadgeType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "NonFungibleBadge"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum AccountDepositPreValidationNonFungibleBadgeBadgeType {
        NonFungibleBadge,
    }
    impl From<&AccountDepositPreValidationNonFungibleBadgeBadgeType>
    for AccountDepositPreValidationNonFungibleBadgeBadgeType {
        fn from(value: &AccountDepositPreValidationNonFungibleBadgeBadgeType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for AccountDepositPreValidationNonFungibleBadgeBadgeType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::NonFungibleBadge => write!(f, "NonFungibleBadge"),
            }
        }
    }
    impl std::str::FromStr for AccountDepositPreValidationNonFungibleBadgeBadgeType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "NonFungibleBadge" => Ok(Self::NonFungibleBadge),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str>
    for AccountDepositPreValidationNonFungibleBadgeBadgeType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String>
    for AccountDepositPreValidationNonFungibleBadgeBadgeType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String>
    for AccountDepositPreValidationNonFungibleBadgeBadgeType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///AccountDepositPreValidationRequest
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "account_address": "<account-address>",
    ///      "resource_addresses": [
    ///        "<resource-address>"
    ///      ]
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "account_address",
    ///    "resource_addresses"
    ///  ],
    ///  "properties": {
    ///    "account_address": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "badge": {
    ///      "$ref": "#/components/schemas/TransactionAccountDepositPreValidationAuthorizedDepositorBadge"
    ///    },
    ///    "resource_addresses": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Address"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct AccountDepositPreValidationRequest {
        pub account_address: Address,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub badge: Option<
            TransactionAccountDepositPreValidationAuthorizedDepositorBadge,
        >,
        pub resource_addresses: Vec<Address>,
    }
    impl From<&AccountDepositPreValidationRequest>
    for AccountDepositPreValidationRequest {
        fn from(value: &AccountDepositPreValidationRequest) -> Self {
            value.clone()
        }
    }
    impl AccountDepositPreValidationRequest {
        pub fn builder() -> builder::AccountDepositPreValidationRequest {
            Default::default()
        }
    }
    ///AccountDepositPreValidationResourceBadge
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/TransactionAccountDepositPreValidationAuthorizedDepositorBadgeBase"
    ///    },
    ///    {
    ///      "type": "object"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "properties": {
    ///        "badge_type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "ResourceBadge"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct AccountDepositPreValidationResourceBadge {
        pub badge_type: AccountDepositPreValidationResourceBadgeBadgeType,
        pub resource_address: Address,
    }
    impl From<&AccountDepositPreValidationResourceBadge>
    for AccountDepositPreValidationResourceBadge {
        fn from(value: &AccountDepositPreValidationResourceBadge) -> Self {
            value.clone()
        }
    }
    impl AccountDepositPreValidationResourceBadge {
        pub fn builder() -> builder::AccountDepositPreValidationResourceBadge {
            Default::default()
        }
    }
    ///AccountDepositPreValidationResourceBadgeBadgeType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ResourceBadge"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum AccountDepositPreValidationResourceBadgeBadgeType {
        ResourceBadge,
    }
    impl From<&AccountDepositPreValidationResourceBadgeBadgeType>
    for AccountDepositPreValidationResourceBadgeBadgeType {
        fn from(value: &AccountDepositPreValidationResourceBadgeBadgeType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for AccountDepositPreValidationResourceBadgeBadgeType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::ResourceBadge => write!(f, "ResourceBadge"),
            }
        }
    }
    impl std::str::FromStr for AccountDepositPreValidationResourceBadgeBadgeType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ResourceBadge" => Ok(Self::ResourceBadge),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str>
    for AccountDepositPreValidationResourceBadgeBadgeType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String>
    for AccountDepositPreValidationResourceBadgeBadgeType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String>
    for AccountDepositPreValidationResourceBadgeBadgeType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///AccountDepositPreValidationResourceSpecificBehaviourItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "allows_try_deposit",
    ///    "resource_address"
    ///  ],
    ///  "properties": {
    ///    "allows_try_deposit": {
    ///      "type": "boolean"
    ///    },
    ///    "resource_address": {
    ///      "$ref": "#/components/schemas/Address"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct AccountDepositPreValidationResourceSpecificBehaviourItem {
        pub allows_try_deposit: bool,
        pub resource_address: Address,
    }
    impl From<&AccountDepositPreValidationResourceSpecificBehaviourItem>
    for AccountDepositPreValidationResourceSpecificBehaviourItem {
        fn from(
            value: &AccountDepositPreValidationResourceSpecificBehaviourItem,
        ) -> Self {
            value.clone()
        }
    }
    impl AccountDepositPreValidationResourceSpecificBehaviourItem {
        pub fn builder() -> builder::AccountDepositPreValidationResourceSpecificBehaviourItem {
            Default::default()
        }
    }
    ///AccountDepositPreValidationResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/LedgerStateMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "allows_try_deposit_batch",
    ///        "deciding_factors",
    ///        "resource_specific"
    ///      ],
    ///      "properties": {
    ///        "allows_try_deposit_batch": {
    ///          "type": "boolean"
    ///        },
    ///        "deciding_factors": {
    ///          "$ref": "#/components/schemas/AccountDepositPreValidationDecidingFactors"
    ///        },
    ///        "resource_specific_behaviour": {
    ///          "description": "The fully resolved try_deposit_* ability of each resource (which takes all the inputs into account, including the authorized depositor badge, the default deposit rule and the resource-specific details).",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/AccountDepositPreValidationResourceSpecificBehaviourItem"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct AccountDepositPreValidationResponse {
        pub allows_try_deposit_batch: bool,
        pub deciding_factors: AccountDepositPreValidationDecidingFactors,
        pub ledger_state: LedgerState,
        pub resource_specific: ::serde_json::Value,
        ///The fully resolved try_deposit_* ability of each resource (which takes all the inputs into account, including the authorized depositor badge, the default deposit rule and the resource-specific details).
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub resource_specific_behaviour: Vec<
            AccountDepositPreValidationResourceSpecificBehaviourItem,
        >,
    }
    impl From<&AccountDepositPreValidationResponse>
    for AccountDepositPreValidationResponse {
        fn from(value: &AccountDepositPreValidationResponse) -> Self {
            value.clone()
        }
    }
    impl AccountDepositPreValidationResponse {
        pub fn builder() -> builder::AccountDepositPreValidationResponse {
            Default::default()
        }
    }
    ///AccountLockerAddress
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "account_address",
    ///    "locker_address"
    ///  ],
    ///  "properties": {
    ///    "account_address": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "locker_address": {
    ///      "$ref": "#/components/schemas/Address"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct AccountLockerAddress {
        pub account_address: Address,
        pub locker_address: Address,
    }
    impl From<&AccountLockerAddress> for AccountLockerAddress {
        fn from(value: &AccountLockerAddress) -> Self {
            value.clone()
        }
    }
    impl AccountLockerAddress {
        pub fn builder() -> builder::AccountLockerAddress {
            Default::default()
        }
    }
    ///AccountLockerNotFoundError
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/GatewayErrorBase"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/AccountLockerAddress"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "AccountLockerNotFoundError"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct AccountLockerNotFoundError {
        pub account_address: Address,
        pub locker_address: Address,
        #[serde(rename = "type")]
        pub type_: AccountLockerNotFoundErrorType,
    }
    impl From<&AccountLockerNotFoundError> for AccountLockerNotFoundError {
        fn from(value: &AccountLockerNotFoundError) -> Self {
            value.clone()
        }
    }
    impl AccountLockerNotFoundError {
        pub fn builder() -> builder::AccountLockerNotFoundError {
            Default::default()
        }
    }
    ///AccountLockerNotFoundErrorType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "AccountLockerNotFoundError"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum AccountLockerNotFoundErrorType {
        AccountLockerNotFoundError,
    }
    impl From<&AccountLockerNotFoundErrorType> for AccountLockerNotFoundErrorType {
        fn from(value: &AccountLockerNotFoundErrorType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for AccountLockerNotFoundErrorType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::AccountLockerNotFoundError => {
                    write!(f, "AccountLockerNotFoundError")
                }
            }
        }
    }
    impl std::str::FromStr for AccountLockerNotFoundErrorType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "AccountLockerNotFoundError" => Ok(Self::AccountLockerNotFoundError),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for AccountLockerNotFoundErrorType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for AccountLockerNotFoundErrorType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for AccountLockerNotFoundErrorType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///Account Locker Account Resources Collection
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Account Locker Account Resources Collection",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ResultSetCursorMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "items"
    ///      ],
    ///      "properties": {
    ///        "items": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/AccountLockerVaultCollectionItem"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct AccountLockerVaultCollection {
        pub items: Vec<AccountLockerVaultCollectionItem>,
        ///If specified, contains a cursor to query next page of the `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_cursor: Option<String>,
        ///Total number of items in underlying collection, fragment of which is available in `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_count: Option<i64>,
    }
    impl From<&AccountLockerVaultCollection> for AccountLockerVaultCollection {
        fn from(value: &AccountLockerVaultCollection) -> Self {
            value.clone()
        }
    }
    impl AccountLockerVaultCollection {
        pub fn builder() -> builder::AccountLockerVaultCollection {
            Default::default()
        }
    }
    ///AccountLockerVaultCollectionItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/AccountLockerVaultCollectionItemFungible"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/AccountLockerVaultCollectionItemNonFungible"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum AccountLockerVaultCollectionItem {
        Fungible(AccountLockerVaultCollectionItemFungible),
        NonFungible(AccountLockerVaultCollectionItemNonFungible),
    }
    impl From<&AccountLockerVaultCollectionItem> for AccountLockerVaultCollectionItem {
        fn from(value: &AccountLockerVaultCollectionItem) -> Self {
            value.clone()
        }
    }
    impl From<AccountLockerVaultCollectionItemFungible>
    for AccountLockerVaultCollectionItem {
        fn from(value: AccountLockerVaultCollectionItemFungible) -> Self {
            Self::Fungible(value)
        }
    }
    impl From<AccountLockerVaultCollectionItemNonFungible>
    for AccountLockerVaultCollectionItem {
        fn from(value: AccountLockerVaultCollectionItemNonFungible) -> Self {
            Self::NonFungible(value)
        }
    }
    ///AccountLockerVaultCollectionItemBase
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "last_updated_at_state_version",
    ///    "resource_address",
    ///    "type",
    ///    "vault_address"
    ///  ],
    ///  "properties": {
    ///    "last_updated_at_state_version": {
    ///      "$ref": "#/components/schemas/LastUpdatedAtStateVersion"
    ///    },
    ///    "resource_address": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "type": {
    ///      "$ref": "#/components/schemas/AccountLockerVaultCollectionItemType"
    ///    },
    ///    "vault_address": {
    ///      "$ref": "#/components/schemas/Address"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct AccountLockerVaultCollectionItemBase {
        pub last_updated_at_state_version: LastUpdatedAtStateVersion,
        pub resource_address: Address,
        #[serde(rename = "type")]
        pub type_: AccountLockerVaultCollectionItemType,
        pub vault_address: Address,
    }
    impl From<&AccountLockerVaultCollectionItemBase>
    for AccountLockerVaultCollectionItemBase {
        fn from(value: &AccountLockerVaultCollectionItemBase) -> Self {
            value.clone()
        }
    }
    impl AccountLockerVaultCollectionItemBase {
        pub fn builder() -> builder::AccountLockerVaultCollectionItemBase {
            Default::default()
        }
    }
    ///AccountLockerVaultCollectionItemFungible
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/AccountLockerVaultCollectionItemBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "amount"
    ///      ],
    ///      "properties": {
    ///        "amount": {
    ///          "$ref": "#/components/schemas/BigDecimal"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "Fungible"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct AccountLockerVaultCollectionItemFungible {
        pub amount: BigDecimal,
        pub last_updated_at_state_version: LastUpdatedAtStateVersion,
        pub resource_address: Address,
        #[serde(rename = "type")]
        pub type_: AccountLockerVaultCollectionItemFungibleType,
        pub vault_address: Address,
    }
    impl From<&AccountLockerVaultCollectionItemFungible>
    for AccountLockerVaultCollectionItemFungible {
        fn from(value: &AccountLockerVaultCollectionItemFungible) -> Self {
            value.clone()
        }
    }
    impl AccountLockerVaultCollectionItemFungible {
        pub fn builder() -> builder::AccountLockerVaultCollectionItemFungible {
            Default::default()
        }
    }
    ///AccountLockerVaultCollectionItemFungibleType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "Fungible"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum AccountLockerVaultCollectionItemFungibleType {
        Fungible,
    }
    impl From<&AccountLockerVaultCollectionItemFungibleType>
    for AccountLockerVaultCollectionItemFungibleType {
        fn from(value: &AccountLockerVaultCollectionItemFungibleType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for AccountLockerVaultCollectionItemFungibleType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Fungible => write!(f, "Fungible"),
            }
        }
    }
    impl std::str::FromStr for AccountLockerVaultCollectionItemFungibleType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "Fungible" => Ok(Self::Fungible),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for AccountLockerVaultCollectionItemFungibleType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String>
    for AccountLockerVaultCollectionItemFungibleType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for AccountLockerVaultCollectionItemFungibleType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///AccountLockerVaultCollectionItemNonFungible
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/AccountLockerVaultCollectionItemBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "total_count"
    ///      ],
    ///      "properties": {
    ///        "total_count": {
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "NonFungible"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct AccountLockerVaultCollectionItemNonFungible {
        pub last_updated_at_state_version: LastUpdatedAtStateVersion,
        pub resource_address: Address,
        pub total_count: i64,
        #[serde(rename = "type")]
        pub type_: AccountLockerVaultCollectionItemNonFungibleType,
        pub vault_address: Address,
    }
    impl From<&AccountLockerVaultCollectionItemNonFungible>
    for AccountLockerVaultCollectionItemNonFungible {
        fn from(value: &AccountLockerVaultCollectionItemNonFungible) -> Self {
            value.clone()
        }
    }
    impl AccountLockerVaultCollectionItemNonFungible {
        pub fn builder() -> builder::AccountLockerVaultCollectionItemNonFungible {
            Default::default()
        }
    }
    ///AccountLockerVaultCollectionItemNonFungibleType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "NonFungible"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum AccountLockerVaultCollectionItemNonFungibleType {
        NonFungible,
    }
    impl From<&AccountLockerVaultCollectionItemNonFungibleType>
    for AccountLockerVaultCollectionItemNonFungibleType {
        fn from(value: &AccountLockerVaultCollectionItemNonFungibleType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for AccountLockerVaultCollectionItemNonFungibleType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::NonFungible => write!(f, "NonFungible"),
            }
        }
    }
    impl std::str::FromStr for AccountLockerVaultCollectionItemNonFungibleType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "NonFungible" => Ok(Self::NonFungible),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str>
    for AccountLockerVaultCollectionItemNonFungibleType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String>
    for AccountLockerVaultCollectionItemNonFungibleType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String>
    for AccountLockerVaultCollectionItemNonFungibleType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///AccountLockerVaultCollectionItemType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "Fungible",
    ///    "NonFungible"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum AccountLockerVaultCollectionItemType {
        Fungible,
        NonFungible,
    }
    impl From<&AccountLockerVaultCollectionItemType>
    for AccountLockerVaultCollectionItemType {
        fn from(value: &AccountLockerVaultCollectionItemType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for AccountLockerVaultCollectionItemType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Fungible => write!(f, "Fungible"),
                Self::NonFungible => write!(f, "NonFungible"),
            }
        }
    }
    impl std::str::FromStr for AccountLockerVaultCollectionItemType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "Fungible" => Ok(Self::Fungible),
                "NonFungible" => Ok(Self::NonFungible),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for AccountLockerVaultCollectionItemType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for AccountLockerVaultCollectionItemType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for AccountLockerVaultCollectionItemType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///AccountResourcePreferenceRule
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "Allowed",
    ///    "Disallowed"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum AccountResourcePreferenceRule {
        Allowed,
        Disallowed,
    }
    impl From<&AccountResourcePreferenceRule> for AccountResourcePreferenceRule {
        fn from(value: &AccountResourcePreferenceRule) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for AccountResourcePreferenceRule {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Allowed => write!(f, "Allowed"),
                Self::Disallowed => write!(f, "Disallowed"),
            }
        }
    }
    impl std::str::FromStr for AccountResourcePreferenceRule {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "Allowed" => Ok(Self::Allowed),
                "Disallowed" => Ok(Self::Disallowed),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for AccountResourcePreferenceRule {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for AccountResourcePreferenceRule {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for AccountResourcePreferenceRule {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///Account resource preferences collection
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Account resource preferences collection",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ResultSetCursorMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "items"
    ///      ],
    ///      "properties": {
    ///        "items": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/AccountResourcePreferencesResponseItem"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct AccountResourcePreferencesCollection {
        pub items: Vec<AccountResourcePreferencesResponseItem>,
        ///If specified, contains a cursor to query next page of the `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_cursor: Option<String>,
        ///Total number of items in underlying collection, fragment of which is available in `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_count: Option<i64>,
    }
    impl From<&AccountResourcePreferencesCollection>
    for AccountResourcePreferencesCollection {
        fn from(value: &AccountResourcePreferencesCollection) -> Self {
            value.clone()
        }
    }
    impl AccountResourcePreferencesCollection {
        pub fn builder() -> builder::AccountResourcePreferencesCollection {
            Default::default()
        }
    }
    ///AccountResourcePreferencesResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "last_updated_at_state_version",
    ///    "resource_address",
    ///    "resource_preference_rule"
    ///  ],
    ///  "properties": {
    ///    "last_updated_at_state_version": {
    ///      "$ref": "#/components/schemas/LastUpdatedAtStateVersion"
    ///    },
    ///    "resource_address": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "resource_preference_rule": {
    ///      "$ref": "#/components/schemas/AccountResourcePreferenceRule"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct AccountResourcePreferencesResponseItem {
        pub last_updated_at_state_version: LastUpdatedAtStateVersion,
        pub resource_address: Address,
        pub resource_preference_rule: AccountResourcePreferenceRule,
    }
    impl From<&AccountResourcePreferencesResponseItem>
    for AccountResourcePreferencesResponseItem {
        fn from(value: &AccountResourcePreferencesResponseItem) -> Self {
            value.clone()
        }
    }
    impl AccountResourcePreferencesResponseItem {
        pub fn builder() -> builder::AccountResourcePreferencesResponseItem {
            Default::default()
        }
    }
    ///Bech32m-encoded human readable version of the address.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Bech32m-encoded human readable version of the address.",
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub struct Address(pub String);
    impl ::std::ops::Deref for Address {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<Address> for String {
        fn from(value: Address) -> Self {
            value.0
        }
    }
    impl From<&Address> for Address {
        fn from(value: &Address) -> Self {
            value.clone()
        }
    }
    impl From<String> for Address {
        fn from(value: String) -> Self {
            Self(value)
        }
    }
    impl std::str::FromStr for Address {
        type Err = std::convert::Infallible;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::fmt::Display for Address {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }
    ///defines upper boundary (inclusive) for queried data. i.e `{ "at_state_version" = {"epoch" = 10} }`, will return data till 10 epoch.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "defines upper boundary (inclusive) for queried data. i.e `{ \"at_state_version\" = {\"epoch\" = 10} }`, will return data till 10 epoch.",
    ///  "type": "object",
    ///  "properties": {
    ///    "at_ledger_state": {
    ///      "$ref": "#/components/schemas/LedgerStateSelector"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct AtLedgerStateMixin {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub at_ledger_state: Option<LedgerStateSelector>,
    }
    impl From<&AtLedgerStateMixin> for AtLedgerStateMixin {
        fn from(value: &AtLedgerStateMixin) -> Self {
            value.clone()
        }
    }
    impl AtLedgerStateMixin {
        pub fn builder() -> builder::AtLedgerStateMixin {
            Default::default()
        }
    }
    ///String-encoded decimal representing the amount of a related fungible resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "String-encoded decimal representing the amount of a related fungible resource.",
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub struct BigDecimal(pub String);
    impl ::std::ops::Deref for BigDecimal {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<BigDecimal> for String {
        fn from(value: BigDecimal) -> Self {
            value.0
        }
    }
    impl From<&BigDecimal> for BigDecimal {
        fn from(value: &BigDecimal) -> Self {
            value.clone()
        }
    }
    impl From<String> for BigDecimal {
        fn from(value: String) -> Self {
            Self(value)
        }
    }
    impl std::str::FromStr for BigDecimal {
        type Err = std::convert::Infallible;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::fmt::Display for BigDecimal {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }
    ///BlueprintMethodRoyalty
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "method_name"
    ///  ],
    ///  "properties": {
    ///    "method_name": {
    ///      "type": "string"
    ///    },
    ///    "royalty_amount": {
    ///      "$ref": "#/components/schemas/RoyaltyAmount"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct BlueprintMethodRoyalty {
        pub method_name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub royalty_amount: Option<RoyaltyAmount>,
    }
    impl From<&BlueprintMethodRoyalty> for BlueprintMethodRoyalty {
        fn from(value: &BlueprintMethodRoyalty) -> Self {
            value.clone()
        }
    }
    impl BlueprintMethodRoyalty {
        pub fn builder() -> builder::BlueprintMethodRoyalty {
            Default::default()
        }
    }
    ///BlueprintRoyaltyConfig
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "is_enabled"
    ///  ],
    ///  "properties": {
    ///    "is_enabled": {
    ///      "type": "boolean"
    ///    },
    ///    "method_rules": {
    ///      "description": "The royalty rules by method. The array is only present if royalties are enabled.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/BlueprintMethodRoyalty"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct BlueprintRoyaltyConfig {
        pub is_enabled: bool,
        ///The royalty rules by method. The array is only present if royalties are enabled.
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub method_rules: Vec<BlueprintMethodRoyalty>,
    }
    impl From<&BlueprintRoyaltyConfig> for BlueprintRoyaltyConfig {
        fn from(value: &BlueprintRoyaltyConfig) -> Self {
            value.clone()
        }
    }
    impl BlueprintRoyaltyConfig {
        pub fn builder() -> builder::BlueprintRoyaltyConfig {
            Default::default()
        }
    }
    ///CommittedTransactionInfo
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "epoch",
    ///    "round",
    ///    "round_timestamp",
    ///    "state_version",
    ///    "transaction_status"
    ///  ],
    ///  "properties": {
    ///    "affected_global_entities": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Address"
    ///      }
    ///    },
    ///    "balance_changes": {
    ///      "$ref": "#/components/schemas/TransactionBalanceChanges"
    ///    },
    ///    "child_subintent_hashes": {
    ///      "description": "The child subintent hashes of the root transaction intent.\nPlease note that it is returned regardless of whether the transaction was committed successfully or failed, and it can be returned in multiple transactions.\n",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/HashBech32mString"
    ///      }
    ///    },
    ///    "confirmed_at": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "format": "date-time"
    ///    },
    ///    "epoch": {
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "error_message": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "fee_paid": {
    ///      "$ref": "#/components/schemas/BigDecimal"
    ///    },
    ///    "intent_hash": {
    ///      "$ref": "#/components/schemas/HashBech32mString"
    ///    },
    ///    "manifest_classes": {
    ///      "description": "A collection of zero or more manifest classes ordered from the most specific class to the least specific one.\nThis field will be present only for user transactions.\nFor user transactions with subintents only the root transaction intent is currently used to determine the manifest classes.\n",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ManifestClass"
    ///      }
    ///    },
    ///    "manifest_instructions": {
    ///      "description": "A text-representation of a transaction manifest.\nThis field will be present only for user transactions and when explicitly opted-in using the `manifest_instructions` flag.\n",
    ///      "type": "string"
    ///    },
    ///    "message": {
    ///      "description": "The optional transaction message.\nThis type is defined in the Core API as `TransactionMessage`. See the Core API documentation for more details.\n",
    ///      "type": "object"
    ///    },
    ///    "payload_hash": {
    ///      "$ref": "#/components/schemas/HashBech32mString"
    ///    },
    ///    "raw_hex": {
    ///      "$ref": "#/components/schemas/HexString"
    ///    },
    ///    "receipt": {
    ///      "$ref": "#/components/schemas/TransactionReceipt"
    ///    },
    ///    "round": {
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "round_timestamp": {
    ///      "type": "string"
    ///    },
    ///    "state_version": {
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "subintent_details": {
    ///      "description": "Subintent details.\nPlease note that it is returned regardless of whether the transaction was committed successfully or failed, and it can be returned in multiple transactions.\n",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/TransactionSubintentDetails"
    ///      }
    ///    },
    ///    "transaction_status": {
    ///      "$ref": "#/components/schemas/TransactionStatus"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct CommittedTransactionInfo {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub affected_global_entities: Vec<Address>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub balance_changes: Option<TransactionBalanceChanges>,
        /**The child subintent hashes of the root transaction intent.
Please note that it is returned regardless of whether the transaction was committed successfully or failed, and it can be returned in multiple transactions.
*/
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub child_subintent_hashes: Vec<HashBech32mString>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub confirmed_at: Option<chrono::DateTime<chrono::offset::Utc>>,
        pub epoch: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub error_message: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fee_paid: Option<BigDecimal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub intent_hash: Option<HashBech32mString>,
        /**A collection of zero or more manifest classes ordered from the most specific class to the least specific one.
This field will be present only for user transactions.
For user transactions with subintents only the root transaction intent is currently used to determine the manifest classes.
*/
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub manifest_classes: Vec<ManifestClass>,
        /**A text-representation of a transaction manifest.
This field will be present only for user transactions and when explicitly opted-in using the `manifest_instructions` flag.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub manifest_instructions: Option<String>,
        /**The optional transaction message.
This type is defined in the Core API as `TransactionMessage`. See the Core API documentation for more details.
*/
        #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
        pub message: ::serde_json::Map<String, ::serde_json::Value>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub payload_hash: Option<HashBech32mString>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub raw_hex: Option<HexString>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub receipt: Option<TransactionReceipt>,
        pub round: i64,
        pub round_timestamp: String,
        pub state_version: i64,
        /**Subintent details.
Please note that it is returned regardless of whether the transaction was committed successfully or failed, and it can be returned in multiple transactions.
*/
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub subintent_details: Vec<TransactionSubintentDetails>,
        pub transaction_status: TransactionStatus,
    }
    impl From<&CommittedTransactionInfo> for CommittedTransactionInfo {
        fn from(value: &CommittedTransactionInfo) -> Self {
            value.clone()
        }
    }
    impl CommittedTransactionInfo {
        pub fn builder() -> builder::CommittedTransactionInfo {
            Default::default()
        }
    }
    ///CompiledPreviewTransaction
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/PreviewTransactionBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "preview_transaction_hex"
    ///      ],
    ///      "properties": {
    ///        "preview_transaction_hex": {
    ///          "description": "A hex-encoded, compiled `RawPreviewTransaction`.\n\nAs of Cuttlefish, only `PreviewTransactionV2` is supported.\n\nA `PreviewTransactionV2` can be created with a v2 transaction builder:\n* If using Rust, it can be created with a `TransactionV2Builder` using `build_preview_transaction()`\n  and then converted to hex with `preview_transaction.to_raw().unwrap().to_hex()`\n* If using the toolkit, you can create this using the v2 transaction builder.\n\nSome subtleties:\n* Partial transactions can't be previewed. Instead, they must be wrapped inside a\n  transaction wrapper, so that the engine knows how to yield to them appropriately.\n* Currently the builder assumes that the signed partial transactions have real signatures.\n  This isn't strictly required, and we may create a builder in future which allows providing\n  public keys when building partial transactions for use in preview.\n* If you don't have signatures to hand, you can simply not sign the partial transactions,\n  and then use the `assume_all_signature_proofs` preview flag, although be advised that\n  this may result in the fee estimate being slightly lower during preview.\n* We may create more ergonomic builders for PreviewTransactions which allow use of\n  public keys to denote the signers of subintents. Let us know if this is important\n  for your use case.\n",
    ///          "type": "string"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "Compiled"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct CompiledPreviewTransaction {
        /**A hex-encoded, compiled `RawPreviewTransaction`.

As of Cuttlefish, only `PreviewTransactionV2` is supported.

A `PreviewTransactionV2` can be created with a v2 transaction builder:
* If using Rust, it can be created with a `TransactionV2Builder` using `build_preview_transaction()`
  and then converted to hex with `preview_transaction.to_raw().unwrap().to_hex()`
* If using the toolkit, you can create this using the v2 transaction builder.

Some subtleties:
* Partial transactions can't be previewed. Instead, they must be wrapped inside a
  transaction wrapper, so that the engine knows how to yield to them appropriately.
* Currently the builder assumes that the signed partial transactions have real signatures.
  This isn't strictly required, and we may create a builder in future which allows providing
  public keys when building partial transactions for use in preview.
* If you don't have signatures to hand, you can simply not sign the partial transactions,
  and then use the `assume_all_signature_proofs` preview flag, although be advised that
  this may result in the fee estimate being slightly lower during preview.
* We may create more ergonomic builders for PreviewTransactions which allow use of
  public keys to denote the signers of subintents. Let us know if this is important
  for your use case.
*/
        pub preview_transaction_hex: String,
        #[serde(rename = "type")]
        pub type_: PreviewTransactionType,
    }
    impl From<&CompiledPreviewTransaction> for CompiledPreviewTransaction {
        fn from(value: &CompiledPreviewTransaction) -> Self {
            value.clone()
        }
    }
    impl CompiledPreviewTransaction {
        pub fn builder() -> builder::CompiledPreviewTransaction {
            Default::default()
        }
    }
    ///ComponentEntityRoleAssignmentEntry
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "assignment",
    ///    "role_key"
    ///  ],
    ///  "properties": {
    ///    "assignment": {
    ///      "type": "object",
    ///      "required": [
    ///        "resolution"
    ///      ],
    ///      "properties": {
    ///        "explicit_rule": {
    ///          "description": "This type is defined in the Core API as `AccessRule`. See the Core API documentation for more details.\n",
    ///          "type": "object"
    ///        },
    ///        "resolution": {
    ///          "$ref": "#/components/schemas/RoleAssignmentResolution"
    ///        }
    ///      }
    ///    },
    ///    "role_key": {
    ///      "$ref": "#/components/schemas/RoleKey"
    ///    },
    ///    "updater_roles": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/RoleKey"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ComponentEntityRoleAssignmentEntry {
        pub assignment: ComponentEntityRoleAssignmentEntryAssignment,
        pub role_key: RoleKey,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub updater_roles: Vec<RoleKey>,
    }
    impl From<&ComponentEntityRoleAssignmentEntry>
    for ComponentEntityRoleAssignmentEntry {
        fn from(value: &ComponentEntityRoleAssignmentEntry) -> Self {
            value.clone()
        }
    }
    impl ComponentEntityRoleAssignmentEntry {
        pub fn builder() -> builder::ComponentEntityRoleAssignmentEntry {
            Default::default()
        }
    }
    ///ComponentEntityRoleAssignmentEntryAssignment
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "resolution"
    ///  ],
    ///  "properties": {
    ///    "explicit_rule": {
    ///      "description": "This type is defined in the Core API as `AccessRule`. See the Core API documentation for more details.\n",
    ///      "type": "object"
    ///    },
    ///    "resolution": {
    ///      "$ref": "#/components/schemas/RoleAssignmentResolution"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ComponentEntityRoleAssignmentEntryAssignment {
        /**This type is defined in the Core API as `AccessRule`. See the Core API documentation for more details.
*/
        #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
        pub explicit_rule: ::serde_json::Map<String, ::serde_json::Value>,
        pub resolution: RoleAssignmentResolution,
    }
    impl From<&ComponentEntityRoleAssignmentEntryAssignment>
    for ComponentEntityRoleAssignmentEntryAssignment {
        fn from(value: &ComponentEntityRoleAssignmentEntryAssignment) -> Self {
            value.clone()
        }
    }
    impl ComponentEntityRoleAssignmentEntryAssignment {
        pub fn builder() -> builder::ComponentEntityRoleAssignmentEntryAssignment {
            Default::default()
        }
    }
    ///ComponentEntityRoleAssignments
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "entries",
    ///    "owner"
    ///  ],
    ///  "properties": {
    ///    "entries": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ComponentEntityRoleAssignmentEntry"
    ///      }
    ///    },
    ///    "owner": {
    ///      "description": "This type is defined in the Core API as `OwnerRole`. See the Core API documentation for more details.\n",
    ///      "type": "object"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ComponentEntityRoleAssignments {
        pub entries: Vec<ComponentEntityRoleAssignmentEntry>,
        /**This type is defined in the Core API as `OwnerRole`. See the Core API documentation for more details.
*/
        pub owner: ::serde_json::Map<String, ::serde_json::Value>,
    }
    impl From<&ComponentEntityRoleAssignments> for ComponentEntityRoleAssignments {
        fn from(value: &ComponentEntityRoleAssignments) -> Self {
            value.clone()
        }
    }
    impl ComponentEntityRoleAssignments {
        pub fn builder() -> builder::ComponentEntityRoleAssignments {
            Default::default()
        }
    }
    ///ComponentMethodRoyalty
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "method_name"
    ///  ],
    ///  "properties": {
    ///    "method_name": {
    ///      "type": "string"
    ///    },
    ///    "royalty_amount": {
    ///      "$ref": "#/components/schemas/RoyaltyAmount"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ComponentMethodRoyalty {
        pub method_name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub royalty_amount: Option<RoyaltyAmount>,
    }
    impl From<&ComponentMethodRoyalty> for ComponentMethodRoyalty {
        fn from(value: &ComponentMethodRoyalty) -> Self {
            value.clone()
        }
    }
    impl ComponentMethodRoyalty {
        pub fn builder() -> builder::ComponentMethodRoyalty {
            Default::default()
        }
    }
    ///ComponentRoyaltyConfig
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "is_enabled"
    ///  ],
    ///  "properties": {
    ///    "is_enabled": {
    ///      "type": "boolean"
    ///    },
    ///    "method_rules": {
    ///      "description": "The royalty rules by method. The array is only present if royalties are enabled.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ComponentMethodRoyalty"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ComponentRoyaltyConfig {
        pub is_enabled: bool,
        ///The royalty rules by method. The array is only present if royalties are enabled.
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub method_rules: Vec<ComponentMethodRoyalty>,
    }
    impl From<&ComponentRoyaltyConfig> for ComponentRoyaltyConfig {
        fn from(value: &ComponentRoyaltyConfig) -> Self {
            value.clone()
        }
    }
    impl ComponentRoyaltyConfig {
        pub fn builder() -> builder::ComponentRoyaltyConfig {
            Default::default()
        }
    }
    ///CursorLimitMixin
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "cursor": {
    ///      "description": "This cursor allows forward pagination, by providing the cursor from the previous request.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "limit_per_page": {
    ///      "description": "The page size requested.",
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct CursorLimitMixin {
        ///This cursor allows forward pagination, by providing the cursor from the previous request.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub cursor: Option<String>,
        ///The page size requested.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub limit_per_page: Option<i64>,
    }
    impl From<&CursorLimitMixin> for CursorLimitMixin {
        fn from(value: &CursorLimitMixin) -> Self {
            value.clone()
        }
    }
    impl CursorLimitMixin {
        pub fn builder() -> builder::CursorLimitMixin {
            Default::default()
        }
    }
    ///Entity metadata collection.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Entity metadata collection.",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ResultSetCursorMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "items"
    ///      ],
    ///      "properties": {
    ///        "items": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/EntityMetadataItem"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct EntityMetadataCollection {
        pub items: Vec<EntityMetadataItem>,
        ///If specified, contains a cursor to query next page of the `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_cursor: Option<String>,
        ///Total number of items in underlying collection, fragment of which is available in `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_count: Option<i64>,
    }
    impl From<&EntityMetadataCollection> for EntityMetadataCollection {
        fn from(value: &EntityMetadataCollection) -> Self {
            value.clone()
        }
    }
    impl EntityMetadataCollection {
        pub fn builder() -> builder::EntityMetadataCollection {
            Default::default()
        }
    }
    ///Entity metadata key-value pair.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Entity metadata key-value pair.",
    ///  "type": "object",
    ///  "required": [
    ///    "is_locked",
    ///    "key",
    ///    "last_updated_at_state_version",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "is_locked": {
    ///      "type": "boolean"
    ///    },
    ///    "key": {
    ///      "description": "Entity metadata key.",
    ///      "type": "string"
    ///    },
    ///    "last_updated_at_state_version": {
    ///      "$ref": "#/components/schemas/LastUpdatedAtStateVersion"
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/EntityMetadataItemValue"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct EntityMetadataItem {
        pub is_locked: bool,
        ///Entity metadata key.
        pub key: String,
        pub last_updated_at_state_version: LastUpdatedAtStateVersion,
        pub value: EntityMetadataItemValue,
    }
    impl From<&EntityMetadataItem> for EntityMetadataItem {
        fn from(value: &EntityMetadataItem) -> Self {
            value.clone()
        }
    }
    impl EntityMetadataItem {
        pub fn builder() -> builder::EntityMetadataItem {
            Default::default()
        }
    }
    ///EntityMetadataItemValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ScryptoSborValue"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "typed"
    ///      ],
    ///      "properties": {
    ///        "typed": {
    ///          "$ref": "#/components/schemas/MetadataTypedValue"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct EntityMetadataItemValue {
        pub programmatic_json: ProgrammaticScryptoSborValue,
        pub raw_hex: HexString,
        pub typed: MetadataTypedValue,
    }
    impl From<&EntityMetadataItemValue> for EntityMetadataItemValue {
        fn from(value: &EntityMetadataItemValue) -> Self {
            value.clone()
        }
    }
    impl EntityMetadataItemValue {
        pub fn builder() -> builder::EntityMetadataItemValue {
            Default::default()
        }
    }
    ///EntityNotFoundError
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/GatewayErrorBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "address"
    ///      ],
    ///      "properties": {
    ///        "address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "EntityNotFoundError"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct EntityNotFoundError {
        pub address: Address,
        #[serde(rename = "type")]
        pub type_: EntityNotFoundErrorType,
    }
    impl From<&EntityNotFoundError> for EntityNotFoundError {
        fn from(value: &EntityNotFoundError) -> Self {
            value.clone()
        }
    }
    impl EntityNotFoundError {
        pub fn builder() -> builder::EntityNotFoundError {
            Default::default()
        }
    }
    ///EntityNotFoundErrorType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "EntityNotFoundError"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum EntityNotFoundErrorType {
        EntityNotFoundError,
    }
    impl From<&EntityNotFoundErrorType> for EntityNotFoundErrorType {
        fn from(value: &EntityNotFoundErrorType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EntityNotFoundErrorType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EntityNotFoundError => write!(f, "EntityNotFoundError"),
            }
        }
    }
    impl std::str::FromStr for EntityNotFoundErrorType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "EntityNotFoundError" => Ok(Self::EntityNotFoundError),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for EntityNotFoundErrorType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for EntityNotFoundErrorType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for EntityNotFoundErrorType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///EntitySchemaCollection
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ResultSetCursorMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "items"
    ///      ],
    ///      "properties": {
    ///        "items": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/EntitySchemaCollectionItem"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct EntitySchemaCollection {
        pub items: Vec<EntitySchemaCollectionItem>,
        ///If specified, contains a cursor to query next page of the `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_cursor: Option<String>,
        ///Total number of items in underlying collection, fragment of which is available in `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_count: Option<i64>,
    }
    impl From<&EntitySchemaCollection> for EntitySchemaCollection {
        fn from(value: &EntitySchemaCollection) -> Self {
            value.clone()
        }
    }
    impl EntitySchemaCollection {
        pub fn builder() -> builder::EntitySchemaCollection {
            Default::default()
        }
    }
    ///EntitySchemaCollectionItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "schema_hash_hex",
    ///    "schema_hex"
    ///  ],
    ///  "properties": {
    ///    "schema_hash_hex": {
    ///      "$ref": "#/components/schemas/HexString"
    ///    },
    ///    "schema_hex": {
    ///      "$ref": "#/components/schemas/HexString"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct EntitySchemaCollectionItem {
        pub schema_hash_hex: HexString,
        pub schema_hex: HexString,
    }
    impl From<&EntitySchemaCollectionItem> for EntitySchemaCollectionItem {
        fn from(value: &EntitySchemaCollectionItem) -> Self {
            value.clone()
        }
    }
    impl EntitySchemaCollectionItem {
        pub fn builder() -> builder::EntitySchemaCollectionItem {
            Default::default()
        }
    }
    ///ErrorResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "message"
    ///  ],
    ///  "properties": {
    ///    "code": {
    ///      "description": "A numeric code corresponding to the given error type.",
    ///      "type": "integer"
    ///    },
    ///    "details": {
    ///      "$ref": "#/components/schemas/GatewayError"
    ///    },
    ///    "message": {
    ///      "description": "A human-readable error message.",
    ///      "type": "string"
    ///    },
    ///    "trace_id": {
    ///      "description": "A unique request identifier to be used when reporting errors, to allow correlation with the Gateway API's error logs.",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ErrorResponse {
        ///A numeric code corresponding to the given error type.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub code: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub details: Option<GatewayError>,
        ///A human-readable error message.
        pub message: String,
        ///A unique request identifier to be used when reporting errors, to allow correlation with the Gateway API's error logs.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub trace_id: Option<String>,
    }
    impl From<&ErrorResponse> for ErrorResponse {
        fn from(value: &ErrorResponse) -> Self {
            value.clone()
        }
    }
    impl ErrorResponse {
        pub fn builder() -> builder::ErrorResponse {
            Default::default()
        }
    }
    ///EventsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "data",
    ///    "emitter",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "data": {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValue"
    ///    },
    ///    "emitter": {
    ///      "description": "This type is defined in the Core API as `EventEmitterIdentifier`. See the Core API documentation for more details.\n",
    ///      "type": "object"
    ///    },
    ///    "name": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct EventsItem {
        pub data: ProgrammaticScryptoSborValue,
        /**This type is defined in the Core API as `EventEmitterIdentifier`. See the Core API documentation for more details.
*/
        pub emitter: ::serde_json::Map<String, ::serde_json::Value>,
        pub name: String,
    }
    impl From<&EventsItem> for EventsItem {
        fn from(value: &EventsItem) -> Self {
            value.clone()
        }
    }
    impl EventsItem {
        pub fn builder() -> builder::EventsItem {
            Default::default()
        }
    }
    ///defines lower boundary (inclusive) for queried data. i.e `{ "from_state_version" = {"epoch" = 10} }`, will return data from epoch 10 till current max ledger tip.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "defines lower boundary (inclusive) for queried data. i.e `{ \"from_state_version\" = {\"epoch\" = 10} }`, will return data from epoch 10 till current max ledger tip.",
    ///  "type": "object",
    ///  "properties": {
    ///    "from_ledger_state": {
    ///      "$ref": "#/components/schemas/LedgerStateSelector"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct FromLedgerStateMixin {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub from_ledger_state: Option<LedgerStateSelector>,
    }
    impl From<&FromLedgerStateMixin> for FromLedgerStateMixin {
        fn from(value: &FromLedgerStateMixin) -> Self {
            value.clone()
        }
    }
    impl FromLedgerStateMixin {
        pub fn builder() -> builder::FromLedgerStateMixin {
            Default::default()
        }
    }
    ///Fungible resources collection.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Fungible resources collection.",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ResultSetCursorMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "items"
    ///      ],
    ///      "properties": {
    ///        "items": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/FungibleResourcesCollectionItem"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct FungibleResourcesCollection {
        pub items: Vec<FungibleResourcesCollectionItem>,
        ///If specified, contains a cursor to query next page of the `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_cursor: Option<String>,
        ///Total number of items in underlying collection, fragment of which is available in `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_count: Option<i64>,
    }
    impl From<&FungibleResourcesCollection> for FungibleResourcesCollection {
        fn from(value: &FungibleResourcesCollection) -> Self {
            value.clone()
        }
    }
    impl FungibleResourcesCollection {
        pub fn builder() -> builder::FungibleResourcesCollection {
            Default::default()
        }
    }
    ///FungibleResourcesCollectionItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/FungibleResourcesCollectionItemGloballyAggregated"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/FungibleResourcesCollectionItemVaultAggregated"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum FungibleResourcesCollectionItem {
        GloballyAggregated(FungibleResourcesCollectionItemGloballyAggregated),
        VaultAggregated(FungibleResourcesCollectionItemVaultAggregated),
    }
    impl From<&FungibleResourcesCollectionItem> for FungibleResourcesCollectionItem {
        fn from(value: &FungibleResourcesCollectionItem) -> Self {
            value.clone()
        }
    }
    impl From<FungibleResourcesCollectionItemGloballyAggregated>
    for FungibleResourcesCollectionItem {
        fn from(value: FungibleResourcesCollectionItemGloballyAggregated) -> Self {
            Self::GloballyAggregated(value)
        }
    }
    impl From<FungibleResourcesCollectionItemVaultAggregated>
    for FungibleResourcesCollectionItem {
        fn from(value: FungibleResourcesCollectionItemVaultAggregated) -> Self {
            Self::VaultAggregated(value)
        }
    }
    ///FungibleResourcesCollectionItemBase
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "aggregation_level",
    ///    "resource_address"
    ///  ],
    ///  "properties": {
    ///    "aggregation_level": {
    ///      "$ref": "#/components/schemas/ResourceAggregationLevel"
    ///    },
    ///    "explicit_metadata": {
    ///      "$ref": "#/components/schemas/EntityMetadataCollection"
    ///    },
    ///    "resource_address": {
    ///      "$ref": "#/components/schemas/Address"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct FungibleResourcesCollectionItemBase {
        pub aggregation_level: ResourceAggregationLevel,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub explicit_metadata: Option<EntityMetadataCollection>,
        pub resource_address: Address,
    }
    impl From<&FungibleResourcesCollectionItemBase>
    for FungibleResourcesCollectionItemBase {
        fn from(value: &FungibleResourcesCollectionItemBase) -> Self {
            value.clone()
        }
    }
    impl FungibleResourcesCollectionItemBase {
        pub fn builder() -> builder::FungibleResourcesCollectionItemBase {
            Default::default()
        }
    }
    ///FungibleResourcesCollectionItemGloballyAggregated
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/FungibleResourcesCollectionItemBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "amount",
    ///        "last_updated_at_state_version"
    ///      ],
    ///      "properties": {
    ///        "aggregation_level": {
    ///          "type": "string",
    ///          "enum": [
    ///            "Global"
    ///          ]
    ///        },
    ///        "amount": {
    ///          "$ref": "#/components/schemas/BigDecimal"
    ///        },
    ///        "last_updated_at_state_version": {
    ///          "$ref": "#/components/schemas/LastUpdatedAtStateVersion"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct FungibleResourcesCollectionItemGloballyAggregated {
        pub aggregation_level: FungibleResourcesCollectionItemGloballyAggregatedAggregationLevel,
        pub amount: BigDecimal,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub explicit_metadata: Option<EntityMetadataCollection>,
        pub last_updated_at_state_version: LastUpdatedAtStateVersion,
        pub resource_address: Address,
    }
    impl From<&FungibleResourcesCollectionItemGloballyAggregated>
    for FungibleResourcesCollectionItemGloballyAggregated {
        fn from(value: &FungibleResourcesCollectionItemGloballyAggregated) -> Self {
            value.clone()
        }
    }
    impl FungibleResourcesCollectionItemGloballyAggregated {
        pub fn builder() -> builder::FungibleResourcesCollectionItemGloballyAggregated {
            Default::default()
        }
    }
    ///FungibleResourcesCollectionItemGloballyAggregatedAggregationLevel
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "Global"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum FungibleResourcesCollectionItemGloballyAggregatedAggregationLevel {
        Global,
    }
    impl From<&FungibleResourcesCollectionItemGloballyAggregatedAggregationLevel>
    for FungibleResourcesCollectionItemGloballyAggregatedAggregationLevel {
        fn from(
            value: &FungibleResourcesCollectionItemGloballyAggregatedAggregationLevel,
        ) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display
    for FungibleResourcesCollectionItemGloballyAggregatedAggregationLevel {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Global => write!(f, "Global"),
            }
        }
    }
    impl std::str::FromStr
    for FungibleResourcesCollectionItemGloballyAggregatedAggregationLevel {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "Global" => Ok(Self::Global),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str>
    for FungibleResourcesCollectionItemGloballyAggregatedAggregationLevel {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String>
    for FungibleResourcesCollectionItemGloballyAggregatedAggregationLevel {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String>
    for FungibleResourcesCollectionItemGloballyAggregatedAggregationLevel {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///FungibleResourcesCollectionItemVaultAggregated
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/FungibleResourcesCollectionItemBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "vaults"
    ///      ],
    ///      "properties": {
    ///        "aggregation_level": {
    ///          "type": "string",
    ///          "enum": [
    ///            "Vault"
    ///          ]
    ///        },
    ///        "vaults": {
    ///          "$ref": "#/components/schemas/FungibleResourcesCollectionItemVaultAggregatedVault"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct FungibleResourcesCollectionItemVaultAggregated {
        pub aggregation_level: FungibleResourcesCollectionItemVaultAggregatedAggregationLevel,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub explicit_metadata: Option<EntityMetadataCollection>,
        pub resource_address: Address,
        pub vaults: FungibleResourcesCollectionItemVaultAggregatedVault,
    }
    impl From<&FungibleResourcesCollectionItemVaultAggregated>
    for FungibleResourcesCollectionItemVaultAggregated {
        fn from(value: &FungibleResourcesCollectionItemVaultAggregated) -> Self {
            value.clone()
        }
    }
    impl FungibleResourcesCollectionItemVaultAggregated {
        pub fn builder() -> builder::FungibleResourcesCollectionItemVaultAggregated {
            Default::default()
        }
    }
    ///FungibleResourcesCollectionItemVaultAggregatedAggregationLevel
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "Vault"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum FungibleResourcesCollectionItemVaultAggregatedAggregationLevel {
        Vault,
    }
    impl From<&FungibleResourcesCollectionItemVaultAggregatedAggregationLevel>
    for FungibleResourcesCollectionItemVaultAggregatedAggregationLevel {
        fn from(
            value: &FungibleResourcesCollectionItemVaultAggregatedAggregationLevel,
        ) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display
    for FungibleResourcesCollectionItemVaultAggregatedAggregationLevel {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Vault => write!(f, "Vault"),
            }
        }
    }
    impl std::str::FromStr
    for FungibleResourcesCollectionItemVaultAggregatedAggregationLevel {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "Vault" => Ok(Self::Vault),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str>
    for FungibleResourcesCollectionItemVaultAggregatedAggregationLevel {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String>
    for FungibleResourcesCollectionItemVaultAggregatedAggregationLevel {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String>
    for FungibleResourcesCollectionItemVaultAggregatedAggregationLevel {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///FungibleResourcesCollectionItemVaultAggregatedVault
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ResultSetCursorMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "items"
    ///      ],
    ///      "properties": {
    ///        "items": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/FungibleResourcesCollectionItemVaultAggregatedVaultItem"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct FungibleResourcesCollectionItemVaultAggregatedVault {
        pub items: Vec<FungibleResourcesCollectionItemVaultAggregatedVaultItem>,
        ///If specified, contains a cursor to query next page of the `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_cursor: Option<String>,
        ///Total number of items in underlying collection, fragment of which is available in `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_count: Option<i64>,
    }
    impl From<&FungibleResourcesCollectionItemVaultAggregatedVault>
    for FungibleResourcesCollectionItemVaultAggregatedVault {
        fn from(value: &FungibleResourcesCollectionItemVaultAggregatedVault) -> Self {
            value.clone()
        }
    }
    impl FungibleResourcesCollectionItemVaultAggregatedVault {
        pub fn builder() -> builder::FungibleResourcesCollectionItemVaultAggregatedVault {
            Default::default()
        }
    }
    ///FungibleResourcesCollectionItemVaultAggregatedVaultItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "last_updated_at_state_version",
    ///    "vault_address"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "$ref": "#/components/schemas/BigDecimal"
    ///    },
    ///    "last_updated_at_state_version": {
    ///      "$ref": "#/components/schemas/LastUpdatedAtStateVersion"
    ///    },
    ///    "vault_address": {
    ///      "$ref": "#/components/schemas/Address"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct FungibleResourcesCollectionItemVaultAggregatedVaultItem {
        pub amount: BigDecimal,
        pub last_updated_at_state_version: LastUpdatedAtStateVersion,
        pub vault_address: Address,
    }
    impl From<&FungibleResourcesCollectionItemVaultAggregatedVaultItem>
    for FungibleResourcesCollectionItemVaultAggregatedVaultItem {
        fn from(
            value: &FungibleResourcesCollectionItemVaultAggregatedVaultItem,
        ) -> Self {
            value.clone()
        }
    }
    impl FungibleResourcesCollectionItemVaultAggregatedVaultItem {
        pub fn builder() -> builder::FungibleResourcesCollectionItemVaultAggregatedVaultItem {
            Default::default()
        }
    }
    ///GatewayError
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/AccountLockerNotFoundError"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/EntityNotFoundError"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/InvalidEntityError"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/NotSyncedUpError"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/InvalidRequestError"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/InvalidTransactionError"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/TransactionNotFoundError"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/InternalServerError"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum GatewayError {
        AccountLockerNotFoundError(AccountLockerNotFoundError),
        EntityNotFoundError(EntityNotFoundError),
        InvalidEntityError(InvalidEntityError),
        NotSyncedUpError(NotSyncedUpError),
        InvalidRequestError(InvalidRequestError),
        InvalidTransactionError(InvalidTransactionError),
        TransactionNotFoundError(TransactionNotFoundError),
        InternalServerError(InternalServerError),
    }
    impl From<&GatewayError> for GatewayError {
        fn from(value: &GatewayError) -> Self {
            value.clone()
        }
    }
    impl From<AccountLockerNotFoundError> for GatewayError {
        fn from(value: AccountLockerNotFoundError) -> Self {
            Self::AccountLockerNotFoundError(value)
        }
    }
    impl From<EntityNotFoundError> for GatewayError {
        fn from(value: EntityNotFoundError) -> Self {
            Self::EntityNotFoundError(value)
        }
    }
    impl From<InvalidEntityError> for GatewayError {
        fn from(value: InvalidEntityError) -> Self {
            Self::InvalidEntityError(value)
        }
    }
    impl From<NotSyncedUpError> for GatewayError {
        fn from(value: NotSyncedUpError) -> Self {
            Self::NotSyncedUpError(value)
        }
    }
    impl From<InvalidRequestError> for GatewayError {
        fn from(value: InvalidRequestError) -> Self {
            Self::InvalidRequestError(value)
        }
    }
    impl From<InvalidTransactionError> for GatewayError {
        fn from(value: InvalidTransactionError) -> Self {
            Self::InvalidTransactionError(value)
        }
    }
    impl From<TransactionNotFoundError> for GatewayError {
        fn from(value: TransactionNotFoundError) -> Self {
            Self::TransactionNotFoundError(value)
        }
    }
    impl From<InternalServerError> for GatewayError {
        fn from(value: InternalServerError) -> Self {
            Self::InternalServerError(value)
        }
    }
    ///GatewayErrorBase
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "type": {
    ///      "description": "The type of error. Each subtype may have its own additional structured fields.",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct GatewayErrorBase {
        ///The type of error. Each subtype may have its own additional structured fields.
        #[serde(rename = "type")]
        pub type_: String,
    }
    impl From<&GatewayErrorBase> for GatewayErrorBase {
        fn from(value: &GatewayErrorBase) -> Self {
            value.clone()
        }
    }
    impl GatewayErrorBase {
        pub fn builder() -> builder::GatewayErrorBase {
            Default::default()
        }
    }
    ///GatewayInfoResponseKnownTarget
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "state_version"
    ///  ],
    ///  "properties": {
    ///    "state_version": {
    ///      "description": "The latest-seen state version of the tip of the network's ledger. If this is significantly ahead of the current ledger state version, the Network Gateway is possibly behind and may be reporting outdated information.\n",
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct GatewayInfoResponseKnownTarget {
        /**The latest-seen state version of the tip of the network's ledger. If this is significantly ahead of the current ledger state version, the Network Gateway is possibly behind and may be reporting outdated information.
*/
        pub state_version: i64,
    }
    impl From<&GatewayInfoResponseKnownTarget> for GatewayInfoResponseKnownTarget {
        fn from(value: &GatewayInfoResponseKnownTarget) -> Self {
            value.clone()
        }
    }
    impl GatewayInfoResponseKnownTarget {
        pub fn builder() -> builder::GatewayInfoResponseKnownTarget {
            Default::default()
        }
    }
    ///GatewayInfoResponseReleaseInfo
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "image_tag",
    ///    "open_api_schema_version",
    ///    "release_version"
    ///  ],
    ///  "properties": {
    ///    "image_tag": {
    ///      "description": "Image tag that is currently deployed to the Gateway API.",
    ///      "type": "string"
    ///    },
    ///    "open_api_schema_version": {
    ///      "description": "The Open API Schema version that was used to generate the API models.",
    ///      "type": "string"
    ///    },
    ///    "release_version": {
    ///      "description": "The release that is currently deployed to the Gateway API.",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct GatewayInfoResponseReleaseInfo {
        ///Image tag that is currently deployed to the Gateway API.
        pub image_tag: String,
        ///The Open API Schema version that was used to generate the API models.
        pub open_api_schema_version: String,
        ///The release that is currently deployed to the Gateway API.
        pub release_version: String,
    }
    impl From<&GatewayInfoResponseReleaseInfo> for GatewayInfoResponseReleaseInfo {
        fn from(value: &GatewayInfoResponseReleaseInfo) -> Self {
            value.clone()
        }
    }
    impl GatewayInfoResponseReleaseInfo {
        pub fn builder() -> builder::GatewayInfoResponseReleaseInfo {
            Default::default()
        }
    }
    ///GatewayStatusResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/LedgerStateMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "release_info"
    ///      ],
    ///      "properties": {
    ///        "release_info": {
    ///          "$ref": "#/components/schemas/GatewayInfoResponseReleaseInfo"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct GatewayStatusResponse {
        pub ledger_state: LedgerState,
        pub release_info: GatewayInfoResponseReleaseInfo,
    }
    impl From<&GatewayStatusResponse> for GatewayStatusResponse {
        fn from(value: &GatewayStatusResponse) -> Self {
            value.clone()
        }
    }
    impl GatewayStatusResponse {
        pub fn builder() -> builder::GatewayStatusResponse {
            Default::default()
        }
    }
    ///Bech32m-encoded hash.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Bech32m-encoded hash.",
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub struct HashBech32mString(pub String);
    impl ::std::ops::Deref for HashBech32mString {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<HashBech32mString> for String {
        fn from(value: HashBech32mString) -> Self {
            value.0
        }
    }
    impl From<&HashBech32mString> for HashBech32mString {
        fn from(value: &HashBech32mString) -> Self {
            value.clone()
        }
    }
    impl From<String> for HashBech32mString {
        fn from(value: String) -> Self {
            Self(value)
        }
    }
    impl std::str::FromStr for HashBech32mString {
        type Err = std::convert::Infallible;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::fmt::Display for HashBech32mString {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }
    ///Hex-encoded SHA-256 hash.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Hex-encoded SHA-256 hash.",
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub struct HashHexString(pub String);
    impl ::std::ops::Deref for HashHexString {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<HashHexString> for String {
        fn from(value: HashHexString) -> Self {
            value.0
        }
    }
    impl From<&HashHexString> for HashHexString {
        fn from(value: &HashHexString) -> Self {
            value.clone()
        }
    }
    impl From<String> for HashHexString {
        fn from(value: String) -> Self {
            Self(value)
        }
    }
    impl std::str::FromStr for HashHexString {
        type Err = std::convert::Infallible;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::fmt::Display for HashHexString {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }
    ///Hex-encoded binary blob.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Hex-encoded binary blob.",
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub struct HexString(pub String);
    impl ::std::ops::Deref for HexString {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<HexString> for String {
        fn from(value: HexString) -> Self {
            value.0
        }
    }
    impl From<&HexString> for HexString {
        fn from(value: &HexString) -> Self {
            value.clone()
        }
    }
    impl From<String> for HexString {
        fn from(value: String) -> Self {
            Self(value)
        }
    }
    impl std::str::FromStr for HexString {
        type Err = std::convert::Infallible;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::fmt::Display for HexString {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }
    ///InternalServerError
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/GatewayErrorBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "cause",
    ///        "exception"
    ///      ],
    ///      "properties": {
    ///        "cause": {
    ///          "description": "Gives a human readable message - likely just a trace ID for reporting the error.",
    ///          "type": "string"
    ///        },
    ///        "exception": {
    ///          "description": "Gives an error type which occurred within the Gateway API when serving the request.",
    ///          "type": "string"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "InternalServerError"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct InternalServerError {
        ///Gives a human readable message - likely just a trace ID for reporting the error.
        pub cause: String,
        ///Gives an error type which occurred within the Gateway API when serving the request.
        pub exception: String,
        #[serde(rename = "type")]
        pub type_: InternalServerErrorType,
    }
    impl From<&InternalServerError> for InternalServerError {
        fn from(value: &InternalServerError) -> Self {
            value.clone()
        }
    }
    impl InternalServerError {
        pub fn builder() -> builder::InternalServerError {
            Default::default()
        }
    }
    ///InternalServerErrorType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "InternalServerError"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum InternalServerErrorType {
        InternalServerError,
    }
    impl From<&InternalServerErrorType> for InternalServerErrorType {
        fn from(value: &InternalServerErrorType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for InternalServerErrorType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::InternalServerError => write!(f, "InternalServerError"),
            }
        }
    }
    impl std::str::FromStr for InternalServerErrorType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "InternalServerError" => Ok(Self::InternalServerError),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for InternalServerErrorType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for InternalServerErrorType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for InternalServerErrorType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///InvalidEntityError
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/GatewayErrorBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "address"
    ///      ],
    ///      "properties": {
    ///        "address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "InvalidEntityError"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct InvalidEntityError {
        pub address: Address,
        #[serde(rename = "type")]
        pub type_: InvalidEntityErrorType,
    }
    impl From<&InvalidEntityError> for InvalidEntityError {
        fn from(value: &InvalidEntityError) -> Self {
            value.clone()
        }
    }
    impl InvalidEntityError {
        pub fn builder() -> builder::InvalidEntityError {
            Default::default()
        }
    }
    ///InvalidEntityErrorType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "InvalidEntityError"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum InvalidEntityErrorType {
        InvalidEntityError,
    }
    impl From<&InvalidEntityErrorType> for InvalidEntityErrorType {
        fn from(value: &InvalidEntityErrorType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for InvalidEntityErrorType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::InvalidEntityError => write!(f, "InvalidEntityError"),
            }
        }
    }
    impl std::str::FromStr for InvalidEntityErrorType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "InvalidEntityError" => Ok(Self::InvalidEntityError),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for InvalidEntityErrorType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for InvalidEntityErrorType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for InvalidEntityErrorType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///InvalidRequestError
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/GatewayErrorBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "validation_errors"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "InvalidRequestError"
    ///          ]
    ///        },
    ///        "validation_errors": {
    ///          "description": "One or more validation errors which occurred when validating the request.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/ValidationErrorsAtPath"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct InvalidRequestError {
        #[serde(rename = "type")]
        pub type_: InvalidRequestErrorType,
        ///One or more validation errors which occurred when validating the request.
        pub validation_errors: Vec<ValidationErrorsAtPath>,
    }
    impl From<&InvalidRequestError> for InvalidRequestError {
        fn from(value: &InvalidRequestError) -> Self {
            value.clone()
        }
    }
    impl InvalidRequestError {
        pub fn builder() -> builder::InvalidRequestError {
            Default::default()
        }
    }
    ///InvalidRequestErrorType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "InvalidRequestError"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum InvalidRequestErrorType {
        InvalidRequestError,
    }
    impl From<&InvalidRequestErrorType> for InvalidRequestErrorType {
        fn from(value: &InvalidRequestErrorType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for InvalidRequestErrorType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::InvalidRequestError => write!(f, "InvalidRequestError"),
            }
        }
    }
    impl std::str::FromStr for InvalidRequestErrorType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "InvalidRequestError" => Ok(Self::InvalidRequestError),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for InvalidRequestErrorType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for InvalidRequestErrorType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for InvalidRequestErrorType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///InvalidTransactionError
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/GatewayErrorBase"
    ///    },
    ///    {
    ///      "type": "object"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "InvalidTransactionError"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct InvalidTransactionError {
        #[serde(rename = "type")]
        pub type_: InvalidTransactionErrorType,
    }
    impl From<&InvalidTransactionError> for InvalidTransactionError {
        fn from(value: &InvalidTransactionError) -> Self {
            value.clone()
        }
    }
    impl InvalidTransactionError {
        pub fn builder() -> builder::InvalidTransactionError {
            Default::default()
        }
    }
    ///InvalidTransactionErrorType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "InvalidTransactionError"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum InvalidTransactionErrorType {
        InvalidTransactionError,
    }
    impl From<&InvalidTransactionErrorType> for InvalidTransactionErrorType {
        fn from(value: &InvalidTransactionErrorType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for InvalidTransactionErrorType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::InvalidTransactionError => write!(f, "InvalidTransactionError"),
            }
        }
    }
    impl std::str::FromStr for InvalidTransactionErrorType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "InvalidTransactionError" => Ok(Self::InvalidTransactionError),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for InvalidTransactionErrorType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for InvalidTransactionErrorType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for InvalidTransactionErrorType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The most recent state version underlying object was modified at.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The most recent state version underlying object was modified at.",
    ///  "type": "integer",
    ///  "format": "int64",
    ///  "maximum": 100000000000000.0,
    ///  "minimum": 1.0
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct LastUpdatedAtStateVersion(pub i64);
    impl ::std::ops::Deref for LastUpdatedAtStateVersion {
        type Target = i64;
        fn deref(&self) -> &i64 {
            &self.0
        }
    }
    impl From<LastUpdatedAtStateVersion> for i64 {
        fn from(value: LastUpdatedAtStateVersion) -> Self {
            value.0
        }
    }
    impl From<&LastUpdatedAtStateVersion> for LastUpdatedAtStateVersion {
        fn from(value: &LastUpdatedAtStateVersion) -> Self {
            value.clone()
        }
    }
    impl From<i64> for LastUpdatedAtStateVersion {
        fn from(value: i64) -> Self {
            Self(value)
        }
    }
    impl std::str::FromStr for LastUpdatedAtStateVersion {
        type Err = <i64 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }
    impl std::convert::TryFrom<&str> for LastUpdatedAtStateVersion {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for LastUpdatedAtStateVersion {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for LastUpdatedAtStateVersion {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }
    impl ::std::fmt::Display for LastUpdatedAtStateVersion {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }
    /**The ledger state against which the response was generated.
Can be used to detect if the Network Gateway is returning up-to-date information.
*/
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The ledger state against which the response was generated.\nCan be used to detect if the Network Gateway is returning up-to-date information.\n",
    ///  "type": "object",
    ///  "required": [
    ///    "epoch",
    ///    "network",
    ///    "proposer_round_timestamp",
    ///    "round",
    ///    "state_version"
    ///  ],
    ///  "properties": {
    ///    "epoch": {
    ///      "description": "The epoch number of the ledger at this state version.",
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "network": {
    ///      "$ref": "#/components/schemas/NetworkName"
    ///    },
    ///    "proposer_round_timestamp": {
    ///      "description": "The proposer round timestamp of the consensus round when this transaction was committed to ledger.\nThis is not guaranteed to be strictly increasing, as it is computed as an average across the validator set.\nIf this is significantly behind the current timestamp, the Network Gateway is likely reporting out-dated\ninformation, or the network has stalled.\n",
    ///      "type": "string"
    ///    },
    ///    "round": {
    ///      "description": "The consensus round in the epoch that this state version was committed in.",
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "state_version": {
    ///      "description": "The state version of the ledger. Each transaction increments the state version by 1.",
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct LedgerState {
        ///The epoch number of the ledger at this state version.
        pub epoch: i64,
        pub network: NetworkName,
        /**The proposer round timestamp of the consensus round when this transaction was committed to ledger.
This is not guaranteed to be strictly increasing, as it is computed as an average across the validator set.
If this is significantly behind the current timestamp, the Network Gateway is likely reporting out-dated
information, or the network has stalled.
*/
        pub proposer_round_timestamp: String,
        ///The consensus round in the epoch that this state version was committed in.
        pub round: i64,
        ///The state version of the ledger. Each transaction increments the state version by 1.
        pub state_version: i64,
    }
    impl From<&LedgerState> for LedgerState {
        fn from(value: &LedgerState) -> Self {
            value.clone()
        }
    }
    impl LedgerState {
        pub fn builder() -> builder::LedgerState {
            Default::default()
        }
    }
    ///LedgerStateMixin
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "ledger_state"
    ///  ],
    ///  "properties": {
    ///    "ledger_state": {
    ///      "$ref": "#/components/schemas/LedgerState"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct LedgerStateMixin {
        pub ledger_state: LedgerState,
    }
    impl From<&LedgerStateMixin> for LedgerStateMixin {
        fn from(value: &LedgerStateMixin) -> Self {
            value.clone()
        }
    }
    impl LedgerStateMixin {
        pub fn builder() -> builder::LedgerStateMixin {
            Default::default()
        }
    }
    /**Optional. This allows for a request to be made against a historic state.
If a constraint is specified, the Gateway will resolve the request against the ledger state at that time.
If not specified, requests will be made with respect to the top of the committed ledger.
*/
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Optional. This allows for a request to be made against a historic state.\nIf a constraint is specified, the Gateway will resolve the request against the ledger state at that time.\nIf not specified, requests will be made with respect to the top of the committed ledger.\n",
    ///  "type": [
    ///    "object",
    ///    "null"
    ///  ],
    ///  "properties": {
    ///    "epoch": {
    ///      "description": "If provided, the ledger state lower than or equal to the given epoch at round 0 is returned.",
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ],
    ///      "format": "int64",
    ///      "maximum": 10000000000.0,
    ///      "minimum": 0.0
    ///    },
    ///    "round": {
    ///      "description": "If provided must be accompanied with `epoch`, the ledger state lower than or equal to the given epoch and round is returned.",
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ],
    ///      "format": "int64",
    ///      "maximum": 10000000000.0,
    ///      "minimum": 0.0
    ///    },
    ///    "state_version": {
    ///      "description": "If provided, the latest ledger state lower than or equal to the given state version is returned.",
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ],
    ///      "format": "int64",
    ///      "maximum": 100000000000000.0,
    ///      "minimum": 1.0
    ///    },
    ///    "timestamp": {
    ///      "description": "If provided, the latest ledger state lower than or equal to the given round timestamp is returned.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct LedgerStateSelector(pub Option<LedgerStateSelectorInner>);
    impl ::std::ops::Deref for LedgerStateSelector {
        type Target = Option<LedgerStateSelectorInner>;
        fn deref(&self) -> &Option<LedgerStateSelectorInner> {
            &self.0
        }
    }
    impl From<LedgerStateSelector> for Option<LedgerStateSelectorInner> {
        fn from(value: LedgerStateSelector) -> Self {
            value.0
        }
    }
    impl From<&LedgerStateSelector> for LedgerStateSelector {
        fn from(value: &LedgerStateSelector) -> Self {
            value.clone()
        }
    }
    impl From<Option<LedgerStateSelectorInner>> for LedgerStateSelector {
        fn from(value: Option<LedgerStateSelectorInner>) -> Self {
            Self(value)
        }
    }
    /**Optional. This allows for a request to be made against a historic state.
If a constraint is specified, the Gateway will resolve the request against the ledger state at that time.
If not specified, requests will be made with respect to the top of the committed ledger.
*/
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Optional. This allows for a request to be made against a historic state.\nIf a constraint is specified, the Gateway will resolve the request against the ledger state at that time.\nIf not specified, requests will be made with respect to the top of the committed ledger.\n",
    ///  "type": "object",
    ///  "properties": {
    ///    "epoch": {
    ///      "description": "If provided, the ledger state lower than or equal to the given epoch at round 0 is returned.",
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ],
    ///      "format": "int64",
    ///      "maximum": 10000000000.0,
    ///      "minimum": 0.0
    ///    },
    ///    "round": {
    ///      "description": "If provided must be accompanied with `epoch`, the ledger state lower than or equal to the given epoch and round is returned.",
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ],
    ///      "format": "int64",
    ///      "maximum": 10000000000.0,
    ///      "minimum": 0.0
    ///    },
    ///    "state_version": {
    ///      "description": "If provided, the latest ledger state lower than or equal to the given state version is returned.",
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ],
    ///      "format": "int64",
    ///      "maximum": 100000000000000.0,
    ///      "minimum": 1.0
    ///    },
    ///    "timestamp": {
    ///      "description": "If provided, the latest ledger state lower than or equal to the given round timestamp is returned.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct LedgerStateSelectorInner {
        ///If provided, the ledger state lower than or equal to the given epoch at round 0 is returned.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub epoch: Option<i64>,
        ///If provided must be accompanied with `epoch`, the ledger state lower than or equal to the given epoch and round is returned.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub round: Option<i64>,
        ///If provided, the latest ledger state lower than or equal to the given state version is returned.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub state_version: Option<i64>,
        ///If provided, the latest ledger state lower than or equal to the given round timestamp is returned.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub timestamp: Option<chrono::DateTime<chrono::offset::Utc>>,
    }
    impl From<&LedgerStateSelectorInner> for LedgerStateSelectorInner {
        fn from(value: &LedgerStateSelectorInner) -> Self {
            value.clone()
        }
    }
    impl LedgerStateSelectorInner {
        pub fn builder() -> builder::LedgerStateSelectorInner {
            Default::default()
        }
    }
    /**High-level manifest class type:
  * `General`: A general manifest that involves any amount of arbitrary components and packages where nothing more concrete can be said about the manifest and its nature.
  * `Transfer`: A manifest of a 1-to-1 transfer to a one-to-many transfer of resources.
  * `PoolContribution`: A manifest that contributed some amount of resources to a liquidity pool that can be a one-resource pool, two-resource pool, or a multi-resource pool.
  * `PoolRedemption`: A manifest that redeemed resources from a liquidity pool. Similar to contributions, this can be any of the three pool blueprints available in the pool package.
  * `ValidatorStake`: A manifest where XRD is staked to one or more validators.
  * `ValidatorUnstake`: A manifest where XRD is unstaked from one or more validators.
  * `ValidatorClaim`: A manifest where XRD is claimed from one or more validators.
  * `AccountDepositSettingsUpdate`: A manifest that updated the deposit settings of the account.
*/
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "High-level manifest class type:\n  * `General`: A general manifest that involves any amount of arbitrary components and packages where nothing more concrete can be said about the manifest and its nature.\n  * `Transfer`: A manifest of a 1-to-1 transfer to a one-to-many transfer of resources.\n  * `PoolContribution`: A manifest that contributed some amount of resources to a liquidity pool that can be a one-resource pool, two-resource pool, or a multi-resource pool.\n  * `PoolRedemption`: A manifest that redeemed resources from a liquidity pool. Similar to contributions, this can be any of the three pool blueprints available in the pool package.\n  * `ValidatorStake`: A manifest where XRD is staked to one or more validators.\n  * `ValidatorUnstake`: A manifest where XRD is unstaked from one or more validators.\n  * `ValidatorClaim`: A manifest where XRD is claimed from one or more validators.\n  * `AccountDepositSettingsUpdate`: A manifest that updated the deposit settings of the account.\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "General",
    ///    "Transfer",
    ///    "PoolContribution",
    ///    "PoolRedemption",
    ///    "ValidatorStake",
    ///    "ValidatorUnstake",
    ///    "ValidatorClaim",
    ///    "AccountDepositSettingsUpdate"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum ManifestClass {
        General,
        Transfer,
        PoolContribution,
        PoolRedemption,
        ValidatorStake,
        ValidatorUnstake,
        ValidatorClaim,
        AccountDepositSettingsUpdate,
    }
    impl From<&ManifestClass> for ManifestClass {
        fn from(value: &ManifestClass) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for ManifestClass {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::General => write!(f, "General"),
                Self::Transfer => write!(f, "Transfer"),
                Self::PoolContribution => write!(f, "PoolContribution"),
                Self::PoolRedemption => write!(f, "PoolRedemption"),
                Self::ValidatorStake => write!(f, "ValidatorStake"),
                Self::ValidatorUnstake => write!(f, "ValidatorUnstake"),
                Self::ValidatorClaim => write!(f, "ValidatorClaim"),
                Self::AccountDepositSettingsUpdate => {
                    write!(f, "AccountDepositSettingsUpdate")
                }
            }
        }
    }
    impl std::str::FromStr for ManifestClass {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "General" => Ok(Self::General),
                "Transfer" => Ok(Self::Transfer),
                "PoolContribution" => Ok(Self::PoolContribution),
                "PoolRedemption" => Ok(Self::PoolRedemption),
                "ValidatorStake" => Ok(Self::ValidatorStake),
                "ValidatorUnstake" => Ok(Self::ValidatorUnstake),
                "ValidatorClaim" => Ok(Self::ValidatorClaim),
                "AccountDepositSettingsUpdate" => Ok(Self::AccountDepositSettingsUpdate),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for ManifestClass {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for ManifestClass {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for ManifestClass {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MetadataBoolArrayValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/MetadataTypedValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "values"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "BoolArray"
    ///          ]
    ///        },
    ///        "values": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": "boolean"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct MetadataBoolArrayValue {
        #[serde(rename = "type")]
        pub type_: MetadataBoolArrayValueType,
        pub values: Vec<bool>,
    }
    impl From<&MetadataBoolArrayValue> for MetadataBoolArrayValue {
        fn from(value: &MetadataBoolArrayValue) -> Self {
            value.clone()
        }
    }
    impl MetadataBoolArrayValue {
        pub fn builder() -> builder::MetadataBoolArrayValue {
            Default::default()
        }
    }
    ///MetadataBoolArrayValueType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "BoolArray"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum MetadataBoolArrayValueType {
        BoolArray,
    }
    impl From<&MetadataBoolArrayValueType> for MetadataBoolArrayValueType {
        fn from(value: &MetadataBoolArrayValueType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for MetadataBoolArrayValueType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::BoolArray => write!(f, "BoolArray"),
            }
        }
    }
    impl std::str::FromStr for MetadataBoolArrayValueType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "BoolArray" => Ok(Self::BoolArray),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MetadataBoolArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MetadataBoolArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MetadataBoolArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MetadataBoolValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/MetadataTypedValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "Bool"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "boolean"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct MetadataBoolValue {
        #[serde(rename = "type")]
        pub type_: MetadataBoolValueType,
        pub value: bool,
    }
    impl From<&MetadataBoolValue> for MetadataBoolValue {
        fn from(value: &MetadataBoolValue) -> Self {
            value.clone()
        }
    }
    impl MetadataBoolValue {
        pub fn builder() -> builder::MetadataBoolValue {
            Default::default()
        }
    }
    ///MetadataBoolValueType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "Bool"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum MetadataBoolValueType {
        Bool,
    }
    impl From<&MetadataBoolValueType> for MetadataBoolValueType {
        fn from(value: &MetadataBoolValueType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for MetadataBoolValueType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Bool => write!(f, "Bool"),
            }
        }
    }
    impl std::str::FromStr for MetadataBoolValueType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "Bool" => Ok(Self::Bool),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MetadataBoolValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MetadataBoolValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MetadataBoolValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MetadataDecimalArrayValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/MetadataTypedValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "values"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "DecimalArray"
    ///          ]
    ///        },
    ///        "values": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct MetadataDecimalArrayValue {
        #[serde(rename = "type")]
        pub type_: MetadataDecimalArrayValueType,
        pub values: Vec<String>,
    }
    impl From<&MetadataDecimalArrayValue> for MetadataDecimalArrayValue {
        fn from(value: &MetadataDecimalArrayValue) -> Self {
            value.clone()
        }
    }
    impl MetadataDecimalArrayValue {
        pub fn builder() -> builder::MetadataDecimalArrayValue {
            Default::default()
        }
    }
    ///MetadataDecimalArrayValueType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "DecimalArray"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum MetadataDecimalArrayValueType {
        DecimalArray,
    }
    impl From<&MetadataDecimalArrayValueType> for MetadataDecimalArrayValueType {
        fn from(value: &MetadataDecimalArrayValueType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for MetadataDecimalArrayValueType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::DecimalArray => write!(f, "DecimalArray"),
            }
        }
    }
    impl std::str::FromStr for MetadataDecimalArrayValueType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "DecimalArray" => Ok(Self::DecimalArray),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MetadataDecimalArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MetadataDecimalArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MetadataDecimalArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MetadataDecimalValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/MetadataTypedValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "Decimal"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct MetadataDecimalValue {
        #[serde(rename = "type")]
        pub type_: MetadataDecimalValueType,
        pub value: String,
    }
    impl From<&MetadataDecimalValue> for MetadataDecimalValue {
        fn from(value: &MetadataDecimalValue) -> Self {
            value.clone()
        }
    }
    impl MetadataDecimalValue {
        pub fn builder() -> builder::MetadataDecimalValue {
            Default::default()
        }
    }
    ///MetadataDecimalValueType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "Decimal"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum MetadataDecimalValueType {
        Decimal,
    }
    impl From<&MetadataDecimalValueType> for MetadataDecimalValueType {
        fn from(value: &MetadataDecimalValueType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for MetadataDecimalValueType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Decimal => write!(f, "Decimal"),
            }
        }
    }
    impl std::str::FromStr for MetadataDecimalValueType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "Decimal" => Ok(Self::Decimal),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MetadataDecimalValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MetadataDecimalValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MetadataDecimalValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MetadataGlobalAddressArrayValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/MetadataTypedValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "values"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "GlobalAddressArray"
    ///          ]
    ///        },
    ///        "values": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct MetadataGlobalAddressArrayValue {
        #[serde(rename = "type")]
        pub type_: MetadataGlobalAddressArrayValueType,
        pub values: Vec<String>,
    }
    impl From<&MetadataGlobalAddressArrayValue> for MetadataGlobalAddressArrayValue {
        fn from(value: &MetadataGlobalAddressArrayValue) -> Self {
            value.clone()
        }
    }
    impl MetadataGlobalAddressArrayValue {
        pub fn builder() -> builder::MetadataGlobalAddressArrayValue {
            Default::default()
        }
    }
    ///MetadataGlobalAddressArrayValueType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "GlobalAddressArray"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum MetadataGlobalAddressArrayValueType {
        GlobalAddressArray,
    }
    impl From<&MetadataGlobalAddressArrayValueType>
    for MetadataGlobalAddressArrayValueType {
        fn from(value: &MetadataGlobalAddressArrayValueType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for MetadataGlobalAddressArrayValueType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GlobalAddressArray => write!(f, "GlobalAddressArray"),
            }
        }
    }
    impl std::str::FromStr for MetadataGlobalAddressArrayValueType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "GlobalAddressArray" => Ok(Self::GlobalAddressArray),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MetadataGlobalAddressArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MetadataGlobalAddressArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MetadataGlobalAddressArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MetadataGlobalAddressValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/MetadataTypedValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "GlobalAddress"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct MetadataGlobalAddressValue {
        #[serde(rename = "type")]
        pub type_: MetadataGlobalAddressValueType,
        pub value: String,
    }
    impl From<&MetadataGlobalAddressValue> for MetadataGlobalAddressValue {
        fn from(value: &MetadataGlobalAddressValue) -> Self {
            value.clone()
        }
    }
    impl MetadataGlobalAddressValue {
        pub fn builder() -> builder::MetadataGlobalAddressValue {
            Default::default()
        }
    }
    ///MetadataGlobalAddressValueType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "GlobalAddress"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum MetadataGlobalAddressValueType {
        GlobalAddress,
    }
    impl From<&MetadataGlobalAddressValueType> for MetadataGlobalAddressValueType {
        fn from(value: &MetadataGlobalAddressValueType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for MetadataGlobalAddressValueType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GlobalAddress => write!(f, "GlobalAddress"),
            }
        }
    }
    impl std::str::FromStr for MetadataGlobalAddressValueType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "GlobalAddress" => Ok(Self::GlobalAddress),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MetadataGlobalAddressValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MetadataGlobalAddressValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MetadataGlobalAddressValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MetadataI32ArrayValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/MetadataTypedValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "values"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "I32Array"
    ///          ]
    ///        },
    ///        "values": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct MetadataI32ArrayValue {
        #[serde(rename = "type")]
        pub type_: MetadataI32ArrayValueType,
        pub values: Vec<String>,
    }
    impl From<&MetadataI32ArrayValue> for MetadataI32ArrayValue {
        fn from(value: &MetadataI32ArrayValue) -> Self {
            value.clone()
        }
    }
    impl MetadataI32ArrayValue {
        pub fn builder() -> builder::MetadataI32ArrayValue {
            Default::default()
        }
    }
    ///MetadataI32ArrayValueType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "I32Array"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum MetadataI32ArrayValueType {
        I32Array,
    }
    impl From<&MetadataI32ArrayValueType> for MetadataI32ArrayValueType {
        fn from(value: &MetadataI32ArrayValueType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for MetadataI32ArrayValueType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::I32Array => write!(f, "I32Array"),
            }
        }
    }
    impl std::str::FromStr for MetadataI32ArrayValueType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "I32Array" => Ok(Self::I32Array),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MetadataI32ArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MetadataI32ArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MetadataI32ArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MetadataI32Value
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/MetadataTypedValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "I32"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct MetadataI32Value {
        #[serde(rename = "type")]
        pub type_: MetadataI32ValueType,
        pub value: String,
    }
    impl From<&MetadataI32Value> for MetadataI32Value {
        fn from(value: &MetadataI32Value) -> Self {
            value.clone()
        }
    }
    impl MetadataI32Value {
        pub fn builder() -> builder::MetadataI32Value {
            Default::default()
        }
    }
    ///MetadataI32ValueType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "I32"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum MetadataI32ValueType {
        I32,
    }
    impl From<&MetadataI32ValueType> for MetadataI32ValueType {
        fn from(value: &MetadataI32ValueType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for MetadataI32ValueType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::I32 => write!(f, "I32"),
            }
        }
    }
    impl std::str::FromStr for MetadataI32ValueType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "I32" => Ok(Self::I32),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MetadataI32ValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MetadataI32ValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MetadataI32ValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MetadataI64ArrayValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/MetadataTypedValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "values"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "I64Array"
    ///          ]
    ///        },
    ///        "values": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct MetadataI64ArrayValue {
        #[serde(rename = "type")]
        pub type_: MetadataI64ArrayValueType,
        pub values: Vec<String>,
    }
    impl From<&MetadataI64ArrayValue> for MetadataI64ArrayValue {
        fn from(value: &MetadataI64ArrayValue) -> Self {
            value.clone()
        }
    }
    impl MetadataI64ArrayValue {
        pub fn builder() -> builder::MetadataI64ArrayValue {
            Default::default()
        }
    }
    ///MetadataI64ArrayValueType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "I64Array"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum MetadataI64ArrayValueType {
        I64Array,
    }
    impl From<&MetadataI64ArrayValueType> for MetadataI64ArrayValueType {
        fn from(value: &MetadataI64ArrayValueType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for MetadataI64ArrayValueType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::I64Array => write!(f, "I64Array"),
            }
        }
    }
    impl std::str::FromStr for MetadataI64ArrayValueType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "I64Array" => Ok(Self::I64Array),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MetadataI64ArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MetadataI64ArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MetadataI64ArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MetadataI64Value
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/MetadataTypedValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "I64"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct MetadataI64Value {
        #[serde(rename = "type")]
        pub type_: MetadataI64ValueType,
        pub value: String,
    }
    impl From<&MetadataI64Value> for MetadataI64Value {
        fn from(value: &MetadataI64Value) -> Self {
            value.clone()
        }
    }
    impl MetadataI64Value {
        pub fn builder() -> builder::MetadataI64Value {
            Default::default()
        }
    }
    ///MetadataI64ValueType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "I64"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum MetadataI64ValueType {
        I64,
    }
    impl From<&MetadataI64ValueType> for MetadataI64ValueType {
        fn from(value: &MetadataI64ValueType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for MetadataI64ValueType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::I64 => write!(f, "I64"),
            }
        }
    }
    impl std::str::FromStr for MetadataI64ValueType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "I64" => Ok(Self::I64),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MetadataI64ValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MetadataI64ValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MetadataI64ValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MetadataInstantArrayValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/MetadataTypedValueBase"
    ///    },
    ///    {
    ///      "description": "See documentation of `MetadataInstantValue` for detailed description of `values` vs `values_unix_timestamp_seconds`.\n",
    ///      "type": "object",
    ///      "required": [
    ///        "values",
    ///        "values_unix_timestamp_seconds"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "InstantArray"
    ///          ]
    ///        },
    ///        "values": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": "string"
    ///          }
    ///        },
    ///        "values_unix_timestamp_seconds": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct MetadataInstantArrayValue {
        #[serde(rename = "type")]
        pub type_: MetadataInstantArrayValueType,
        pub values: Vec<String>,
        pub values_unix_timestamp_seconds: Vec<String>,
    }
    impl From<&MetadataInstantArrayValue> for MetadataInstantArrayValue {
        fn from(value: &MetadataInstantArrayValue) -> Self {
            value.clone()
        }
    }
    impl MetadataInstantArrayValue {
        pub fn builder() -> builder::MetadataInstantArrayValue {
            Default::default()
        }
    }
    ///MetadataInstantArrayValueType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "InstantArray"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum MetadataInstantArrayValueType {
        InstantArray,
    }
    impl From<&MetadataInstantArrayValueType> for MetadataInstantArrayValueType {
        fn from(value: &MetadataInstantArrayValueType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for MetadataInstantArrayValueType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::InstantArray => write!(f, "InstantArray"),
            }
        }
    }
    impl std::str::FromStr for MetadataInstantArrayValueType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "InstantArray" => Ok(Self::InstantArray),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MetadataInstantArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MetadataInstantArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MetadataInstantArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MetadataInstantValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/MetadataTypedValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "unix_timestamp_seconds",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "Instant"
    ///          ]
    ///        },
    ///        "unix_timestamp_seconds": {
    ///          "description": "A decimal string-encoded 64-bit signed integer, marking the unix timestamp in seconds.\n\nNote: this field accurately represents the full range of possible on-ledger values (i.e. `-2^63 <= seconds < 2^63`).\n",
    ///          "type": "string"
    ///        },
    ///        "value": {
    ///          "description": "The RFC 3339 / ISO 8601 string representation of the timestamp. Will always use \"Z\" (denoting UTC) and omits milliseconds. E.g.: `2023-01-26T18:30:09Z`.\n\nNote: This field will return clamped value if the actual on-ledger `unix_timestamp_seconds` value is outside the basic range supported by the RFC 3339 / ISO 8601 standard,\nwhich starts at year 1583 (i.e. the beginning of the Gregorian calendar) and ends at year 9999 (inclusive).\n",
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct MetadataInstantValue {
        #[serde(rename = "type")]
        pub type_: MetadataInstantValueType,
        /**A decimal string-encoded 64-bit signed integer, marking the unix timestamp in seconds.

Note: this field accurately represents the full range of possible on-ledger values (i.e. `-2^63 <= seconds < 2^63`).
*/
        pub unix_timestamp_seconds: String,
        /**The RFC 3339 / ISO 8601 string representation of the timestamp. Will always use "Z" (denoting UTC) and omits milliseconds. E.g.: `2023-01-26T18:30:09Z`.

Note: This field will return clamped value if the actual on-ledger `unix_timestamp_seconds` value is outside the basic range supported by the RFC 3339 / ISO 8601 standard,
which starts at year 1583 (i.e. the beginning of the Gregorian calendar) and ends at year 9999 (inclusive).
*/
        pub value: String,
    }
    impl From<&MetadataInstantValue> for MetadataInstantValue {
        fn from(value: &MetadataInstantValue) -> Self {
            value.clone()
        }
    }
    impl MetadataInstantValue {
        pub fn builder() -> builder::MetadataInstantValue {
            Default::default()
        }
    }
    ///MetadataInstantValueType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "Instant"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum MetadataInstantValueType {
        Instant,
    }
    impl From<&MetadataInstantValueType> for MetadataInstantValueType {
        fn from(value: &MetadataInstantValueType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for MetadataInstantValueType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Instant => write!(f, "Instant"),
            }
        }
    }
    impl std::str::FromStr for MetadataInstantValueType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "Instant" => Ok(Self::Instant),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MetadataInstantValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MetadataInstantValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MetadataInstantValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MetadataNonFungibleGlobalIdArrayValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/MetadataTypedValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "values"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "NonFungibleGlobalIdArray"
    ///          ]
    ///        },
    ///        "values": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": "object",
    ///            "required": [
    ///              "non_fungible_id",
    ///              "resource_address"
    ///            ],
    ///            "properties": {
    ///              "non_fungible_id": {
    ///                "$ref": "#/components/schemas/NonFungibleId"
    ///              },
    ///              "resource_address": {
    ///                "$ref": "#/components/schemas/Address"
    ///              }
    ///            }
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct MetadataNonFungibleGlobalIdArrayValue {
        #[serde(rename = "type")]
        pub type_: MetadataNonFungibleGlobalIdArrayValueType,
        pub values: Vec<MetadataNonFungibleGlobalIdArrayValueValuesItem>,
    }
    impl From<&MetadataNonFungibleGlobalIdArrayValue>
    for MetadataNonFungibleGlobalIdArrayValue {
        fn from(value: &MetadataNonFungibleGlobalIdArrayValue) -> Self {
            value.clone()
        }
    }
    impl MetadataNonFungibleGlobalIdArrayValue {
        pub fn builder() -> builder::MetadataNonFungibleGlobalIdArrayValue {
            Default::default()
        }
    }
    ///MetadataNonFungibleGlobalIdArrayValueType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "NonFungibleGlobalIdArray"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum MetadataNonFungibleGlobalIdArrayValueType {
        NonFungibleGlobalIdArray,
    }
    impl From<&MetadataNonFungibleGlobalIdArrayValueType>
    for MetadataNonFungibleGlobalIdArrayValueType {
        fn from(value: &MetadataNonFungibleGlobalIdArrayValueType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for MetadataNonFungibleGlobalIdArrayValueType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::NonFungibleGlobalIdArray => write!(f, "NonFungibleGlobalIdArray"),
            }
        }
    }
    impl std::str::FromStr for MetadataNonFungibleGlobalIdArrayValueType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "NonFungibleGlobalIdArray" => Ok(Self::NonFungibleGlobalIdArray),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MetadataNonFungibleGlobalIdArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MetadataNonFungibleGlobalIdArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MetadataNonFungibleGlobalIdArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MetadataNonFungibleGlobalIdArrayValueValuesItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "non_fungible_id",
    ///    "resource_address"
    ///  ],
    ///  "properties": {
    ///    "non_fungible_id": {
    ///      "$ref": "#/components/schemas/NonFungibleId"
    ///    },
    ///    "resource_address": {
    ///      "$ref": "#/components/schemas/Address"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct MetadataNonFungibleGlobalIdArrayValueValuesItem {
        pub non_fungible_id: NonFungibleId,
        pub resource_address: Address,
    }
    impl From<&MetadataNonFungibleGlobalIdArrayValueValuesItem>
    for MetadataNonFungibleGlobalIdArrayValueValuesItem {
        fn from(value: &MetadataNonFungibleGlobalIdArrayValueValuesItem) -> Self {
            value.clone()
        }
    }
    impl MetadataNonFungibleGlobalIdArrayValueValuesItem {
        pub fn builder() -> builder::MetadataNonFungibleGlobalIdArrayValueValuesItem {
            Default::default()
        }
    }
    ///MetadataNonFungibleGlobalIdValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/MetadataTypedValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "non_fungible_id",
    ///        "resource_address"
    ///      ],
    ///      "properties": {
    ///        "non_fungible_id": {
    ///          "$ref": "#/components/schemas/NonFungibleId"
    ///        },
    ///        "resource_address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "NonFungibleGlobalId"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct MetadataNonFungibleGlobalIdValue {
        pub non_fungible_id: NonFungibleId,
        pub resource_address: Address,
        #[serde(rename = "type")]
        pub type_: MetadataNonFungibleGlobalIdValueType,
    }
    impl From<&MetadataNonFungibleGlobalIdValue> for MetadataNonFungibleGlobalIdValue {
        fn from(value: &MetadataNonFungibleGlobalIdValue) -> Self {
            value.clone()
        }
    }
    impl MetadataNonFungibleGlobalIdValue {
        pub fn builder() -> builder::MetadataNonFungibleGlobalIdValue {
            Default::default()
        }
    }
    ///MetadataNonFungibleGlobalIdValueType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "NonFungibleGlobalId"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum MetadataNonFungibleGlobalIdValueType {
        NonFungibleGlobalId,
    }
    impl From<&MetadataNonFungibleGlobalIdValueType>
    for MetadataNonFungibleGlobalIdValueType {
        fn from(value: &MetadataNonFungibleGlobalIdValueType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for MetadataNonFungibleGlobalIdValueType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::NonFungibleGlobalId => write!(f, "NonFungibleGlobalId"),
            }
        }
    }
    impl std::str::FromStr for MetadataNonFungibleGlobalIdValueType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "NonFungibleGlobalId" => Ok(Self::NonFungibleGlobalId),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MetadataNonFungibleGlobalIdValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MetadataNonFungibleGlobalIdValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MetadataNonFungibleGlobalIdValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MetadataNonFungibleLocalIdArrayValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/MetadataTypedValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "values"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "NonFungibleLocalIdArray"
    ///          ]
    ///        },
    ///        "values": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct MetadataNonFungibleLocalIdArrayValue {
        #[serde(rename = "type")]
        pub type_: MetadataNonFungibleLocalIdArrayValueType,
        pub values: Vec<String>,
    }
    impl From<&MetadataNonFungibleLocalIdArrayValue>
    for MetadataNonFungibleLocalIdArrayValue {
        fn from(value: &MetadataNonFungibleLocalIdArrayValue) -> Self {
            value.clone()
        }
    }
    impl MetadataNonFungibleLocalIdArrayValue {
        pub fn builder() -> builder::MetadataNonFungibleLocalIdArrayValue {
            Default::default()
        }
    }
    ///MetadataNonFungibleLocalIdArrayValueType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "NonFungibleLocalIdArray"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum MetadataNonFungibleLocalIdArrayValueType {
        NonFungibleLocalIdArray,
    }
    impl From<&MetadataNonFungibleLocalIdArrayValueType>
    for MetadataNonFungibleLocalIdArrayValueType {
        fn from(value: &MetadataNonFungibleLocalIdArrayValueType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for MetadataNonFungibleLocalIdArrayValueType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::NonFungibleLocalIdArray => write!(f, "NonFungibleLocalIdArray"),
            }
        }
    }
    impl std::str::FromStr for MetadataNonFungibleLocalIdArrayValueType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "NonFungibleLocalIdArray" => Ok(Self::NonFungibleLocalIdArray),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MetadataNonFungibleLocalIdArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MetadataNonFungibleLocalIdArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MetadataNonFungibleLocalIdArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MetadataNonFungibleLocalIdValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/MetadataTypedValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "NonFungibleLocalId"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct MetadataNonFungibleLocalIdValue {
        #[serde(rename = "type")]
        pub type_: MetadataNonFungibleLocalIdValueType,
        pub value: String,
    }
    impl From<&MetadataNonFungibleLocalIdValue> for MetadataNonFungibleLocalIdValue {
        fn from(value: &MetadataNonFungibleLocalIdValue) -> Self {
            value.clone()
        }
    }
    impl MetadataNonFungibleLocalIdValue {
        pub fn builder() -> builder::MetadataNonFungibleLocalIdValue {
            Default::default()
        }
    }
    ///MetadataNonFungibleLocalIdValueType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "NonFungibleLocalId"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum MetadataNonFungibleLocalIdValueType {
        NonFungibleLocalId,
    }
    impl From<&MetadataNonFungibleLocalIdValueType>
    for MetadataNonFungibleLocalIdValueType {
        fn from(value: &MetadataNonFungibleLocalIdValueType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for MetadataNonFungibleLocalIdValueType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::NonFungibleLocalId => write!(f, "NonFungibleLocalId"),
            }
        }
    }
    impl std::str::FromStr for MetadataNonFungibleLocalIdValueType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "NonFungibleLocalId" => Ok(Self::NonFungibleLocalId),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MetadataNonFungibleLocalIdValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MetadataNonFungibleLocalIdValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MetadataNonFungibleLocalIdValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MetadataOriginArrayValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/MetadataTypedValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "values"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "OriginArray"
    ///          ]
    ///        },
    ///        "values": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct MetadataOriginArrayValue {
        #[serde(rename = "type")]
        pub type_: MetadataOriginArrayValueType,
        pub values: Vec<String>,
    }
    impl From<&MetadataOriginArrayValue> for MetadataOriginArrayValue {
        fn from(value: &MetadataOriginArrayValue) -> Self {
            value.clone()
        }
    }
    impl MetadataOriginArrayValue {
        pub fn builder() -> builder::MetadataOriginArrayValue {
            Default::default()
        }
    }
    ///MetadataOriginArrayValueType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "OriginArray"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum MetadataOriginArrayValueType {
        OriginArray,
    }
    impl From<&MetadataOriginArrayValueType> for MetadataOriginArrayValueType {
        fn from(value: &MetadataOriginArrayValueType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for MetadataOriginArrayValueType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::OriginArray => write!(f, "OriginArray"),
            }
        }
    }
    impl std::str::FromStr for MetadataOriginArrayValueType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "OriginArray" => Ok(Self::OriginArray),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MetadataOriginArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MetadataOriginArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MetadataOriginArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MetadataOriginValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/MetadataTypedValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "Origin"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct MetadataOriginValue {
        #[serde(rename = "type")]
        pub type_: MetadataOriginValueType,
        pub value: String,
    }
    impl From<&MetadataOriginValue> for MetadataOriginValue {
        fn from(value: &MetadataOriginValue) -> Self {
            value.clone()
        }
    }
    impl MetadataOriginValue {
        pub fn builder() -> builder::MetadataOriginValue {
            Default::default()
        }
    }
    ///MetadataOriginValueType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "Origin"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum MetadataOriginValueType {
        Origin,
    }
    impl From<&MetadataOriginValueType> for MetadataOriginValueType {
        fn from(value: &MetadataOriginValueType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for MetadataOriginValueType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Origin => write!(f, "Origin"),
            }
        }
    }
    impl std::str::FromStr for MetadataOriginValueType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "Origin" => Ok(Self::Origin),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MetadataOriginValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MetadataOriginValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MetadataOriginValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MetadataPublicKeyArrayValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/MetadataTypedValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "values"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "PublicKeyArray"
    ///          ]
    ///        },
    ///        "values": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/PublicKey"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct MetadataPublicKeyArrayValue {
        #[serde(rename = "type")]
        pub type_: MetadataPublicKeyArrayValueType,
        pub values: Vec<PublicKey>,
    }
    impl From<&MetadataPublicKeyArrayValue> for MetadataPublicKeyArrayValue {
        fn from(value: &MetadataPublicKeyArrayValue) -> Self {
            value.clone()
        }
    }
    impl MetadataPublicKeyArrayValue {
        pub fn builder() -> builder::MetadataPublicKeyArrayValue {
            Default::default()
        }
    }
    ///MetadataPublicKeyArrayValueType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "PublicKeyArray"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum MetadataPublicKeyArrayValueType {
        PublicKeyArray,
    }
    impl From<&MetadataPublicKeyArrayValueType> for MetadataPublicKeyArrayValueType {
        fn from(value: &MetadataPublicKeyArrayValueType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for MetadataPublicKeyArrayValueType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::PublicKeyArray => write!(f, "PublicKeyArray"),
            }
        }
    }
    impl std::str::FromStr for MetadataPublicKeyArrayValueType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "PublicKeyArray" => Ok(Self::PublicKeyArray),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MetadataPublicKeyArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MetadataPublicKeyArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MetadataPublicKeyArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MetadataPublicKeyHashArrayValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/MetadataTypedValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "values"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "PublicKeyHashArray"
    ///          ]
    ///        },
    ///        "values": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/PublicKeyHash"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct MetadataPublicKeyHashArrayValue {
        #[serde(rename = "type")]
        pub type_: MetadataPublicKeyHashArrayValueType,
        pub values: Vec<PublicKeyHash>,
    }
    impl From<&MetadataPublicKeyHashArrayValue> for MetadataPublicKeyHashArrayValue {
        fn from(value: &MetadataPublicKeyHashArrayValue) -> Self {
            value.clone()
        }
    }
    impl MetadataPublicKeyHashArrayValue {
        pub fn builder() -> builder::MetadataPublicKeyHashArrayValue {
            Default::default()
        }
    }
    ///MetadataPublicKeyHashArrayValueType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "PublicKeyHashArray"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum MetadataPublicKeyHashArrayValueType {
        PublicKeyHashArray,
    }
    impl From<&MetadataPublicKeyHashArrayValueType>
    for MetadataPublicKeyHashArrayValueType {
        fn from(value: &MetadataPublicKeyHashArrayValueType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for MetadataPublicKeyHashArrayValueType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::PublicKeyHashArray => write!(f, "PublicKeyHashArray"),
            }
        }
    }
    impl std::str::FromStr for MetadataPublicKeyHashArrayValueType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "PublicKeyHashArray" => Ok(Self::PublicKeyHashArray),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MetadataPublicKeyHashArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MetadataPublicKeyHashArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MetadataPublicKeyHashArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MetadataPublicKeyHashValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/MetadataTypedValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "PublicKeyHash"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/PublicKeyHash"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct MetadataPublicKeyHashValue {
        #[serde(rename = "type")]
        pub type_: MetadataPublicKeyHashValueType,
        pub value: PublicKeyHash,
    }
    impl From<&MetadataPublicKeyHashValue> for MetadataPublicKeyHashValue {
        fn from(value: &MetadataPublicKeyHashValue) -> Self {
            value.clone()
        }
    }
    impl MetadataPublicKeyHashValue {
        pub fn builder() -> builder::MetadataPublicKeyHashValue {
            Default::default()
        }
    }
    ///MetadataPublicKeyHashValueType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "PublicKeyHash"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum MetadataPublicKeyHashValueType {
        PublicKeyHash,
    }
    impl From<&MetadataPublicKeyHashValueType> for MetadataPublicKeyHashValueType {
        fn from(value: &MetadataPublicKeyHashValueType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for MetadataPublicKeyHashValueType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::PublicKeyHash => write!(f, "PublicKeyHash"),
            }
        }
    }
    impl std::str::FromStr for MetadataPublicKeyHashValueType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "PublicKeyHash" => Ok(Self::PublicKeyHash),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MetadataPublicKeyHashValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MetadataPublicKeyHashValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MetadataPublicKeyHashValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MetadataPublicKeyValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/MetadataTypedValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "PublicKey"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/PublicKey"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct MetadataPublicKeyValue {
        #[serde(rename = "type")]
        pub type_: MetadataPublicKeyValueType,
        pub value: PublicKey,
    }
    impl From<&MetadataPublicKeyValue> for MetadataPublicKeyValue {
        fn from(value: &MetadataPublicKeyValue) -> Self {
            value.clone()
        }
    }
    impl MetadataPublicKeyValue {
        pub fn builder() -> builder::MetadataPublicKeyValue {
            Default::default()
        }
    }
    ///MetadataPublicKeyValueType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "PublicKey"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum MetadataPublicKeyValueType {
        PublicKey,
    }
    impl From<&MetadataPublicKeyValueType> for MetadataPublicKeyValueType {
        fn from(value: &MetadataPublicKeyValueType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for MetadataPublicKeyValueType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::PublicKey => write!(f, "PublicKey"),
            }
        }
    }
    impl std::str::FromStr for MetadataPublicKeyValueType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "PublicKey" => Ok(Self::PublicKey),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MetadataPublicKeyValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MetadataPublicKeyValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MetadataPublicKeyValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MetadataStringArrayValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/MetadataTypedValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "values"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "StringArray"
    ///          ]
    ///        },
    ///        "values": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct MetadataStringArrayValue {
        #[serde(rename = "type")]
        pub type_: MetadataStringArrayValueType,
        pub values: Vec<String>,
    }
    impl From<&MetadataStringArrayValue> for MetadataStringArrayValue {
        fn from(value: &MetadataStringArrayValue) -> Self {
            value.clone()
        }
    }
    impl MetadataStringArrayValue {
        pub fn builder() -> builder::MetadataStringArrayValue {
            Default::default()
        }
    }
    ///MetadataStringArrayValueType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "StringArray"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum MetadataStringArrayValueType {
        StringArray,
    }
    impl From<&MetadataStringArrayValueType> for MetadataStringArrayValueType {
        fn from(value: &MetadataStringArrayValueType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for MetadataStringArrayValueType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::StringArray => write!(f, "StringArray"),
            }
        }
    }
    impl std::str::FromStr for MetadataStringArrayValueType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "StringArray" => Ok(Self::StringArray),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MetadataStringArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MetadataStringArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MetadataStringArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MetadataStringValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/MetadataTypedValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "String"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct MetadataStringValue {
        #[serde(rename = "type")]
        pub type_: MetadataStringValueType,
        pub value: String,
    }
    impl From<&MetadataStringValue> for MetadataStringValue {
        fn from(value: &MetadataStringValue) -> Self {
            value.clone()
        }
    }
    impl MetadataStringValue {
        pub fn builder() -> builder::MetadataStringValue {
            Default::default()
        }
    }
    ///MetadataStringValueType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "String"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum MetadataStringValueType {
        String,
    }
    impl From<&MetadataStringValueType> for MetadataStringValueType {
        fn from(value: &MetadataStringValueType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for MetadataStringValueType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::String => write!(f, "String"),
            }
        }
    }
    impl std::str::FromStr for MetadataStringValueType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "String" => Ok(Self::String),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MetadataStringValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MetadataStringValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MetadataStringValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MetadataTypedValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/MetadataStringValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/MetadataBoolValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/MetadataU8Value"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/MetadataU32Value"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/MetadataU64Value"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/MetadataI32Value"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/MetadataI64Value"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/MetadataDecimalValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/MetadataGlobalAddressValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/MetadataPublicKeyValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/MetadataNonFungibleGlobalIdValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/MetadataNonFungibleLocalIdValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/MetadataInstantValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/MetadataUrlValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/MetadataOriginValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/MetadataPublicKeyHashValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/MetadataStringArrayValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/MetadataBoolArrayValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/MetadataU8ArrayValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/MetadataU32ArrayValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/MetadataU64ArrayValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/MetadataI32ArrayValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/MetadataI64ArrayValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/MetadataDecimalArrayValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/MetadataGlobalAddressArrayValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/MetadataPublicKeyArrayValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/MetadataNonFungibleGlobalIdArrayValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/MetadataNonFungibleLocalIdArrayValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/MetadataInstantArrayValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/MetadataUrlArrayValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/MetadataOriginArrayValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/MetadataPublicKeyHashArrayValue"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum MetadataTypedValue {
        StringValue(MetadataStringValue),
        BoolValue(MetadataBoolValue),
        U8Value(MetadataU8Value),
        U32Value(MetadataU32Value),
        U64Value(MetadataU64Value),
        I32Value(MetadataI32Value),
        I64Value(MetadataI64Value),
        DecimalValue(MetadataDecimalValue),
        GlobalAddressValue(MetadataGlobalAddressValue),
        PublicKeyValue(MetadataPublicKeyValue),
        NonFungibleGlobalIdValue(MetadataNonFungibleGlobalIdValue),
        NonFungibleLocalIdValue(MetadataNonFungibleLocalIdValue),
        InstantValue(MetadataInstantValue),
        UrlValue(MetadataUrlValue),
        OriginValue(MetadataOriginValue),
        PublicKeyHashValue(MetadataPublicKeyHashValue),
        StringArrayValue(MetadataStringArrayValue),
        BoolArrayValue(MetadataBoolArrayValue),
        U8ArrayValue(MetadataU8ArrayValue),
        U32ArrayValue(MetadataU32ArrayValue),
        U64ArrayValue(MetadataU64ArrayValue),
        I32ArrayValue(MetadataI32ArrayValue),
        I64ArrayValue(MetadataI64ArrayValue),
        DecimalArrayValue(MetadataDecimalArrayValue),
        GlobalAddressArrayValue(MetadataGlobalAddressArrayValue),
        PublicKeyArrayValue(MetadataPublicKeyArrayValue),
        NonFungibleGlobalIdArrayValue(MetadataNonFungibleGlobalIdArrayValue),
        NonFungibleLocalIdArrayValue(MetadataNonFungibleLocalIdArrayValue),
        InstantArrayValue(MetadataInstantArrayValue),
        UrlArrayValue(MetadataUrlArrayValue),
        OriginArrayValue(MetadataOriginArrayValue),
        PublicKeyHashArrayValue(MetadataPublicKeyHashArrayValue),
    }
    impl From<&MetadataTypedValue> for MetadataTypedValue {
        fn from(value: &MetadataTypedValue) -> Self {
            value.clone()
        }
    }
    impl From<MetadataStringValue> for MetadataTypedValue {
        fn from(value: MetadataStringValue) -> Self {
            Self::StringValue(value)
        }
    }
    impl From<MetadataBoolValue> for MetadataTypedValue {
        fn from(value: MetadataBoolValue) -> Self {
            Self::BoolValue(value)
        }
    }
    impl From<MetadataU8Value> for MetadataTypedValue {
        fn from(value: MetadataU8Value) -> Self {
            Self::U8Value(value)
        }
    }
    impl From<MetadataU32Value> for MetadataTypedValue {
        fn from(value: MetadataU32Value) -> Self {
            Self::U32Value(value)
        }
    }
    impl From<MetadataU64Value> for MetadataTypedValue {
        fn from(value: MetadataU64Value) -> Self {
            Self::U64Value(value)
        }
    }
    impl From<MetadataI32Value> for MetadataTypedValue {
        fn from(value: MetadataI32Value) -> Self {
            Self::I32Value(value)
        }
    }
    impl From<MetadataI64Value> for MetadataTypedValue {
        fn from(value: MetadataI64Value) -> Self {
            Self::I64Value(value)
        }
    }
    impl From<MetadataDecimalValue> for MetadataTypedValue {
        fn from(value: MetadataDecimalValue) -> Self {
            Self::DecimalValue(value)
        }
    }
    impl From<MetadataGlobalAddressValue> for MetadataTypedValue {
        fn from(value: MetadataGlobalAddressValue) -> Self {
            Self::GlobalAddressValue(value)
        }
    }
    impl From<MetadataPublicKeyValue> for MetadataTypedValue {
        fn from(value: MetadataPublicKeyValue) -> Self {
            Self::PublicKeyValue(value)
        }
    }
    impl From<MetadataNonFungibleGlobalIdValue> for MetadataTypedValue {
        fn from(value: MetadataNonFungibleGlobalIdValue) -> Self {
            Self::NonFungibleGlobalIdValue(value)
        }
    }
    impl From<MetadataNonFungibleLocalIdValue> for MetadataTypedValue {
        fn from(value: MetadataNonFungibleLocalIdValue) -> Self {
            Self::NonFungibleLocalIdValue(value)
        }
    }
    impl From<MetadataInstantValue> for MetadataTypedValue {
        fn from(value: MetadataInstantValue) -> Self {
            Self::InstantValue(value)
        }
    }
    impl From<MetadataUrlValue> for MetadataTypedValue {
        fn from(value: MetadataUrlValue) -> Self {
            Self::UrlValue(value)
        }
    }
    impl From<MetadataOriginValue> for MetadataTypedValue {
        fn from(value: MetadataOriginValue) -> Self {
            Self::OriginValue(value)
        }
    }
    impl From<MetadataPublicKeyHashValue> for MetadataTypedValue {
        fn from(value: MetadataPublicKeyHashValue) -> Self {
            Self::PublicKeyHashValue(value)
        }
    }
    impl From<MetadataStringArrayValue> for MetadataTypedValue {
        fn from(value: MetadataStringArrayValue) -> Self {
            Self::StringArrayValue(value)
        }
    }
    impl From<MetadataBoolArrayValue> for MetadataTypedValue {
        fn from(value: MetadataBoolArrayValue) -> Self {
            Self::BoolArrayValue(value)
        }
    }
    impl From<MetadataU8ArrayValue> for MetadataTypedValue {
        fn from(value: MetadataU8ArrayValue) -> Self {
            Self::U8ArrayValue(value)
        }
    }
    impl From<MetadataU32ArrayValue> for MetadataTypedValue {
        fn from(value: MetadataU32ArrayValue) -> Self {
            Self::U32ArrayValue(value)
        }
    }
    impl From<MetadataU64ArrayValue> for MetadataTypedValue {
        fn from(value: MetadataU64ArrayValue) -> Self {
            Self::U64ArrayValue(value)
        }
    }
    impl From<MetadataI32ArrayValue> for MetadataTypedValue {
        fn from(value: MetadataI32ArrayValue) -> Self {
            Self::I32ArrayValue(value)
        }
    }
    impl From<MetadataI64ArrayValue> for MetadataTypedValue {
        fn from(value: MetadataI64ArrayValue) -> Self {
            Self::I64ArrayValue(value)
        }
    }
    impl From<MetadataDecimalArrayValue> for MetadataTypedValue {
        fn from(value: MetadataDecimalArrayValue) -> Self {
            Self::DecimalArrayValue(value)
        }
    }
    impl From<MetadataGlobalAddressArrayValue> for MetadataTypedValue {
        fn from(value: MetadataGlobalAddressArrayValue) -> Self {
            Self::GlobalAddressArrayValue(value)
        }
    }
    impl From<MetadataPublicKeyArrayValue> for MetadataTypedValue {
        fn from(value: MetadataPublicKeyArrayValue) -> Self {
            Self::PublicKeyArrayValue(value)
        }
    }
    impl From<MetadataNonFungibleGlobalIdArrayValue> for MetadataTypedValue {
        fn from(value: MetadataNonFungibleGlobalIdArrayValue) -> Self {
            Self::NonFungibleGlobalIdArrayValue(value)
        }
    }
    impl From<MetadataNonFungibleLocalIdArrayValue> for MetadataTypedValue {
        fn from(value: MetadataNonFungibleLocalIdArrayValue) -> Self {
            Self::NonFungibleLocalIdArrayValue(value)
        }
    }
    impl From<MetadataInstantArrayValue> for MetadataTypedValue {
        fn from(value: MetadataInstantArrayValue) -> Self {
            Self::InstantArrayValue(value)
        }
    }
    impl From<MetadataUrlArrayValue> for MetadataTypedValue {
        fn from(value: MetadataUrlArrayValue) -> Self {
            Self::UrlArrayValue(value)
        }
    }
    impl From<MetadataOriginArrayValue> for MetadataTypedValue {
        fn from(value: MetadataOriginArrayValue) -> Self {
            Self::OriginArrayValue(value)
        }
    }
    impl From<MetadataPublicKeyHashArrayValue> for MetadataTypedValue {
        fn from(value: MetadataPublicKeyHashArrayValue) -> Self {
            Self::PublicKeyHashArrayValue(value)
        }
    }
    ///MetadataTypedValueBase
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "type": {
    ///      "$ref": "#/components/schemas/MetadataValueType"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct MetadataTypedValueBase {
        #[serde(rename = "type")]
        pub type_: MetadataValueType,
    }
    impl From<&MetadataTypedValueBase> for MetadataTypedValueBase {
        fn from(value: &MetadataTypedValueBase) -> Self {
            value.clone()
        }
    }
    impl MetadataTypedValueBase {
        pub fn builder() -> builder::MetadataTypedValueBase {
            Default::default()
        }
    }
    ///MetadataU32ArrayValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/MetadataTypedValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "values"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "U32Array"
    ///          ]
    ///        },
    ///        "values": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct MetadataU32ArrayValue {
        #[serde(rename = "type")]
        pub type_: MetadataU32ArrayValueType,
        pub values: Vec<String>,
    }
    impl From<&MetadataU32ArrayValue> for MetadataU32ArrayValue {
        fn from(value: &MetadataU32ArrayValue) -> Self {
            value.clone()
        }
    }
    impl MetadataU32ArrayValue {
        pub fn builder() -> builder::MetadataU32ArrayValue {
            Default::default()
        }
    }
    ///MetadataU32ArrayValueType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "U32Array"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum MetadataU32ArrayValueType {
        U32Array,
    }
    impl From<&MetadataU32ArrayValueType> for MetadataU32ArrayValueType {
        fn from(value: &MetadataU32ArrayValueType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for MetadataU32ArrayValueType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::U32Array => write!(f, "U32Array"),
            }
        }
    }
    impl std::str::FromStr for MetadataU32ArrayValueType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "U32Array" => Ok(Self::U32Array),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MetadataU32ArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MetadataU32ArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MetadataU32ArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MetadataU32Value
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/MetadataTypedValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "U32"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct MetadataU32Value {
        #[serde(rename = "type")]
        pub type_: MetadataU32ValueType,
        pub value: String,
    }
    impl From<&MetadataU32Value> for MetadataU32Value {
        fn from(value: &MetadataU32Value) -> Self {
            value.clone()
        }
    }
    impl MetadataU32Value {
        pub fn builder() -> builder::MetadataU32Value {
            Default::default()
        }
    }
    ///MetadataU32ValueType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "U32"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum MetadataU32ValueType {
        U32,
    }
    impl From<&MetadataU32ValueType> for MetadataU32ValueType {
        fn from(value: &MetadataU32ValueType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for MetadataU32ValueType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::U32 => write!(f, "U32"),
            }
        }
    }
    impl std::str::FromStr for MetadataU32ValueType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "U32" => Ok(Self::U32),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MetadataU32ValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MetadataU32ValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MetadataU32ValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MetadataU64ArrayValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/MetadataTypedValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "values"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "U64Array"
    ///          ]
    ///        },
    ///        "values": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct MetadataU64ArrayValue {
        #[serde(rename = "type")]
        pub type_: MetadataU64ArrayValueType,
        pub values: Vec<String>,
    }
    impl From<&MetadataU64ArrayValue> for MetadataU64ArrayValue {
        fn from(value: &MetadataU64ArrayValue) -> Self {
            value.clone()
        }
    }
    impl MetadataU64ArrayValue {
        pub fn builder() -> builder::MetadataU64ArrayValue {
            Default::default()
        }
    }
    ///MetadataU64ArrayValueType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "U64Array"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum MetadataU64ArrayValueType {
        U64Array,
    }
    impl From<&MetadataU64ArrayValueType> for MetadataU64ArrayValueType {
        fn from(value: &MetadataU64ArrayValueType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for MetadataU64ArrayValueType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::U64Array => write!(f, "U64Array"),
            }
        }
    }
    impl std::str::FromStr for MetadataU64ArrayValueType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "U64Array" => Ok(Self::U64Array),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MetadataU64ArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MetadataU64ArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MetadataU64ArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MetadataU64Value
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/MetadataTypedValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "U64"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct MetadataU64Value {
        #[serde(rename = "type")]
        pub type_: MetadataU64ValueType,
        pub value: String,
    }
    impl From<&MetadataU64Value> for MetadataU64Value {
        fn from(value: &MetadataU64Value) -> Self {
            value.clone()
        }
    }
    impl MetadataU64Value {
        pub fn builder() -> builder::MetadataU64Value {
            Default::default()
        }
    }
    ///MetadataU64ValueType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "U64"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum MetadataU64ValueType {
        U64,
    }
    impl From<&MetadataU64ValueType> for MetadataU64ValueType {
        fn from(value: &MetadataU64ValueType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for MetadataU64ValueType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::U64 => write!(f, "U64"),
            }
        }
    }
    impl std::str::FromStr for MetadataU64ValueType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "U64" => Ok(Self::U64),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MetadataU64ValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MetadataU64ValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MetadataU64ValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MetadataU8ArrayValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/MetadataTypedValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "value_hex"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "U8Array"
    ///          ]
    ///        },
    ///        "value_hex": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct MetadataU8ArrayValue {
        #[serde(rename = "type")]
        pub type_: MetadataU8ArrayValueType,
        pub value_hex: String,
    }
    impl From<&MetadataU8ArrayValue> for MetadataU8ArrayValue {
        fn from(value: &MetadataU8ArrayValue) -> Self {
            value.clone()
        }
    }
    impl MetadataU8ArrayValue {
        pub fn builder() -> builder::MetadataU8ArrayValue {
            Default::default()
        }
    }
    ///MetadataU8ArrayValueType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "U8Array"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum MetadataU8ArrayValueType {
        U8Array,
    }
    impl From<&MetadataU8ArrayValueType> for MetadataU8ArrayValueType {
        fn from(value: &MetadataU8ArrayValueType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for MetadataU8ArrayValueType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::U8Array => write!(f, "U8Array"),
            }
        }
    }
    impl std::str::FromStr for MetadataU8ArrayValueType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "U8Array" => Ok(Self::U8Array),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MetadataU8ArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MetadataU8ArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MetadataU8ArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MetadataU8Value
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/MetadataTypedValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "U8"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct MetadataU8Value {
        #[serde(rename = "type")]
        pub type_: MetadataU8ValueType,
        pub value: String,
    }
    impl From<&MetadataU8Value> for MetadataU8Value {
        fn from(value: &MetadataU8Value) -> Self {
            value.clone()
        }
    }
    impl MetadataU8Value {
        pub fn builder() -> builder::MetadataU8Value {
            Default::default()
        }
    }
    ///MetadataU8ValueType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "U8"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum MetadataU8ValueType {
        U8,
    }
    impl From<&MetadataU8ValueType> for MetadataU8ValueType {
        fn from(value: &MetadataU8ValueType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for MetadataU8ValueType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::U8 => write!(f, "U8"),
            }
        }
    }
    impl std::str::FromStr for MetadataU8ValueType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "U8" => Ok(Self::U8),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MetadataU8ValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MetadataU8ValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MetadataU8ValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MetadataUrlArrayValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/MetadataTypedValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "values"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "UrlArray"
    ///          ]
    ///        },
    ///        "values": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct MetadataUrlArrayValue {
        #[serde(rename = "type")]
        pub type_: MetadataUrlArrayValueType,
        pub values: Vec<String>,
    }
    impl From<&MetadataUrlArrayValue> for MetadataUrlArrayValue {
        fn from(value: &MetadataUrlArrayValue) -> Self {
            value.clone()
        }
    }
    impl MetadataUrlArrayValue {
        pub fn builder() -> builder::MetadataUrlArrayValue {
            Default::default()
        }
    }
    ///MetadataUrlArrayValueType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "UrlArray"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum MetadataUrlArrayValueType {
        UrlArray,
    }
    impl From<&MetadataUrlArrayValueType> for MetadataUrlArrayValueType {
        fn from(value: &MetadataUrlArrayValueType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for MetadataUrlArrayValueType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::UrlArray => write!(f, "UrlArray"),
            }
        }
    }
    impl std::str::FromStr for MetadataUrlArrayValueType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "UrlArray" => Ok(Self::UrlArray),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MetadataUrlArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MetadataUrlArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MetadataUrlArrayValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MetadataUrlValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/MetadataTypedValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "Url"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct MetadataUrlValue {
        #[serde(rename = "type")]
        pub type_: MetadataUrlValueType,
        pub value: String,
    }
    impl From<&MetadataUrlValue> for MetadataUrlValue {
        fn from(value: &MetadataUrlValue) -> Self {
            value.clone()
        }
    }
    impl MetadataUrlValue {
        pub fn builder() -> builder::MetadataUrlValue {
            Default::default()
        }
    }
    ///MetadataUrlValueType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "Url"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum MetadataUrlValueType {
        Url,
    }
    impl From<&MetadataUrlValueType> for MetadataUrlValueType {
        fn from(value: &MetadataUrlValueType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for MetadataUrlValueType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Url => write!(f, "Url"),
            }
        }
    }
    impl std::str::FromStr for MetadataUrlValueType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "Url" => Ok(Self::Url),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MetadataUrlValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MetadataUrlValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MetadataUrlValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///MetadataValueType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "String",
    ///    "Bool",
    ///    "U8",
    ///    "U32",
    ///    "U64",
    ///    "I32",
    ///    "I64",
    ///    "Decimal",
    ///    "GlobalAddress",
    ///    "PublicKey",
    ///    "NonFungibleGlobalId",
    ///    "NonFungibleLocalId",
    ///    "Instant",
    ///    "Url",
    ///    "Origin",
    ///    "PublicKeyHash",
    ///    "StringArray",
    ///    "BoolArray",
    ///    "U8Array",
    ///    "U32Array",
    ///    "U64Array",
    ///    "I32Array",
    ///    "I64Array",
    ///    "DecimalArray",
    ///    "GlobalAddressArray",
    ///    "PublicKeyArray",
    ///    "NonFungibleGlobalIdArray",
    ///    "NonFungibleLocalIdArray",
    ///    "InstantArray",
    ///    "UrlArray",
    ///    "OriginArray",
    ///    "PublicKeyHashArray"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum MetadataValueType {
        String,
        Bool,
        U8,
        U32,
        U64,
        I32,
        I64,
        Decimal,
        GlobalAddress,
        PublicKey,
        NonFungibleGlobalId,
        NonFungibleLocalId,
        Instant,
        Url,
        Origin,
        PublicKeyHash,
        StringArray,
        BoolArray,
        U8Array,
        U32Array,
        U64Array,
        I32Array,
        I64Array,
        DecimalArray,
        GlobalAddressArray,
        PublicKeyArray,
        NonFungibleGlobalIdArray,
        NonFungibleLocalIdArray,
        InstantArray,
        UrlArray,
        OriginArray,
        PublicKeyHashArray,
    }
    impl From<&MetadataValueType> for MetadataValueType {
        fn from(value: &MetadataValueType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for MetadataValueType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::String => write!(f, "String"),
                Self::Bool => write!(f, "Bool"),
                Self::U8 => write!(f, "U8"),
                Self::U32 => write!(f, "U32"),
                Self::U64 => write!(f, "U64"),
                Self::I32 => write!(f, "I32"),
                Self::I64 => write!(f, "I64"),
                Self::Decimal => write!(f, "Decimal"),
                Self::GlobalAddress => write!(f, "GlobalAddress"),
                Self::PublicKey => write!(f, "PublicKey"),
                Self::NonFungibleGlobalId => write!(f, "NonFungibleGlobalId"),
                Self::NonFungibleLocalId => write!(f, "NonFungibleLocalId"),
                Self::Instant => write!(f, "Instant"),
                Self::Url => write!(f, "Url"),
                Self::Origin => write!(f, "Origin"),
                Self::PublicKeyHash => write!(f, "PublicKeyHash"),
                Self::StringArray => write!(f, "StringArray"),
                Self::BoolArray => write!(f, "BoolArray"),
                Self::U8Array => write!(f, "U8Array"),
                Self::U32Array => write!(f, "U32Array"),
                Self::U64Array => write!(f, "U64Array"),
                Self::I32Array => write!(f, "I32Array"),
                Self::I64Array => write!(f, "I64Array"),
                Self::DecimalArray => write!(f, "DecimalArray"),
                Self::GlobalAddressArray => write!(f, "GlobalAddressArray"),
                Self::PublicKeyArray => write!(f, "PublicKeyArray"),
                Self::NonFungibleGlobalIdArray => write!(f, "NonFungibleGlobalIdArray"),
                Self::NonFungibleLocalIdArray => write!(f, "NonFungibleLocalIdArray"),
                Self::InstantArray => write!(f, "InstantArray"),
                Self::UrlArray => write!(f, "UrlArray"),
                Self::OriginArray => write!(f, "OriginArray"),
                Self::PublicKeyHashArray => write!(f, "PublicKeyHashArray"),
            }
        }
    }
    impl std::str::FromStr for MetadataValueType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "String" => Ok(Self::String),
                "Bool" => Ok(Self::Bool),
                "U8" => Ok(Self::U8),
                "U32" => Ok(Self::U32),
                "U64" => Ok(Self::U64),
                "I32" => Ok(Self::I32),
                "I64" => Ok(Self::I64),
                "Decimal" => Ok(Self::Decimal),
                "GlobalAddress" => Ok(Self::GlobalAddress),
                "PublicKey" => Ok(Self::PublicKey),
                "NonFungibleGlobalId" => Ok(Self::NonFungibleGlobalId),
                "NonFungibleLocalId" => Ok(Self::NonFungibleLocalId),
                "Instant" => Ok(Self::Instant),
                "Url" => Ok(Self::Url),
                "Origin" => Ok(Self::Origin),
                "PublicKeyHash" => Ok(Self::PublicKeyHash),
                "StringArray" => Ok(Self::StringArray),
                "BoolArray" => Ok(Self::BoolArray),
                "U8Array" => Ok(Self::U8Array),
                "U32Array" => Ok(Self::U32Array),
                "U64Array" => Ok(Self::U64Array),
                "I32Array" => Ok(Self::I32Array),
                "I64Array" => Ok(Self::I64Array),
                "DecimalArray" => Ok(Self::DecimalArray),
                "GlobalAddressArray" => Ok(Self::GlobalAddressArray),
                "PublicKeyArray" => Ok(Self::PublicKeyArray),
                "NonFungibleGlobalIdArray" => Ok(Self::NonFungibleGlobalIdArray),
                "NonFungibleLocalIdArray" => Ok(Self::NonFungibleLocalIdArray),
                "InstantArray" => Ok(Self::InstantArray),
                "UrlArray" => Ok(Self::UrlArray),
                "OriginArray" => Ok(Self::OriginArray),
                "PublicKeyHashArray" => Ok(Self::PublicKeyHashArray),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for MetadataValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for MetadataValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for MetadataValueType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///NativeResourceAccessControllerRecoveryBadgeValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/NativeResourceDetailsBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "access_controller_address"
    ///      ],
    ///      "properties": {
    ///        "access_controller_address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "kind": {
    ///          "type": "string",
    ///          "enum": [
    ///            "AccessControllerRecoveryBadge"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct NativeResourceAccessControllerRecoveryBadgeValue {
        pub access_controller_address: Address,
        pub kind: NativeResourceAccessControllerRecoveryBadgeValueKind,
    }
    impl From<&NativeResourceAccessControllerRecoveryBadgeValue>
    for NativeResourceAccessControllerRecoveryBadgeValue {
        fn from(value: &NativeResourceAccessControllerRecoveryBadgeValue) -> Self {
            value.clone()
        }
    }
    impl NativeResourceAccessControllerRecoveryBadgeValue {
        pub fn builder() -> builder::NativeResourceAccessControllerRecoveryBadgeValue {
            Default::default()
        }
    }
    ///NativeResourceAccessControllerRecoveryBadgeValueKind
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "AccessControllerRecoveryBadge"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum NativeResourceAccessControllerRecoveryBadgeValueKind {
        AccessControllerRecoveryBadge,
    }
    impl From<&NativeResourceAccessControllerRecoveryBadgeValueKind>
    for NativeResourceAccessControllerRecoveryBadgeValueKind {
        fn from(value: &NativeResourceAccessControllerRecoveryBadgeValueKind) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for NativeResourceAccessControllerRecoveryBadgeValueKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::AccessControllerRecoveryBadge => {
                    write!(f, "AccessControllerRecoveryBadge")
                }
            }
        }
    }
    impl std::str::FromStr for NativeResourceAccessControllerRecoveryBadgeValueKind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "AccessControllerRecoveryBadge" => {
                    Ok(Self::AccessControllerRecoveryBadge)
                }
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str>
    for NativeResourceAccessControllerRecoveryBadgeValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String>
    for NativeResourceAccessControllerRecoveryBadgeValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String>
    for NativeResourceAccessControllerRecoveryBadgeValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///NativeResourceAccountOwnerBadgeValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/NativeResourceDetailsBase"
    ///    },
    ///    {
    ///      "type": "object"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "properties": {
    ///        "kind": {
    ///          "type": "string",
    ///          "enum": [
    ///            "AccountOwnerBadge"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct NativeResourceAccountOwnerBadgeValue {
        pub kind: NativeResourceAccountOwnerBadgeValueKind,
    }
    impl From<&NativeResourceAccountOwnerBadgeValue>
    for NativeResourceAccountOwnerBadgeValue {
        fn from(value: &NativeResourceAccountOwnerBadgeValue) -> Self {
            value.clone()
        }
    }
    impl NativeResourceAccountOwnerBadgeValue {
        pub fn builder() -> builder::NativeResourceAccountOwnerBadgeValue {
            Default::default()
        }
    }
    ///NativeResourceAccountOwnerBadgeValueKind
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "AccountOwnerBadge"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum NativeResourceAccountOwnerBadgeValueKind {
        AccountOwnerBadge,
    }
    impl From<&NativeResourceAccountOwnerBadgeValueKind>
    for NativeResourceAccountOwnerBadgeValueKind {
        fn from(value: &NativeResourceAccountOwnerBadgeValueKind) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for NativeResourceAccountOwnerBadgeValueKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::AccountOwnerBadge => write!(f, "AccountOwnerBadge"),
            }
        }
    }
    impl std::str::FromStr for NativeResourceAccountOwnerBadgeValueKind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "AccountOwnerBadge" => Ok(Self::AccountOwnerBadge),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for NativeResourceAccountOwnerBadgeValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for NativeResourceAccountOwnerBadgeValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for NativeResourceAccountOwnerBadgeValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///NativeResourceDetails
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/NativeResourceXrdValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/NativeResourcePackageOwnerBadgeValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/NativeResourceAccountOwnerBadgeValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/NativeResourceIdentityOwnerBadgeValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/NativeResourceValidatorOwnerBadgeValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/NativeResourceSecp256k1SignatureResourceValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/NativeResourceEd25519SignatureResourceValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/NativeResourceGlobalCallerResourceValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/NativeResourcePackageOfDirectCallerResourceValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/NativeResourceSystemExecutionResourceValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/NativeResourceValidatorLiquidStakeUnitValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/NativeResourceValidatorClaimNftValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/NativeResourceOneResourcePoolUnitValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/NativeResourceTwoResourcePoolUnitValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/NativeResourceMultiResourcePoolUnitValue"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/NativeResourceAccessControllerRecoveryBadgeValue"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum NativeResourceDetails {
        XrdValue(NativeResourceXrdValue),
        PackageOwnerBadgeValue(NativeResourcePackageOwnerBadgeValue),
        AccountOwnerBadgeValue(NativeResourceAccountOwnerBadgeValue),
        IdentityOwnerBadgeValue(NativeResourceIdentityOwnerBadgeValue),
        ValidatorOwnerBadgeValue(NativeResourceValidatorOwnerBadgeValue),
        Secp256k1SignatureResourceValue(NativeResourceSecp256k1SignatureResourceValue),
        Ed25519SignatureResourceValue(NativeResourceEd25519SignatureResourceValue),
        GlobalCallerResourceValue(NativeResourceGlobalCallerResourceValue),
        PackageOfDirectCallerResourceValue(
            NativeResourcePackageOfDirectCallerResourceValue,
        ),
        SystemExecutionResourceValue(NativeResourceSystemExecutionResourceValue),
        ValidatorLiquidStakeUnitValue(NativeResourceValidatorLiquidStakeUnitValue),
        ValidatorClaimNftValue(NativeResourceValidatorClaimNftValue),
        OneResourcePoolUnitValue(NativeResourceOneResourcePoolUnitValue),
        TwoResourcePoolUnitValue(NativeResourceTwoResourcePoolUnitValue),
        MultiResourcePoolUnitValue(NativeResourceMultiResourcePoolUnitValue),
        AccessControllerRecoveryBadgeValue(
            NativeResourceAccessControllerRecoveryBadgeValue,
        ),
    }
    impl From<&NativeResourceDetails> for NativeResourceDetails {
        fn from(value: &NativeResourceDetails) -> Self {
            value.clone()
        }
    }
    impl From<NativeResourceXrdValue> for NativeResourceDetails {
        fn from(value: NativeResourceXrdValue) -> Self {
            Self::XrdValue(value)
        }
    }
    impl From<NativeResourcePackageOwnerBadgeValue> for NativeResourceDetails {
        fn from(value: NativeResourcePackageOwnerBadgeValue) -> Self {
            Self::PackageOwnerBadgeValue(value)
        }
    }
    impl From<NativeResourceAccountOwnerBadgeValue> for NativeResourceDetails {
        fn from(value: NativeResourceAccountOwnerBadgeValue) -> Self {
            Self::AccountOwnerBadgeValue(value)
        }
    }
    impl From<NativeResourceIdentityOwnerBadgeValue> for NativeResourceDetails {
        fn from(value: NativeResourceIdentityOwnerBadgeValue) -> Self {
            Self::IdentityOwnerBadgeValue(value)
        }
    }
    impl From<NativeResourceValidatorOwnerBadgeValue> for NativeResourceDetails {
        fn from(value: NativeResourceValidatorOwnerBadgeValue) -> Self {
            Self::ValidatorOwnerBadgeValue(value)
        }
    }
    impl From<NativeResourceSecp256k1SignatureResourceValue> for NativeResourceDetails {
        fn from(value: NativeResourceSecp256k1SignatureResourceValue) -> Self {
            Self::Secp256k1SignatureResourceValue(value)
        }
    }
    impl From<NativeResourceEd25519SignatureResourceValue> for NativeResourceDetails {
        fn from(value: NativeResourceEd25519SignatureResourceValue) -> Self {
            Self::Ed25519SignatureResourceValue(value)
        }
    }
    impl From<NativeResourceGlobalCallerResourceValue> for NativeResourceDetails {
        fn from(value: NativeResourceGlobalCallerResourceValue) -> Self {
            Self::GlobalCallerResourceValue(value)
        }
    }
    impl From<NativeResourcePackageOfDirectCallerResourceValue>
    for NativeResourceDetails {
        fn from(value: NativeResourcePackageOfDirectCallerResourceValue) -> Self {
            Self::PackageOfDirectCallerResourceValue(value)
        }
    }
    impl From<NativeResourceSystemExecutionResourceValue> for NativeResourceDetails {
        fn from(value: NativeResourceSystemExecutionResourceValue) -> Self {
            Self::SystemExecutionResourceValue(value)
        }
    }
    impl From<NativeResourceValidatorLiquidStakeUnitValue> for NativeResourceDetails {
        fn from(value: NativeResourceValidatorLiquidStakeUnitValue) -> Self {
            Self::ValidatorLiquidStakeUnitValue(value)
        }
    }
    impl From<NativeResourceValidatorClaimNftValue> for NativeResourceDetails {
        fn from(value: NativeResourceValidatorClaimNftValue) -> Self {
            Self::ValidatorClaimNftValue(value)
        }
    }
    impl From<NativeResourceOneResourcePoolUnitValue> for NativeResourceDetails {
        fn from(value: NativeResourceOneResourcePoolUnitValue) -> Self {
            Self::OneResourcePoolUnitValue(value)
        }
    }
    impl From<NativeResourceTwoResourcePoolUnitValue> for NativeResourceDetails {
        fn from(value: NativeResourceTwoResourcePoolUnitValue) -> Self {
            Self::TwoResourcePoolUnitValue(value)
        }
    }
    impl From<NativeResourceMultiResourcePoolUnitValue> for NativeResourceDetails {
        fn from(value: NativeResourceMultiResourcePoolUnitValue) -> Self {
            Self::MultiResourcePoolUnitValue(value)
        }
    }
    impl From<NativeResourceAccessControllerRecoveryBadgeValue>
    for NativeResourceDetails {
        fn from(value: NativeResourceAccessControllerRecoveryBadgeValue) -> Self {
            Self::AccessControllerRecoveryBadgeValue(value)
        }
    }
    ///NativeResourceDetailsBase
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "kind"
    ///  ],
    ///  "properties": {
    ///    "kind": {
    ///      "$ref": "#/components/schemas/NativeResourceKind"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct NativeResourceDetailsBase {
        pub kind: NativeResourceKind,
    }
    impl From<&NativeResourceDetailsBase> for NativeResourceDetailsBase {
        fn from(value: &NativeResourceDetailsBase) -> Self {
            value.clone()
        }
    }
    impl NativeResourceDetailsBase {
        pub fn builder() -> builder::NativeResourceDetailsBase {
            Default::default()
        }
    }
    ///NativeResourceEd25519SignatureResourceValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/NativeResourceDetailsBase"
    ///    },
    ///    {
    ///      "type": "object"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "properties": {
    ///        "kind": {
    ///          "type": "string",
    ///          "enum": [
    ///            "Ed25519SignatureResource"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct NativeResourceEd25519SignatureResourceValue {
        pub kind: NativeResourceEd25519SignatureResourceValueKind,
    }
    impl From<&NativeResourceEd25519SignatureResourceValue>
    for NativeResourceEd25519SignatureResourceValue {
        fn from(value: &NativeResourceEd25519SignatureResourceValue) -> Self {
            value.clone()
        }
    }
    impl NativeResourceEd25519SignatureResourceValue {
        pub fn builder() -> builder::NativeResourceEd25519SignatureResourceValue {
            Default::default()
        }
    }
    ///NativeResourceEd25519SignatureResourceValueKind
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "Ed25519SignatureResource"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum NativeResourceEd25519SignatureResourceValueKind {
        Ed25519SignatureResource,
    }
    impl From<&NativeResourceEd25519SignatureResourceValueKind>
    for NativeResourceEd25519SignatureResourceValueKind {
        fn from(value: &NativeResourceEd25519SignatureResourceValueKind) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for NativeResourceEd25519SignatureResourceValueKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ed25519SignatureResource => write!(f, "Ed25519SignatureResource"),
            }
        }
    }
    impl std::str::FromStr for NativeResourceEd25519SignatureResourceValueKind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "Ed25519SignatureResource" => Ok(Self::Ed25519SignatureResource),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str>
    for NativeResourceEd25519SignatureResourceValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String>
    for NativeResourceEd25519SignatureResourceValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String>
    for NativeResourceEd25519SignatureResourceValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///NativeResourceGlobalCallerResourceValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/NativeResourceDetailsBase"
    ///    },
    ///    {
    ///      "type": "object"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "properties": {
    ///        "kind": {
    ///          "type": "string",
    ///          "enum": [
    ///            "GlobalCallerResource"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct NativeResourceGlobalCallerResourceValue {
        pub kind: NativeResourceGlobalCallerResourceValueKind,
    }
    impl From<&NativeResourceGlobalCallerResourceValue>
    for NativeResourceGlobalCallerResourceValue {
        fn from(value: &NativeResourceGlobalCallerResourceValue) -> Self {
            value.clone()
        }
    }
    impl NativeResourceGlobalCallerResourceValue {
        pub fn builder() -> builder::NativeResourceGlobalCallerResourceValue {
            Default::default()
        }
    }
    ///NativeResourceGlobalCallerResourceValueKind
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "GlobalCallerResource"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum NativeResourceGlobalCallerResourceValueKind {
        GlobalCallerResource,
    }
    impl From<&NativeResourceGlobalCallerResourceValueKind>
    for NativeResourceGlobalCallerResourceValueKind {
        fn from(value: &NativeResourceGlobalCallerResourceValueKind) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for NativeResourceGlobalCallerResourceValueKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GlobalCallerResource => write!(f, "GlobalCallerResource"),
            }
        }
    }
    impl std::str::FromStr for NativeResourceGlobalCallerResourceValueKind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "GlobalCallerResource" => Ok(Self::GlobalCallerResource),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for NativeResourceGlobalCallerResourceValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for NativeResourceGlobalCallerResourceValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for NativeResourceGlobalCallerResourceValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///NativeResourceIdentityOwnerBadgeValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/NativeResourceDetailsBase"
    ///    },
    ///    {
    ///      "type": "object"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "properties": {
    ///        "kind": {
    ///          "type": "string",
    ///          "enum": [
    ///            "IdentityOwnerBadge"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct NativeResourceIdentityOwnerBadgeValue {
        pub kind: NativeResourceIdentityOwnerBadgeValueKind,
    }
    impl From<&NativeResourceIdentityOwnerBadgeValue>
    for NativeResourceIdentityOwnerBadgeValue {
        fn from(value: &NativeResourceIdentityOwnerBadgeValue) -> Self {
            value.clone()
        }
    }
    impl NativeResourceIdentityOwnerBadgeValue {
        pub fn builder() -> builder::NativeResourceIdentityOwnerBadgeValue {
            Default::default()
        }
    }
    ///NativeResourceIdentityOwnerBadgeValueKind
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "IdentityOwnerBadge"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum NativeResourceIdentityOwnerBadgeValueKind {
        IdentityOwnerBadge,
    }
    impl From<&NativeResourceIdentityOwnerBadgeValueKind>
    for NativeResourceIdentityOwnerBadgeValueKind {
        fn from(value: &NativeResourceIdentityOwnerBadgeValueKind) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for NativeResourceIdentityOwnerBadgeValueKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::IdentityOwnerBadge => write!(f, "IdentityOwnerBadge"),
            }
        }
    }
    impl std::str::FromStr for NativeResourceIdentityOwnerBadgeValueKind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "IdentityOwnerBadge" => Ok(Self::IdentityOwnerBadge),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for NativeResourceIdentityOwnerBadgeValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for NativeResourceIdentityOwnerBadgeValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for NativeResourceIdentityOwnerBadgeValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///NativeResourceKind
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "Xrd",
    ///    "PackageOwnerBadge",
    ///    "AccountOwnerBadge",
    ///    "IdentityOwnerBadge",
    ///    "ValidatorOwnerBadge",
    ///    "Secp256k1SignatureResource",
    ///    "Ed25519SignatureResource",
    ///    "GlobalCallerResource",
    ///    "PackageOfDirectCallerResource",
    ///    "SystemExecutionResource",
    ///    "ValidatorLiquidStakeUnit",
    ///    "ValidatorClaimNft",
    ///    "OneResourcePoolUnit",
    ///    "TwoResourcePoolUnit",
    ///    "MultiResourcePoolUnit",
    ///    "AccessControllerRecoveryBadge"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum NativeResourceKind {
        Xrd,
        PackageOwnerBadge,
        AccountOwnerBadge,
        IdentityOwnerBadge,
        ValidatorOwnerBadge,
        Secp256k1SignatureResource,
        Ed25519SignatureResource,
        GlobalCallerResource,
        PackageOfDirectCallerResource,
        SystemExecutionResource,
        ValidatorLiquidStakeUnit,
        ValidatorClaimNft,
        OneResourcePoolUnit,
        TwoResourcePoolUnit,
        MultiResourcePoolUnit,
        AccessControllerRecoveryBadge,
    }
    impl From<&NativeResourceKind> for NativeResourceKind {
        fn from(value: &NativeResourceKind) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for NativeResourceKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Xrd => write!(f, "Xrd"),
                Self::PackageOwnerBadge => write!(f, "PackageOwnerBadge"),
                Self::AccountOwnerBadge => write!(f, "AccountOwnerBadge"),
                Self::IdentityOwnerBadge => write!(f, "IdentityOwnerBadge"),
                Self::ValidatorOwnerBadge => write!(f, "ValidatorOwnerBadge"),
                Self::Secp256k1SignatureResource => {
                    write!(f, "Secp256k1SignatureResource")
                }
                Self::Ed25519SignatureResource => write!(f, "Ed25519SignatureResource"),
                Self::GlobalCallerResource => write!(f, "GlobalCallerResource"),
                Self::PackageOfDirectCallerResource => {
                    write!(f, "PackageOfDirectCallerResource")
                }
                Self::SystemExecutionResource => write!(f, "SystemExecutionResource"),
                Self::ValidatorLiquidStakeUnit => write!(f, "ValidatorLiquidStakeUnit"),
                Self::ValidatorClaimNft => write!(f, "ValidatorClaimNft"),
                Self::OneResourcePoolUnit => write!(f, "OneResourcePoolUnit"),
                Self::TwoResourcePoolUnit => write!(f, "TwoResourcePoolUnit"),
                Self::MultiResourcePoolUnit => write!(f, "MultiResourcePoolUnit"),
                Self::AccessControllerRecoveryBadge => {
                    write!(f, "AccessControllerRecoveryBadge")
                }
            }
        }
    }
    impl std::str::FromStr for NativeResourceKind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "Xrd" => Ok(Self::Xrd),
                "PackageOwnerBadge" => Ok(Self::PackageOwnerBadge),
                "AccountOwnerBadge" => Ok(Self::AccountOwnerBadge),
                "IdentityOwnerBadge" => Ok(Self::IdentityOwnerBadge),
                "ValidatorOwnerBadge" => Ok(Self::ValidatorOwnerBadge),
                "Secp256k1SignatureResource" => Ok(Self::Secp256k1SignatureResource),
                "Ed25519SignatureResource" => Ok(Self::Ed25519SignatureResource),
                "GlobalCallerResource" => Ok(Self::GlobalCallerResource),
                "PackageOfDirectCallerResource" => {
                    Ok(Self::PackageOfDirectCallerResource)
                }
                "SystemExecutionResource" => Ok(Self::SystemExecutionResource),
                "ValidatorLiquidStakeUnit" => Ok(Self::ValidatorLiquidStakeUnit),
                "ValidatorClaimNft" => Ok(Self::ValidatorClaimNft),
                "OneResourcePoolUnit" => Ok(Self::OneResourcePoolUnit),
                "TwoResourcePoolUnit" => Ok(Self::TwoResourcePoolUnit),
                "MultiResourcePoolUnit" => Ok(Self::MultiResourcePoolUnit),
                "AccessControllerRecoveryBadge" => {
                    Ok(Self::AccessControllerRecoveryBadge)
                }
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for NativeResourceKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for NativeResourceKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for NativeResourceKind {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///NativeResourceMultiResourcePoolUnitValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/NativeResourceDetailsBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "pool_address",
    ///        "redemption_resource_count",
    ///        "unit_redemption_value"
    ///      ],
    ///      "properties": {
    ///        "kind": {
    ///          "type": "string",
    ///          "enum": [
    ///            "MultiResourcePoolUnit"
    ///          ]
    ///        },
    ///        "pool_address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "redemption_resource_count": {
    ///          "type": "integer"
    ///        },
    ///        "unit_redemption_value": {
    ///          "$ref": "#/components/schemas/NativeResourceUnitRedemptionValue"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct NativeResourceMultiResourcePoolUnitValue {
        pub kind: NativeResourceMultiResourcePoolUnitValueKind,
        pub pool_address: Address,
        pub redemption_resource_count: i64,
        pub unit_redemption_value: NativeResourceUnitRedemptionValue,
    }
    impl From<&NativeResourceMultiResourcePoolUnitValue>
    for NativeResourceMultiResourcePoolUnitValue {
        fn from(value: &NativeResourceMultiResourcePoolUnitValue) -> Self {
            value.clone()
        }
    }
    impl NativeResourceMultiResourcePoolUnitValue {
        pub fn builder() -> builder::NativeResourceMultiResourcePoolUnitValue {
            Default::default()
        }
    }
    ///NativeResourceMultiResourcePoolUnitValueKind
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "MultiResourcePoolUnit"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum NativeResourceMultiResourcePoolUnitValueKind {
        MultiResourcePoolUnit,
    }
    impl From<&NativeResourceMultiResourcePoolUnitValueKind>
    for NativeResourceMultiResourcePoolUnitValueKind {
        fn from(value: &NativeResourceMultiResourcePoolUnitValueKind) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for NativeResourceMultiResourcePoolUnitValueKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::MultiResourcePoolUnit => write!(f, "MultiResourcePoolUnit"),
            }
        }
    }
    impl std::str::FromStr for NativeResourceMultiResourcePoolUnitValueKind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "MultiResourcePoolUnit" => Ok(Self::MultiResourcePoolUnit),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for NativeResourceMultiResourcePoolUnitValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String>
    for NativeResourceMultiResourcePoolUnitValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for NativeResourceMultiResourcePoolUnitValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///NativeResourceOneResourcePoolUnitValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/NativeResourceDetailsBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "pool_address",
    ///        "redemption_resource_count",
    ///        "unit_redemption_value"
    ///      ],
    ///      "properties": {
    ///        "kind": {
    ///          "type": "string",
    ///          "enum": [
    ///            "OneResourcePoolUnit"
    ///          ]
    ///        },
    ///        "pool_address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "redemption_resource_count": {
    ///          "type": "integer"
    ///        },
    ///        "unit_redemption_value": {
    ///          "$ref": "#/components/schemas/NativeResourceUnitRedemptionValue"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct NativeResourceOneResourcePoolUnitValue {
        pub kind: NativeResourceOneResourcePoolUnitValueKind,
        pub pool_address: Address,
        pub redemption_resource_count: i64,
        pub unit_redemption_value: NativeResourceUnitRedemptionValue,
    }
    impl From<&NativeResourceOneResourcePoolUnitValue>
    for NativeResourceOneResourcePoolUnitValue {
        fn from(value: &NativeResourceOneResourcePoolUnitValue) -> Self {
            value.clone()
        }
    }
    impl NativeResourceOneResourcePoolUnitValue {
        pub fn builder() -> builder::NativeResourceOneResourcePoolUnitValue {
            Default::default()
        }
    }
    ///NativeResourceOneResourcePoolUnitValueKind
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "OneResourcePoolUnit"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum NativeResourceOneResourcePoolUnitValueKind {
        OneResourcePoolUnit,
    }
    impl From<&NativeResourceOneResourcePoolUnitValueKind>
    for NativeResourceOneResourcePoolUnitValueKind {
        fn from(value: &NativeResourceOneResourcePoolUnitValueKind) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for NativeResourceOneResourcePoolUnitValueKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::OneResourcePoolUnit => write!(f, "OneResourcePoolUnit"),
            }
        }
    }
    impl std::str::FromStr for NativeResourceOneResourcePoolUnitValueKind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "OneResourcePoolUnit" => Ok(Self::OneResourcePoolUnit),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for NativeResourceOneResourcePoolUnitValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for NativeResourceOneResourcePoolUnitValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for NativeResourceOneResourcePoolUnitValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///NativeResourcePackageOfDirectCallerResourceValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/NativeResourceDetailsBase"
    ///    },
    ///    {
    ///      "type": "object"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "properties": {
    ///        "kind": {
    ///          "type": "string",
    ///          "enum": [
    ///            "PackageOfDirectCallerResource"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct NativeResourcePackageOfDirectCallerResourceValue {
        pub kind: NativeResourcePackageOfDirectCallerResourceValueKind,
    }
    impl From<&NativeResourcePackageOfDirectCallerResourceValue>
    for NativeResourcePackageOfDirectCallerResourceValue {
        fn from(value: &NativeResourcePackageOfDirectCallerResourceValue) -> Self {
            value.clone()
        }
    }
    impl NativeResourcePackageOfDirectCallerResourceValue {
        pub fn builder() -> builder::NativeResourcePackageOfDirectCallerResourceValue {
            Default::default()
        }
    }
    ///NativeResourcePackageOfDirectCallerResourceValueKind
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "PackageOfDirectCallerResource"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum NativeResourcePackageOfDirectCallerResourceValueKind {
        PackageOfDirectCallerResource,
    }
    impl From<&NativeResourcePackageOfDirectCallerResourceValueKind>
    for NativeResourcePackageOfDirectCallerResourceValueKind {
        fn from(value: &NativeResourcePackageOfDirectCallerResourceValueKind) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for NativeResourcePackageOfDirectCallerResourceValueKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::PackageOfDirectCallerResource => {
                    write!(f, "PackageOfDirectCallerResource")
                }
            }
        }
    }
    impl std::str::FromStr for NativeResourcePackageOfDirectCallerResourceValueKind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "PackageOfDirectCallerResource" => {
                    Ok(Self::PackageOfDirectCallerResource)
                }
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str>
    for NativeResourcePackageOfDirectCallerResourceValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String>
    for NativeResourcePackageOfDirectCallerResourceValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String>
    for NativeResourcePackageOfDirectCallerResourceValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///NativeResourcePackageOwnerBadgeValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/NativeResourceDetailsBase"
    ///    },
    ///    {
    ///      "type": "object"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "properties": {
    ///        "kind": {
    ///          "type": "string",
    ///          "enum": [
    ///            "PackageOwnerBadge"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct NativeResourcePackageOwnerBadgeValue {
        pub kind: NativeResourcePackageOwnerBadgeValueKind,
    }
    impl From<&NativeResourcePackageOwnerBadgeValue>
    for NativeResourcePackageOwnerBadgeValue {
        fn from(value: &NativeResourcePackageOwnerBadgeValue) -> Self {
            value.clone()
        }
    }
    impl NativeResourcePackageOwnerBadgeValue {
        pub fn builder() -> builder::NativeResourcePackageOwnerBadgeValue {
            Default::default()
        }
    }
    ///NativeResourcePackageOwnerBadgeValueKind
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "PackageOwnerBadge"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum NativeResourcePackageOwnerBadgeValueKind {
        PackageOwnerBadge,
    }
    impl From<&NativeResourcePackageOwnerBadgeValueKind>
    for NativeResourcePackageOwnerBadgeValueKind {
        fn from(value: &NativeResourcePackageOwnerBadgeValueKind) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for NativeResourcePackageOwnerBadgeValueKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::PackageOwnerBadge => write!(f, "PackageOwnerBadge"),
            }
        }
    }
    impl std::str::FromStr for NativeResourcePackageOwnerBadgeValueKind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "PackageOwnerBadge" => Ok(Self::PackageOwnerBadge),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for NativeResourcePackageOwnerBadgeValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for NativeResourcePackageOwnerBadgeValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for NativeResourcePackageOwnerBadgeValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///NativeResourceRedemptionValueItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "resource_address"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "$ref": "#/components/schemas/BigDecimal"
    ///    },
    ///    "resource_address": {
    ///      "$ref": "#/components/schemas/Address"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct NativeResourceRedemptionValueItem {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub amount: Option<BigDecimal>,
        pub resource_address: Address,
    }
    impl From<&NativeResourceRedemptionValueItem> for NativeResourceRedemptionValueItem {
        fn from(value: &NativeResourceRedemptionValueItem) -> Self {
            value.clone()
        }
    }
    impl NativeResourceRedemptionValueItem {
        pub fn builder() -> builder::NativeResourceRedemptionValueItem {
            Default::default()
        }
    }
    ///NativeResourceSecp256k1SignatureResourceValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/NativeResourceDetailsBase"
    ///    },
    ///    {
    ///      "type": "object"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "properties": {
    ///        "kind": {
    ///          "type": "string",
    ///          "enum": [
    ///            "Secp256k1SignatureResource"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct NativeResourceSecp256k1SignatureResourceValue {
        pub kind: NativeResourceSecp256k1SignatureResourceValueKind,
    }
    impl From<&NativeResourceSecp256k1SignatureResourceValue>
    for NativeResourceSecp256k1SignatureResourceValue {
        fn from(value: &NativeResourceSecp256k1SignatureResourceValue) -> Self {
            value.clone()
        }
    }
    impl NativeResourceSecp256k1SignatureResourceValue {
        pub fn builder() -> builder::NativeResourceSecp256k1SignatureResourceValue {
            Default::default()
        }
    }
    ///NativeResourceSecp256k1SignatureResourceValueKind
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "Secp256k1SignatureResource"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum NativeResourceSecp256k1SignatureResourceValueKind {
        Secp256k1SignatureResource,
    }
    impl From<&NativeResourceSecp256k1SignatureResourceValueKind>
    for NativeResourceSecp256k1SignatureResourceValueKind {
        fn from(value: &NativeResourceSecp256k1SignatureResourceValueKind) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for NativeResourceSecp256k1SignatureResourceValueKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Secp256k1SignatureResource => {
                    write!(f, "Secp256k1SignatureResource")
                }
            }
        }
    }
    impl std::str::FromStr for NativeResourceSecp256k1SignatureResourceValueKind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "Secp256k1SignatureResource" => Ok(Self::Secp256k1SignatureResource),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str>
    for NativeResourceSecp256k1SignatureResourceValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String>
    for NativeResourceSecp256k1SignatureResourceValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String>
    for NativeResourceSecp256k1SignatureResourceValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///NativeResourceSystemExecutionResourceValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/NativeResourceDetailsBase"
    ///    },
    ///    {
    ///      "type": "object"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "properties": {
    ///        "kind": {
    ///          "type": "string",
    ///          "enum": [
    ///            "SystemExecutionResource"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct NativeResourceSystemExecutionResourceValue {
        pub kind: NativeResourceSystemExecutionResourceValueKind,
    }
    impl From<&NativeResourceSystemExecutionResourceValue>
    for NativeResourceSystemExecutionResourceValue {
        fn from(value: &NativeResourceSystemExecutionResourceValue) -> Self {
            value.clone()
        }
    }
    impl NativeResourceSystemExecutionResourceValue {
        pub fn builder() -> builder::NativeResourceSystemExecutionResourceValue {
            Default::default()
        }
    }
    ///NativeResourceSystemExecutionResourceValueKind
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "SystemExecutionResource"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum NativeResourceSystemExecutionResourceValueKind {
        SystemExecutionResource,
    }
    impl From<&NativeResourceSystemExecutionResourceValueKind>
    for NativeResourceSystemExecutionResourceValueKind {
        fn from(value: &NativeResourceSystemExecutionResourceValueKind) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for NativeResourceSystemExecutionResourceValueKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SystemExecutionResource => write!(f, "SystemExecutionResource"),
            }
        }
    }
    impl std::str::FromStr for NativeResourceSystemExecutionResourceValueKind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "SystemExecutionResource" => Ok(Self::SystemExecutionResource),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for NativeResourceSystemExecutionResourceValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String>
    for NativeResourceSystemExecutionResourceValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String>
    for NativeResourceSystemExecutionResourceValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///NativeResourceTwoResourcePoolUnitValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/NativeResourceDetailsBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "pool_address",
    ///        "redemption_resource_count",
    ///        "unit_redemption_value"
    ///      ],
    ///      "properties": {
    ///        "kind": {
    ///          "type": "string",
    ///          "enum": [
    ///            "TwoResourcePoolUnit"
    ///          ]
    ///        },
    ///        "pool_address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "redemption_resource_count": {
    ///          "type": "integer"
    ///        },
    ///        "unit_redemption_value": {
    ///          "$ref": "#/components/schemas/NativeResourceUnitRedemptionValue"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct NativeResourceTwoResourcePoolUnitValue {
        pub kind: NativeResourceTwoResourcePoolUnitValueKind,
        pub pool_address: Address,
        pub redemption_resource_count: i64,
        pub unit_redemption_value: NativeResourceUnitRedemptionValue,
    }
    impl From<&NativeResourceTwoResourcePoolUnitValue>
    for NativeResourceTwoResourcePoolUnitValue {
        fn from(value: &NativeResourceTwoResourcePoolUnitValue) -> Self {
            value.clone()
        }
    }
    impl NativeResourceTwoResourcePoolUnitValue {
        pub fn builder() -> builder::NativeResourceTwoResourcePoolUnitValue {
            Default::default()
        }
    }
    ///NativeResourceTwoResourcePoolUnitValueKind
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "TwoResourcePoolUnit"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum NativeResourceTwoResourcePoolUnitValueKind {
        TwoResourcePoolUnit,
    }
    impl From<&NativeResourceTwoResourcePoolUnitValueKind>
    for NativeResourceTwoResourcePoolUnitValueKind {
        fn from(value: &NativeResourceTwoResourcePoolUnitValueKind) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for NativeResourceTwoResourcePoolUnitValueKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TwoResourcePoolUnit => write!(f, "TwoResourcePoolUnit"),
            }
        }
    }
    impl std::str::FromStr for NativeResourceTwoResourcePoolUnitValueKind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "TwoResourcePoolUnit" => Ok(Self::TwoResourcePoolUnit),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for NativeResourceTwoResourcePoolUnitValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for NativeResourceTwoResourcePoolUnitValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for NativeResourceTwoResourcePoolUnitValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///NativeResourceUnitRedemptionValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "array",
    ///  "items": {
    ///    "$ref": "#/components/schemas/NativeResourceRedemptionValueItem"
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct NativeResourceUnitRedemptionValue(
        pub Vec<NativeResourceRedemptionValueItem>,
    );
    impl ::std::ops::Deref for NativeResourceUnitRedemptionValue {
        type Target = Vec<NativeResourceRedemptionValueItem>;
        fn deref(&self) -> &Vec<NativeResourceRedemptionValueItem> {
            &self.0
        }
    }
    impl From<NativeResourceUnitRedemptionValue>
    for Vec<NativeResourceRedemptionValueItem> {
        fn from(value: NativeResourceUnitRedemptionValue) -> Self {
            value.0
        }
    }
    impl From<&NativeResourceUnitRedemptionValue> for NativeResourceUnitRedemptionValue {
        fn from(value: &NativeResourceUnitRedemptionValue) -> Self {
            value.clone()
        }
    }
    impl From<Vec<NativeResourceRedemptionValueItem>>
    for NativeResourceUnitRedemptionValue {
        fn from(value: Vec<NativeResourceRedemptionValueItem>) -> Self {
            Self(value)
        }
    }
    ///NativeResourceValidatorClaimNftValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/NativeResourceDetailsBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "validator_address"
    ///      ],
    ///      "properties": {
    ///        "kind": {
    ///          "type": "string",
    ///          "enum": [
    ///            "ValidatorClaimNft"
    ///          ]
    ///        },
    ///        "validator_address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct NativeResourceValidatorClaimNftValue {
        pub kind: NativeResourceValidatorClaimNftValueKind,
        pub validator_address: Address,
    }
    impl From<&NativeResourceValidatorClaimNftValue>
    for NativeResourceValidatorClaimNftValue {
        fn from(value: &NativeResourceValidatorClaimNftValue) -> Self {
            value.clone()
        }
    }
    impl NativeResourceValidatorClaimNftValue {
        pub fn builder() -> builder::NativeResourceValidatorClaimNftValue {
            Default::default()
        }
    }
    ///NativeResourceValidatorClaimNftValueKind
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ValidatorClaimNft"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum NativeResourceValidatorClaimNftValueKind {
        ValidatorClaimNft,
    }
    impl From<&NativeResourceValidatorClaimNftValueKind>
    for NativeResourceValidatorClaimNftValueKind {
        fn from(value: &NativeResourceValidatorClaimNftValueKind) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for NativeResourceValidatorClaimNftValueKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::ValidatorClaimNft => write!(f, "ValidatorClaimNft"),
            }
        }
    }
    impl std::str::FromStr for NativeResourceValidatorClaimNftValueKind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ValidatorClaimNft" => Ok(Self::ValidatorClaimNft),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for NativeResourceValidatorClaimNftValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for NativeResourceValidatorClaimNftValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for NativeResourceValidatorClaimNftValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///NativeResourceValidatorLiquidStakeUnitValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/NativeResourceDetailsBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "redemption_resource_count",
    ///        "unit_redemption_value",
    ///        "validator_address"
    ///      ],
    ///      "properties": {
    ///        "kind": {
    ///          "type": "string",
    ///          "enum": [
    ///            "ValidatorLiquidStakeUnit"
    ///          ]
    ///        },
    ///        "redemption_resource_count": {
    ///          "type": "integer"
    ///        },
    ///        "unit_redemption_value": {
    ///          "$ref": "#/components/schemas/NativeResourceUnitRedemptionValue"
    ///        },
    ///        "validator_address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct NativeResourceValidatorLiquidStakeUnitValue {
        pub kind: NativeResourceValidatorLiquidStakeUnitValueKind,
        pub redemption_resource_count: i64,
        pub unit_redemption_value: NativeResourceUnitRedemptionValue,
        pub validator_address: Address,
    }
    impl From<&NativeResourceValidatorLiquidStakeUnitValue>
    for NativeResourceValidatorLiquidStakeUnitValue {
        fn from(value: &NativeResourceValidatorLiquidStakeUnitValue) -> Self {
            value.clone()
        }
    }
    impl NativeResourceValidatorLiquidStakeUnitValue {
        pub fn builder() -> builder::NativeResourceValidatorLiquidStakeUnitValue {
            Default::default()
        }
    }
    ///NativeResourceValidatorLiquidStakeUnitValueKind
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ValidatorLiquidStakeUnit"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum NativeResourceValidatorLiquidStakeUnitValueKind {
        ValidatorLiquidStakeUnit,
    }
    impl From<&NativeResourceValidatorLiquidStakeUnitValueKind>
    for NativeResourceValidatorLiquidStakeUnitValueKind {
        fn from(value: &NativeResourceValidatorLiquidStakeUnitValueKind) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for NativeResourceValidatorLiquidStakeUnitValueKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::ValidatorLiquidStakeUnit => write!(f, "ValidatorLiquidStakeUnit"),
            }
        }
    }
    impl std::str::FromStr for NativeResourceValidatorLiquidStakeUnitValueKind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ValidatorLiquidStakeUnit" => Ok(Self::ValidatorLiquidStakeUnit),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str>
    for NativeResourceValidatorLiquidStakeUnitValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String>
    for NativeResourceValidatorLiquidStakeUnitValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String>
    for NativeResourceValidatorLiquidStakeUnitValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///NativeResourceValidatorOwnerBadgeValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/NativeResourceDetailsBase"
    ///    },
    ///    {
    ///      "type": "object"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "properties": {
    ///        "kind": {
    ///          "type": "string",
    ///          "enum": [
    ///            "ValidatorOwnerBadge"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct NativeResourceValidatorOwnerBadgeValue {
        pub kind: NativeResourceValidatorOwnerBadgeValueKind,
    }
    impl From<&NativeResourceValidatorOwnerBadgeValue>
    for NativeResourceValidatorOwnerBadgeValue {
        fn from(value: &NativeResourceValidatorOwnerBadgeValue) -> Self {
            value.clone()
        }
    }
    impl NativeResourceValidatorOwnerBadgeValue {
        pub fn builder() -> builder::NativeResourceValidatorOwnerBadgeValue {
            Default::default()
        }
    }
    ///NativeResourceValidatorOwnerBadgeValueKind
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ValidatorOwnerBadge"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum NativeResourceValidatorOwnerBadgeValueKind {
        ValidatorOwnerBadge,
    }
    impl From<&NativeResourceValidatorOwnerBadgeValueKind>
    for NativeResourceValidatorOwnerBadgeValueKind {
        fn from(value: &NativeResourceValidatorOwnerBadgeValueKind) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for NativeResourceValidatorOwnerBadgeValueKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::ValidatorOwnerBadge => write!(f, "ValidatorOwnerBadge"),
            }
        }
    }
    impl std::str::FromStr for NativeResourceValidatorOwnerBadgeValueKind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ValidatorOwnerBadge" => Ok(Self::ValidatorOwnerBadge),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for NativeResourceValidatorOwnerBadgeValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for NativeResourceValidatorOwnerBadgeValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for NativeResourceValidatorOwnerBadgeValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///NativeResourceXrdValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/NativeResourceDetailsBase"
    ///    },
    ///    {
    ///      "type": "object"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "properties": {
    ///        "kind": {
    ///          "type": "string",
    ///          "enum": [
    ///            "Xrd"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct NativeResourceXrdValue {
        pub kind: NativeResourceXrdValueKind,
    }
    impl From<&NativeResourceXrdValue> for NativeResourceXrdValue {
        fn from(value: &NativeResourceXrdValue) -> Self {
            value.clone()
        }
    }
    impl NativeResourceXrdValue {
        pub fn builder() -> builder::NativeResourceXrdValue {
            Default::default()
        }
    }
    ///NativeResourceXrdValueKind
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "Xrd"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum NativeResourceXrdValueKind {
        Xrd,
    }
    impl From<&NativeResourceXrdValueKind> for NativeResourceXrdValueKind {
        fn from(value: &NativeResourceXrdValueKind) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for NativeResourceXrdValueKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Xrd => write!(f, "Xrd"),
            }
        }
    }
    impl std::str::FromStr for NativeResourceXrdValueKind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "Xrd" => Ok(Self::Xrd),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for NativeResourceXrdValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for NativeResourceXrdValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for NativeResourceXrdValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///NetworkConfigurationResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "network_id",
    ///    "network_name",
    ///    "well_known_addresses"
    ///  ],
    ///  "properties": {
    ///    "network_id": {
    ///      "$ref": "#/components/schemas/NetworkId"
    ///    },
    ///    "network_name": {
    ///      "$ref": "#/components/schemas/NetworkName"
    ///    },
    ///    "well_known_addresses": {
    ///      "type": "object",
    ///      "required": [
    ///        "access_controller_package",
    ///        "access_rules_package",
    ///        "account_owner_badge",
    ///        "account_package",
    ///        "consensus_manager",
    ///        "consensus_manager_package",
    ///        "ed25519_signature_virtual_badge",
    ///        "faucet",
    ///        "faucet_package",
    ///        "genesis_helper",
    ///        "genesis_helper_package",
    ///        "global_caller_virtual_badge",
    ///        "identity_owner_badge",
    ///        "identity_package",
    ///        "locker_package",
    ///        "metadata_module_package",
    ///        "package_of_direct_caller_virtual_badge",
    ///        "package_owner_badge",
    ///        "package_package",
    ///        "pool_package",
    ///        "resource_package",
    ///        "role_assignment_module_package",
    ///        "royalty_module_package",
    ///        "secp256k1_signature_virtual_badge",
    ///        "system_transaction_badge",
    ///        "transaction_processor_package",
    ///        "transaction_tracker",
    ///        "validator_owner_badge",
    ///        "xrd"
    ///      ],
    ///      "properties": {
    ///        "access_controller_package": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "access_rules_package": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "account_owner_badge": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "account_package": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "consensus_manager": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "consensus_manager_package": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "ed25519_signature_virtual_badge": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "faucet": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "faucet_package": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "genesis_helper": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "genesis_helper_package": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "global_caller_virtual_badge": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "identity_owner_badge": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "identity_package": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "locker_package": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "metadata_module_package": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "package_of_direct_caller_virtual_badge": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "package_owner_badge": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "package_package": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "pool_package": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "resource_package": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "role_assignment_module_package": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "royalty_module_package": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "secp256k1_signature_virtual_badge": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "system_transaction_badge": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "test_utils_package": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "transaction_processor_package": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "transaction_tracker": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "transaction_tracker_package": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "validator_owner_badge": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "xrd": {
    ///          "$ref": "#/components/schemas/Address"
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct NetworkConfigurationResponse {
        pub network_id: NetworkId,
        pub network_name: NetworkName,
        pub well_known_addresses: NetworkConfigurationResponseWellKnownAddresses,
    }
    impl From<&NetworkConfigurationResponse> for NetworkConfigurationResponse {
        fn from(value: &NetworkConfigurationResponse) -> Self {
            value.clone()
        }
    }
    impl NetworkConfigurationResponse {
        pub fn builder() -> builder::NetworkConfigurationResponse {
            Default::default()
        }
    }
    ///NetworkConfigurationResponseWellKnownAddresses
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "access_controller_package",
    ///    "access_rules_package",
    ///    "account_owner_badge",
    ///    "account_package",
    ///    "consensus_manager",
    ///    "consensus_manager_package",
    ///    "ed25519_signature_virtual_badge",
    ///    "faucet",
    ///    "faucet_package",
    ///    "genesis_helper",
    ///    "genesis_helper_package",
    ///    "global_caller_virtual_badge",
    ///    "identity_owner_badge",
    ///    "identity_package",
    ///    "locker_package",
    ///    "metadata_module_package",
    ///    "package_of_direct_caller_virtual_badge",
    ///    "package_owner_badge",
    ///    "package_package",
    ///    "pool_package",
    ///    "resource_package",
    ///    "role_assignment_module_package",
    ///    "royalty_module_package",
    ///    "secp256k1_signature_virtual_badge",
    ///    "system_transaction_badge",
    ///    "transaction_processor_package",
    ///    "transaction_tracker",
    ///    "validator_owner_badge",
    ///    "xrd"
    ///  ],
    ///  "properties": {
    ///    "access_controller_package": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "access_rules_package": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "account_owner_badge": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "account_package": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "consensus_manager": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "consensus_manager_package": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "ed25519_signature_virtual_badge": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "faucet": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "faucet_package": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "genesis_helper": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "genesis_helper_package": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "global_caller_virtual_badge": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "identity_owner_badge": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "identity_package": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "locker_package": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "metadata_module_package": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "package_of_direct_caller_virtual_badge": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "package_owner_badge": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "package_package": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "pool_package": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "resource_package": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "role_assignment_module_package": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "royalty_module_package": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "secp256k1_signature_virtual_badge": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "system_transaction_badge": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "test_utils_package": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "transaction_processor_package": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "transaction_tracker": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "transaction_tracker_package": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "validator_owner_badge": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "xrd": {
    ///      "$ref": "#/components/schemas/Address"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct NetworkConfigurationResponseWellKnownAddresses {
        pub access_controller_package: Address,
        pub access_rules_package: Address,
        pub account_owner_badge: Address,
        pub account_package: Address,
        pub consensus_manager: Address,
        pub consensus_manager_package: Address,
        pub ed25519_signature_virtual_badge: Address,
        pub faucet: Address,
        pub faucet_package: Address,
        pub genesis_helper: Address,
        pub genesis_helper_package: Address,
        pub global_caller_virtual_badge: Address,
        pub identity_owner_badge: Address,
        pub identity_package: Address,
        pub locker_package: Address,
        pub metadata_module_package: Address,
        pub package_of_direct_caller_virtual_badge: Address,
        pub package_owner_badge: Address,
        pub package_package: Address,
        pub pool_package: Address,
        pub resource_package: Address,
        pub role_assignment_module_package: Address,
        pub royalty_module_package: Address,
        pub secp256k1_signature_virtual_badge: Address,
        pub system_transaction_badge: Address,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub test_utils_package: Option<Address>,
        pub transaction_processor_package: Address,
        pub transaction_tracker: Address,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub transaction_tracker_package: Option<Address>,
        pub validator_owner_badge: Address,
        pub xrd: Address,
    }
    impl From<&NetworkConfigurationResponseWellKnownAddresses>
    for NetworkConfigurationResponseWellKnownAddresses {
        fn from(value: &NetworkConfigurationResponseWellKnownAddresses) -> Self {
            value.clone()
        }
    }
    impl NetworkConfigurationResponseWellKnownAddresses {
        pub fn builder() -> builder::NetworkConfigurationResponseWellKnownAddresses {
            Default::default()
        }
    }
    ///The logical id of the network
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The logical id of the network",
    ///  "examples": [
    ///    "<network-id>"
    ///  ],
    ///  "type": "integer",
    ///  "format": "int32",
    ///  "maximum": 255.0,
    ///  "minimum": 0.0
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct NetworkId(pub u8);
    impl ::std::ops::Deref for NetworkId {
        type Target = u8;
        fn deref(&self) -> &u8 {
            &self.0
        }
    }
    impl From<NetworkId> for u8 {
        fn from(value: NetworkId) -> Self {
            value.0
        }
    }
    impl From<&NetworkId> for NetworkId {
        fn from(value: &NetworkId) -> Self {
            value.clone()
        }
    }
    impl From<u8> for NetworkId {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }
    impl std::str::FromStr for NetworkId {
        type Err = <u8 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }
    impl std::convert::TryFrom<&str> for NetworkId {
        type Error = <u8 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for NetworkId {
        type Error = <u8 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for NetworkId {
        type Error = <u8 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }
    impl ::std::fmt::Display for NetworkId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }
    ///The logical name of the network
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The logical name of the network",
    ///  "examples": [
    ///    "<network-name>"
    ///  ],
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub struct NetworkName(pub String);
    impl ::std::ops::Deref for NetworkName {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<NetworkName> for String {
        fn from(value: NetworkName) -> Self {
            value.0
        }
    }
    impl From<&NetworkName> for NetworkName {
        fn from(value: &NetworkName) -> Self {
            value.clone()
        }
    }
    impl From<String> for NetworkName {
        fn from(value: String) -> Self {
            Self(value)
        }
    }
    impl std::str::FromStr for NetworkName {
        type Err = std::convert::Infallible;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::fmt::Display for NetworkName {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }
    ///String-encoded non-fungible ID.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "String-encoded non-fungible ID.",
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub struct NonFungibleId(pub String);
    impl ::std::ops::Deref for NonFungibleId {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<NonFungibleId> for String {
        fn from(value: NonFungibleId) -> Self {
            value.0
        }
    }
    impl From<&NonFungibleId> for NonFungibleId {
        fn from(value: &NonFungibleId) -> Self {
            value.clone()
        }
    }
    impl From<String> for NonFungibleId {
        fn from(value: String) -> Self {
            Self(value)
        }
    }
    impl std::str::FromStr for NonFungibleId {
        type Err = std::convert::Infallible;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::fmt::Display for NonFungibleId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }
    ///NonFungibleIdType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "String",
    ///    "Integer",
    ///    "Bytes",
    ///    "Ruid"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum NonFungibleIdType {
        String,
        Integer,
        Bytes,
        Ruid,
    }
    impl From<&NonFungibleIdType> for NonFungibleIdType {
        fn from(value: &NonFungibleIdType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for NonFungibleIdType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::String => write!(f, "String"),
                Self::Integer => write!(f, "Integer"),
                Self::Bytes => write!(f, "Bytes"),
                Self::Ruid => write!(f, "Ruid"),
            }
        }
    }
    impl std::str::FromStr for NonFungibleIdType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "String" => Ok(Self::String),
                "Integer" => Ok(Self::Integer),
                "Bytes" => Ok(Self::Bytes),
                "Ruid" => Ok(Self::Ruid),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for NonFungibleIdType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for NonFungibleIdType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for NonFungibleIdType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///Non-fungible resource IDs collection.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Non-fungible resource IDs collection.",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ResultSetCursorMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "items"
    ///      ],
    ///      "properties": {
    ///        "items": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/NonFungibleId"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct NonFungibleIdsCollection {
        pub items: Vec<NonFungibleId>,
        ///If specified, contains a cursor to query next page of the `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_cursor: Option<String>,
        ///Total number of items in underlying collection, fragment of which is available in `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_count: Option<i64>,
    }
    impl From<&NonFungibleIdsCollection> for NonFungibleIdsCollection {
        fn from(value: &NonFungibleIdsCollection) -> Self {
            value.clone()
        }
    }
    impl NonFungibleIdsCollection {
        pub fn builder() -> builder::NonFungibleIdsCollection {
            Default::default()
        }
    }
    ///Non-fungible resources collection.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Non-fungible resources collection.",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ResultSetCursorMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "items"
    ///      ],
    ///      "properties": {
    ///        "items": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/NonFungibleResourcesCollectionItem"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct NonFungibleResourcesCollection {
        pub items: Vec<NonFungibleResourcesCollectionItem>,
        ///If specified, contains a cursor to query next page of the `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_cursor: Option<String>,
        ///Total number of items in underlying collection, fragment of which is available in `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_count: Option<i64>,
    }
    impl From<&NonFungibleResourcesCollection> for NonFungibleResourcesCollection {
        fn from(value: &NonFungibleResourcesCollection) -> Self {
            value.clone()
        }
    }
    impl NonFungibleResourcesCollection {
        pub fn builder() -> builder::NonFungibleResourcesCollection {
            Default::default()
        }
    }
    ///NonFungibleResourcesCollectionItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/NonFungibleResourcesCollectionItemGloballyAggregated"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/NonFungibleResourcesCollectionItemVaultAggregated"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum NonFungibleResourcesCollectionItem {
        GloballyAggregated(NonFungibleResourcesCollectionItemGloballyAggregated),
        VaultAggregated(NonFungibleResourcesCollectionItemVaultAggregated),
    }
    impl From<&NonFungibleResourcesCollectionItem>
    for NonFungibleResourcesCollectionItem {
        fn from(value: &NonFungibleResourcesCollectionItem) -> Self {
            value.clone()
        }
    }
    impl From<NonFungibleResourcesCollectionItemGloballyAggregated>
    for NonFungibleResourcesCollectionItem {
        fn from(value: NonFungibleResourcesCollectionItemGloballyAggregated) -> Self {
            Self::GloballyAggregated(value)
        }
    }
    impl From<NonFungibleResourcesCollectionItemVaultAggregated>
    for NonFungibleResourcesCollectionItem {
        fn from(value: NonFungibleResourcesCollectionItemVaultAggregated) -> Self {
            Self::VaultAggregated(value)
        }
    }
    ///NonFungibleResourcesCollectionItemBase
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "aggregation_level",
    ///    "resource_address"
    ///  ],
    ///  "properties": {
    ///    "aggregation_level": {
    ///      "$ref": "#/components/schemas/ResourceAggregationLevel"
    ///    },
    ///    "explicit_metadata": {
    ///      "$ref": "#/components/schemas/EntityMetadataCollection"
    ///    },
    ///    "resource_address": {
    ///      "$ref": "#/components/schemas/Address"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct NonFungibleResourcesCollectionItemBase {
        pub aggregation_level: ResourceAggregationLevel,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub explicit_metadata: Option<EntityMetadataCollection>,
        pub resource_address: Address,
    }
    impl From<&NonFungibleResourcesCollectionItemBase>
    for NonFungibleResourcesCollectionItemBase {
        fn from(value: &NonFungibleResourcesCollectionItemBase) -> Self {
            value.clone()
        }
    }
    impl NonFungibleResourcesCollectionItemBase {
        pub fn builder() -> builder::NonFungibleResourcesCollectionItemBase {
            Default::default()
        }
    }
    ///NonFungibleResourcesCollectionItemGloballyAggregated
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/NonFungibleResourcesCollectionItemBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "amount",
    ///        "last_updated_at_state_version"
    ///      ],
    ///      "properties": {
    ///        "aggregation_level": {
    ///          "type": "string",
    ///          "enum": [
    ///            "Global"
    ///          ]
    ///        },
    ///        "amount": {
    ///          "description": "The total amount of non-fungible IDs across all vaults.",
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "last_updated_at_state_version": {
    ///          "$ref": "#/components/schemas/LastUpdatedAtStateVersion"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct NonFungibleResourcesCollectionItemGloballyAggregated {
        pub aggregation_level: NonFungibleResourcesCollectionItemGloballyAggregatedAggregationLevel,
        ///The total amount of non-fungible IDs across all vaults.
        pub amount: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub explicit_metadata: Option<EntityMetadataCollection>,
        pub last_updated_at_state_version: LastUpdatedAtStateVersion,
        pub resource_address: Address,
    }
    impl From<&NonFungibleResourcesCollectionItemGloballyAggregated>
    for NonFungibleResourcesCollectionItemGloballyAggregated {
        fn from(value: &NonFungibleResourcesCollectionItemGloballyAggregated) -> Self {
            value.clone()
        }
    }
    impl NonFungibleResourcesCollectionItemGloballyAggregated {
        pub fn builder() -> builder::NonFungibleResourcesCollectionItemGloballyAggregated {
            Default::default()
        }
    }
    ///NonFungibleResourcesCollectionItemGloballyAggregatedAggregationLevel
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "Global"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum NonFungibleResourcesCollectionItemGloballyAggregatedAggregationLevel {
        Global,
    }
    impl From<&NonFungibleResourcesCollectionItemGloballyAggregatedAggregationLevel>
    for NonFungibleResourcesCollectionItemGloballyAggregatedAggregationLevel {
        fn from(
            value: &NonFungibleResourcesCollectionItemGloballyAggregatedAggregationLevel,
        ) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display
    for NonFungibleResourcesCollectionItemGloballyAggregatedAggregationLevel {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Global => write!(f, "Global"),
            }
        }
    }
    impl std::str::FromStr
    for NonFungibleResourcesCollectionItemGloballyAggregatedAggregationLevel {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "Global" => Ok(Self::Global),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str>
    for NonFungibleResourcesCollectionItemGloballyAggregatedAggregationLevel {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String>
    for NonFungibleResourcesCollectionItemGloballyAggregatedAggregationLevel {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String>
    for NonFungibleResourcesCollectionItemGloballyAggregatedAggregationLevel {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///NonFungibleResourcesCollectionItemVaultAggregated
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/NonFungibleResourcesCollectionItemBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "vaults"
    ///      ],
    ///      "properties": {
    ///        "aggregation_level": {
    ///          "type": "string",
    ///          "enum": [
    ///            "Vault"
    ///          ]
    ///        },
    ///        "vaults": {
    ///          "$ref": "#/components/schemas/NonFungibleResourcesCollectionItemVaultAggregatedVault"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct NonFungibleResourcesCollectionItemVaultAggregated {
        pub aggregation_level: NonFungibleResourcesCollectionItemVaultAggregatedAggregationLevel,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub explicit_metadata: Option<EntityMetadataCollection>,
        pub resource_address: Address,
        pub vaults: NonFungibleResourcesCollectionItemVaultAggregatedVault,
    }
    impl From<&NonFungibleResourcesCollectionItemVaultAggregated>
    for NonFungibleResourcesCollectionItemVaultAggregated {
        fn from(value: &NonFungibleResourcesCollectionItemVaultAggregated) -> Self {
            value.clone()
        }
    }
    impl NonFungibleResourcesCollectionItemVaultAggregated {
        pub fn builder() -> builder::NonFungibleResourcesCollectionItemVaultAggregated {
            Default::default()
        }
    }
    ///NonFungibleResourcesCollectionItemVaultAggregatedAggregationLevel
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "Vault"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum NonFungibleResourcesCollectionItemVaultAggregatedAggregationLevel {
        Vault,
    }
    impl From<&NonFungibleResourcesCollectionItemVaultAggregatedAggregationLevel>
    for NonFungibleResourcesCollectionItemVaultAggregatedAggregationLevel {
        fn from(
            value: &NonFungibleResourcesCollectionItemVaultAggregatedAggregationLevel,
        ) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display
    for NonFungibleResourcesCollectionItemVaultAggregatedAggregationLevel {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Vault => write!(f, "Vault"),
            }
        }
    }
    impl std::str::FromStr
    for NonFungibleResourcesCollectionItemVaultAggregatedAggregationLevel {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "Vault" => Ok(Self::Vault),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str>
    for NonFungibleResourcesCollectionItemVaultAggregatedAggregationLevel {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String>
    for NonFungibleResourcesCollectionItemVaultAggregatedAggregationLevel {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String>
    for NonFungibleResourcesCollectionItemVaultAggregatedAggregationLevel {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///NonFungibleResourcesCollectionItemVaultAggregatedVault
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ResultSetCursorMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "items"
    ///      ],
    ///      "properties": {
    ///        "items": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/NonFungibleResourcesCollectionItemVaultAggregatedVaultItem"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct NonFungibleResourcesCollectionItemVaultAggregatedVault {
        pub items: Vec<NonFungibleResourcesCollectionItemVaultAggregatedVaultItem>,
        ///If specified, contains a cursor to query next page of the `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_cursor: Option<String>,
        ///Total number of items in underlying collection, fragment of which is available in `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_count: Option<i64>,
    }
    impl From<&NonFungibleResourcesCollectionItemVaultAggregatedVault>
    for NonFungibleResourcesCollectionItemVaultAggregatedVault {
        fn from(value: &NonFungibleResourcesCollectionItemVaultAggregatedVault) -> Self {
            value.clone()
        }
    }
    impl NonFungibleResourcesCollectionItemVaultAggregatedVault {
        pub fn builder() -> builder::NonFungibleResourcesCollectionItemVaultAggregatedVault {
            Default::default()
        }
    }
    ///NonFungibleResourcesCollectionItemVaultAggregatedVaultItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/OptionalNonFungibleIdsCollection"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "last_updated_at_state_version",
    ///        "total_count",
    ///        "vault_address"
    ///      ],
    ///      "properties": {
    ///        "last_updated_at_state_version": {
    ///          "$ref": "#/components/schemas/LastUpdatedAtStateVersion"
    ///        },
    ///        "total_count": {
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "vault_address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct NonFungibleResourcesCollectionItemVaultAggregatedVaultItem {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub items: Vec<NonFungibleId>,
        pub last_updated_at_state_version: LastUpdatedAtStateVersion,
        ///If specified, contains a cursor to query next page of the `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_cursor: Option<String>,
        pub total_count: i64,
        pub vault_address: Address,
    }
    impl From<&NonFungibleResourcesCollectionItemVaultAggregatedVaultItem>
    for NonFungibleResourcesCollectionItemVaultAggregatedVaultItem {
        fn from(
            value: &NonFungibleResourcesCollectionItemVaultAggregatedVaultItem,
        ) -> Self {
            value.clone()
        }
    }
    impl NonFungibleResourcesCollectionItemVaultAggregatedVaultItem {
        pub fn builder() -> builder::NonFungibleResourcesCollectionItemVaultAggregatedVaultItem {
            Default::default()
        }
    }
    ///NotSyncedUpError
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/GatewayErrorBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "current_sync_delay_seconds",
    ///        "max_allowed_sync_delay_seconds",
    ///        "request_type"
    ///      ],
    ///      "properties": {
    ///        "current_sync_delay_seconds": {
    ///          "description": "The current delay between the Gateway DB and the network ledger round timestamp.",
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "max_allowed_sync_delay_seconds": {
    ///          "description": "The maximum allowed delay between the Gateway DB and the network ledger round timestamp for this `request_type`.",
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "request_type": {
    ///          "description": "The request type that triggered this exception.",
    ///          "type": "string"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "NotSyncedUpError"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct NotSyncedUpError {
        ///The current delay between the Gateway DB and the network ledger round timestamp.
        pub current_sync_delay_seconds: i64,
        ///The maximum allowed delay between the Gateway DB and the network ledger round timestamp for this `request_type`.
        pub max_allowed_sync_delay_seconds: i64,
        ///The request type that triggered this exception.
        pub request_type: String,
        #[serde(rename = "type")]
        pub type_: NotSyncedUpErrorType,
    }
    impl From<&NotSyncedUpError> for NotSyncedUpError {
        fn from(value: &NotSyncedUpError) -> Self {
            value.clone()
        }
    }
    impl NotSyncedUpError {
        pub fn builder() -> builder::NotSyncedUpError {
            Default::default()
        }
    }
    ///NotSyncedUpErrorType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "NotSyncedUpError"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum NotSyncedUpErrorType {
        NotSyncedUpError,
    }
    impl From<&NotSyncedUpErrorType> for NotSyncedUpErrorType {
        fn from(value: &NotSyncedUpErrorType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for NotSyncedUpErrorType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::NotSyncedUpError => write!(f, "NotSyncedUpError"),
            }
        }
    }
    impl std::str::FromStr for NotSyncedUpErrorType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "NotSyncedUpError" => Ok(Self::NotSyncedUpError),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for NotSyncedUpErrorType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for NotSyncedUpErrorType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for NotSyncedUpErrorType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///Hex-encoded notarized transaction payload which can be submitted.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Hex-encoded notarized transaction payload which can be submitted.",
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub struct NotarizedTransactionHexString(pub String);
    impl ::std::ops::Deref for NotarizedTransactionHexString {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<NotarizedTransactionHexString> for String {
        fn from(value: NotarizedTransactionHexString) -> Self {
            value.0
        }
    }
    impl From<&NotarizedTransactionHexString> for NotarizedTransactionHexString {
        fn from(value: &NotarizedTransactionHexString) -> Self {
            value.clone()
        }
    }
    impl From<String> for NotarizedTransactionHexString {
        fn from(value: String) -> Self {
            Self(value)
        }
    }
    impl std::str::FromStr for NotarizedTransactionHexString {
        type Err = std::convert::Infallible;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::fmt::Display for NotarizedTransactionHexString {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }
    ///ObjectModuleId
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "Main",
    ///    "Metadata",
    ///    "Royalty",
    ///    "RoleAssignment"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum ObjectModuleId {
        Main,
        Metadata,
        Royalty,
        RoleAssignment,
    }
    impl From<&ObjectModuleId> for ObjectModuleId {
        fn from(value: &ObjectModuleId) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for ObjectModuleId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Main => write!(f, "Main"),
                Self::Metadata => write!(f, "Metadata"),
                Self::Royalty => write!(f, "Royalty"),
                Self::RoleAssignment => write!(f, "RoleAssignment"),
            }
        }
    }
    impl std::str::FromStr for ObjectModuleId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "Main" => Ok(Self::Main),
                "Metadata" => Ok(Self::Metadata),
                "Royalty" => Ok(Self::Royalty),
                "RoleAssignment" => Ok(Self::RoleAssignment),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for ObjectModuleId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for ObjectModuleId {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for ObjectModuleId {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///Non-fungible resource IDs collection.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Non-fungible resource IDs collection.",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ResultSetCursorMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "properties": {
    ///        "items": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/NonFungibleId"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct OptionalNonFungibleIdsCollection {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub items: Vec<NonFungibleId>,
        ///If specified, contains a cursor to query next page of the `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_cursor: Option<String>,
        ///Total number of items in underlying collection, fragment of which is available in `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_count: Option<i64>,
    }
    impl From<&OptionalNonFungibleIdsCollection> for OptionalNonFungibleIdsCollection {
        fn from(value: &OptionalNonFungibleIdsCollection) -> Self {
            value.clone()
        }
    }
    impl OptionalNonFungibleIdsCollection {
        pub fn builder() -> builder::OptionalNonFungibleIdsCollection {
            Default::default()
        }
    }
    ///Package blueprint collection.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Package blueprint collection.",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ResultSetCursorMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "items"
    ///      ],
    ///      "properties": {
    ///        "items": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/PackageBlueprintCollectionItem"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PackageBlueprintCollection {
        pub items: Vec<PackageBlueprintCollectionItem>,
        ///If specified, contains a cursor to query next page of the `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_cursor: Option<String>,
        ///Total number of items in underlying collection, fragment of which is available in `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_count: Option<i64>,
    }
    impl From<&PackageBlueprintCollection> for PackageBlueprintCollection {
        fn from(value: &PackageBlueprintCollection) -> Self {
            value.clone()
        }
    }
    impl PackageBlueprintCollection {
        pub fn builder() -> builder::PackageBlueprintCollection {
            Default::default()
        }
    }
    ///PackageBlueprintCollectionItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "definition",
    ///    "name",
    ///    "version"
    ///  ],
    ///  "properties": {
    ///    "auth_template": {
    ///      "description": "This type is defined in the Core API as `AuthConfig`. See the Core API documentation for more details.\n",
    ///      "type": "object"
    ///    },
    ///    "auth_template_is_locked": {
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "definition": {
    ///      "description": "This type is defined in the Core API as `BlueprintDefinition`. See the Core API documentation for more details.\n",
    ///      "type": "object"
    ///    },
    ///    "dependant_entities": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Address"
    ///      }
    ///    },
    ///    "name": {
    ///      "type": "string"
    ///    },
    ///    "royalty_config": {
    ///      "$ref": "#/components/schemas/BlueprintRoyaltyConfig"
    ///    },
    ///    "royalty_config_is_locked": {
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "version": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PackageBlueprintCollectionItem {
        /**This type is defined in the Core API as `AuthConfig`. See the Core API documentation for more details.
*/
        #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
        pub auth_template: ::serde_json::Map<String, ::serde_json::Value>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub auth_template_is_locked: Option<bool>,
        /**This type is defined in the Core API as `BlueprintDefinition`. See the Core API documentation for more details.
*/
        pub definition: ::serde_json::Map<String, ::serde_json::Value>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub dependant_entities: Vec<Address>,
        pub name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub royalty_config: Option<BlueprintRoyaltyConfig>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub royalty_config_is_locked: Option<bool>,
        pub version: String,
    }
    impl From<&PackageBlueprintCollectionItem> for PackageBlueprintCollectionItem {
        fn from(value: &PackageBlueprintCollectionItem) -> Self {
            value.clone()
        }
    }
    impl PackageBlueprintCollectionItem {
        pub fn builder() -> builder::PackageBlueprintCollectionItem {
            Default::default()
        }
    }
    ///Package code collection.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Package code collection.",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ResultSetCursorMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "items"
    ///      ],
    ///      "properties": {
    ///        "items": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/PackageCodeCollectionItem"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PackageCodeCollection {
        pub items: Vec<PackageCodeCollectionItem>,
        ///If specified, contains a cursor to query next page of the `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_cursor: Option<String>,
        ///Total number of items in underlying collection, fragment of which is available in `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_count: Option<i64>,
    }
    impl From<&PackageCodeCollection> for PackageCodeCollection {
        fn from(value: &PackageCodeCollection) -> Self {
            value.clone()
        }
    }
    impl PackageCodeCollection {
        pub fn builder() -> builder::PackageCodeCollection {
            Default::default()
        }
    }
    ///PackageCodeCollectionItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "code_hash_hex",
    ///    "code_hex",
    ///    "vm_type"
    ///  ],
    ///  "properties": {
    ///    "code_hash_hex": {
    ///      "$ref": "#/components/schemas/HexString"
    ///    },
    ///    "code_hex": {
    ///      "$ref": "#/components/schemas/HexString"
    ///    },
    ///    "vm_type": {
    ///      "$ref": "#/components/schemas/PackageVmType"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PackageCodeCollectionItem {
        pub code_hash_hex: HexString,
        pub code_hex: HexString,
        pub vm_type: PackageVmType,
    }
    impl From<&PackageCodeCollectionItem> for PackageCodeCollectionItem {
        fn from(value: &PackageCodeCollectionItem) -> Self {
            value.clone()
        }
    }
    impl PackageCodeCollectionItem {
        pub fn builder() -> builder::PackageCodeCollectionItem {
            Default::default()
        }
    }
    ///PackageVmType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "Native",
    ///    "ScryptoV1"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PackageVmType {
        Native,
        ScryptoV1,
    }
    impl From<&PackageVmType> for PackageVmType {
        fn from(value: &PackageVmType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for PackageVmType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Native => write!(f, "Native"),
                Self::ScryptoV1 => write!(f, "ScryptoV1"),
            }
        }
    }
    impl std::str::FromStr for PackageVmType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "Native" => Ok(Self::Native),
                "ScryptoV1" => Ok(Self::ScryptoV1),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for PackageVmType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for PackageVmType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for PackageVmType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///PreviewFlags
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "assume_all_signature_proofs": {
    ///      "description": "If enabled, each manifest processor's auth zone will be given a simulated proof of\nevery signature, which can be used to pass signature access rules.\n\nThis can be used to preview transactions even if the required signatures are not\nknown ahead of time.\n\nSee the documentation on\n[advanced access rules](https://docs.radixdlt.com/docs/advanced-accessrules#signature-requirements)\nfor more information.\n",
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "disable_auth_checks": {
    ///      "description": "If enabled, all authorization checks are skipped during execution.\n\nThis could be used to e.g.:\n* Preview protocol update style transactions.\n* Mint resources for previewing trades with resources you don't own.\n  If doing this, be warned: only resources which were potentially mintable/burnable\n  at creation time will be mintable/burnable, due to feature flags on the resource.\n\nWarning: this mode of operation is quite a departure from normal operation:\n* Calculated fees will likely be lower than a standard execution.\n* This mode can subtly break invariants some dApp code might rely on, or result in unexpected\n  behaviour, so the execution result might not be valid for your needs. For example,\n  if this flag was used to mint pool units to preview a redemption (or some dApp interaction which\n  behind the scenes redeemed them), they'd redeem for less than they're currently worth,\n  because the blueprint code relies on the total supply of the pool units to calculate their\n  redemption worth, and you've just inflated the total supply through the mint operation.\n",
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "skip_epoch_check": {
    ///      "description": "If enabled, the various runtime epoch-related verifications are skipped:\n- The `start_epoch_inclusive` and `end_epoch_exclusive` parameters, if specified, are ignored.\n- The duplicate intent checks (which rely on the expiry epoch) are also ignored.\n\nHowever, if the start and end epoch are provided, they must still be statically valid.\nWe recommend using a value of `start_epoch_inclusive = 1` and `end_epoch_exclusive = 2` in this\ncase.\n",
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "use_free_credit": {
    ///      "description": "If enabled, a large simulated pool of XRD is marked as locked.\n\nThis mode can be used to estimate fees. To get a reliable estimate, we recommend that your\ntransaction is as close as possible to the real transaction. For example:\n- You should still use a lock fee command, but you can set it to lock a fee of 0.\n- You should include the public keys that will sign the transaction, so the cost of\n  signature verification and payload size can be accounted for.\n",
    ///      "default": false,
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PreviewFlags {
        /**If enabled, each manifest processor's auth zone will be given a simulated proof of
every signature, which can be used to pass signature access rules.

This can be used to preview transactions even if the required signatures are not
known ahead of time.

See the documentation on
[advanced access rules](https://docs.radixdlt.com/docs/advanced-accessrules#signature-requirements)
for more information.
*/
        #[serde(default)]
        pub assume_all_signature_proofs: bool,
        /**If enabled, all authorization checks are skipped during execution.

This could be used to e.g.:
* Preview protocol update style transactions.
* Mint resources for previewing trades with resources you don't own.
  If doing this, be warned: only resources which were potentially mintable/burnable
  at creation time will be mintable/burnable, due to feature flags on the resource.

Warning: this mode of operation is quite a departure from normal operation:
* Calculated fees will likely be lower than a standard execution.
* This mode can subtly break invariants some dApp code might rely on, or result in unexpected
  behaviour, so the execution result might not be valid for your needs. For example,
  if this flag was used to mint pool units to preview a redemption (or some dApp interaction which
  behind the scenes redeemed them), they'd redeem for less than they're currently worth,
  because the blueprint code relies on the total supply of the pool units to calculate their
  redemption worth, and you've just inflated the total supply through the mint operation.
*/
        #[serde(default)]
        pub disable_auth_checks: bool,
        /**If enabled, the various runtime epoch-related verifications are skipped:
- The `start_epoch_inclusive` and `end_epoch_exclusive` parameters, if specified, are ignored.
- The duplicate intent checks (which rely on the expiry epoch) are also ignored.

However, if the start and end epoch are provided, they must still be statically valid.
We recommend using a value of `start_epoch_inclusive = 1` and `end_epoch_exclusive = 2` in this
case.
*/
        #[serde(default)]
        pub skip_epoch_check: bool,
        /**If enabled, a large simulated pool of XRD is marked as locked.

This mode can be used to estimate fees. To get a reliable estimate, we recommend that your
transaction is as close as possible to the real transaction. For example:
- You should still use a lock fee command, but you can set it to lock a fee of 0.
- You should include the public keys that will sign the transaction, so the cost of
  signature verification and payload size can be accounted for.
*/
        #[serde(default)]
        pub use_free_credit: bool,
    }
    impl From<&PreviewFlags> for PreviewFlags {
        fn from(value: &PreviewFlags) -> Self {
            value.clone()
        }
    }
    impl PreviewFlags {
        pub fn builder() -> builder::PreviewFlags {
            Default::default()
        }
    }
    ///PreviewTransaction
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/CompiledPreviewTransaction"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PreviewTransaction(pub CompiledPreviewTransaction);
    impl ::std::ops::Deref for PreviewTransaction {
        type Target = CompiledPreviewTransaction;
        fn deref(&self) -> &CompiledPreviewTransaction {
            &self.0
        }
    }
    impl From<PreviewTransaction> for CompiledPreviewTransaction {
        fn from(value: PreviewTransaction) -> Self {
            value.0
        }
    }
    impl From<&PreviewTransaction> for PreviewTransaction {
        fn from(value: &PreviewTransaction) -> Self {
            value.clone()
        }
    }
    impl From<CompiledPreviewTransaction> for PreviewTransaction {
        fn from(value: CompiledPreviewTransaction) -> Self {
            Self(value)
        }
    }
    ///PreviewTransactionBase
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "type": {
    ///      "$ref": "#/components/schemas/PreviewTransactionType"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PreviewTransactionBase {
        #[serde(rename = "type")]
        pub type_: PreviewTransactionType,
    }
    impl From<&PreviewTransactionBase> for PreviewTransactionBase {
        fn from(value: &PreviewTransactionBase) -> Self {
            value.clone()
        }
    }
    impl PreviewTransactionBase {
        pub fn builder() -> builder::PreviewTransactionBase {
            Default::default()
        }
    }
    ///PreviewTransactionType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "Compiled"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PreviewTransactionType {
        Compiled,
    }
    impl From<&PreviewTransactionType> for PreviewTransactionType {
        fn from(value: &PreviewTransactionType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for PreviewTransactionType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Compiled => write!(f, "Compiled"),
            }
        }
    }
    impl std::str::FromStr for PreviewTransactionType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "Compiled" => Ok(Self::Compiled),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for PreviewTransactionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for PreviewTransactionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for PreviewTransactionType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///ProgrammaticScryptoSborValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValueBool"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValueI8"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValueI16"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValueI32"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValueI64"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValueI128"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValueU8"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValueU16"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValueU32"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValueU64"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValueU128"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValueString"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValueEnum"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValueArray"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValueBytes"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValueMap"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValueTuple"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValueReference"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValueOwn"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValueDecimal"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValuePreciseDecimal"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValueNonFungibleLocalId"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum ProgrammaticScryptoSborValue {
        Bool(ProgrammaticScryptoSborValueBool),
        I8(ProgrammaticScryptoSborValueI8),
        I16(ProgrammaticScryptoSborValueI16),
        I32(ProgrammaticScryptoSborValueI32),
        I64(ProgrammaticScryptoSborValueI64),
        I128(ProgrammaticScryptoSborValueI128),
        U8(ProgrammaticScryptoSborValueU8),
        U16(ProgrammaticScryptoSborValueU16),
        U32(ProgrammaticScryptoSborValueU32),
        U64(ProgrammaticScryptoSborValueU64),
        U128(ProgrammaticScryptoSborValueU128),
        String(ProgrammaticScryptoSborValueString),
        Enum(ProgrammaticScryptoSborValueEnum),
        Array(ProgrammaticScryptoSborValueArray),
        Bytes(ProgrammaticScryptoSborValueBytes),
        Map(ProgrammaticScryptoSborValueMap),
        Tuple(ProgrammaticScryptoSborValueTuple),
        Reference(ProgrammaticScryptoSborValueReference),
        Own(ProgrammaticScryptoSborValueOwn),
        Decimal(ProgrammaticScryptoSborValueDecimal),
        PreciseDecimal(ProgrammaticScryptoSborValuePreciseDecimal),
        NonFungibleLocalId(ProgrammaticScryptoSborValueNonFungibleLocalId),
    }
    impl From<&ProgrammaticScryptoSborValue> for ProgrammaticScryptoSborValue {
        fn from(value: &ProgrammaticScryptoSborValue) -> Self {
            value.clone()
        }
    }
    impl From<ProgrammaticScryptoSborValueBool> for ProgrammaticScryptoSborValue {
        fn from(value: ProgrammaticScryptoSborValueBool) -> Self {
            Self::Bool(value)
        }
    }
    impl From<ProgrammaticScryptoSborValueI8> for ProgrammaticScryptoSborValue {
        fn from(value: ProgrammaticScryptoSborValueI8) -> Self {
            Self::I8(value)
        }
    }
    impl From<ProgrammaticScryptoSborValueI16> for ProgrammaticScryptoSborValue {
        fn from(value: ProgrammaticScryptoSborValueI16) -> Self {
            Self::I16(value)
        }
    }
    impl From<ProgrammaticScryptoSborValueI32> for ProgrammaticScryptoSborValue {
        fn from(value: ProgrammaticScryptoSborValueI32) -> Self {
            Self::I32(value)
        }
    }
    impl From<ProgrammaticScryptoSborValueI64> for ProgrammaticScryptoSborValue {
        fn from(value: ProgrammaticScryptoSborValueI64) -> Self {
            Self::I64(value)
        }
    }
    impl From<ProgrammaticScryptoSborValueI128> for ProgrammaticScryptoSborValue {
        fn from(value: ProgrammaticScryptoSborValueI128) -> Self {
            Self::I128(value)
        }
    }
    impl From<ProgrammaticScryptoSborValueU8> for ProgrammaticScryptoSborValue {
        fn from(value: ProgrammaticScryptoSborValueU8) -> Self {
            Self::U8(value)
        }
    }
    impl From<ProgrammaticScryptoSborValueU16> for ProgrammaticScryptoSborValue {
        fn from(value: ProgrammaticScryptoSborValueU16) -> Self {
            Self::U16(value)
        }
    }
    impl From<ProgrammaticScryptoSborValueU32> for ProgrammaticScryptoSborValue {
        fn from(value: ProgrammaticScryptoSborValueU32) -> Self {
            Self::U32(value)
        }
    }
    impl From<ProgrammaticScryptoSborValueU64> for ProgrammaticScryptoSborValue {
        fn from(value: ProgrammaticScryptoSborValueU64) -> Self {
            Self::U64(value)
        }
    }
    impl From<ProgrammaticScryptoSborValueU128> for ProgrammaticScryptoSborValue {
        fn from(value: ProgrammaticScryptoSborValueU128) -> Self {
            Self::U128(value)
        }
    }
    impl From<ProgrammaticScryptoSborValueString> for ProgrammaticScryptoSborValue {
        fn from(value: ProgrammaticScryptoSborValueString) -> Self {
            Self::String(value)
        }
    }
    impl From<ProgrammaticScryptoSborValueEnum> for ProgrammaticScryptoSborValue {
        fn from(value: ProgrammaticScryptoSborValueEnum) -> Self {
            Self::Enum(value)
        }
    }
    impl From<ProgrammaticScryptoSborValueArray> for ProgrammaticScryptoSborValue {
        fn from(value: ProgrammaticScryptoSborValueArray) -> Self {
            Self::Array(value)
        }
    }
    impl From<ProgrammaticScryptoSborValueBytes> for ProgrammaticScryptoSborValue {
        fn from(value: ProgrammaticScryptoSborValueBytes) -> Self {
            Self::Bytes(value)
        }
    }
    impl From<ProgrammaticScryptoSborValueMap> for ProgrammaticScryptoSborValue {
        fn from(value: ProgrammaticScryptoSborValueMap) -> Self {
            Self::Map(value)
        }
    }
    impl From<ProgrammaticScryptoSborValueTuple> for ProgrammaticScryptoSborValue {
        fn from(value: ProgrammaticScryptoSborValueTuple) -> Self {
            Self::Tuple(value)
        }
    }
    impl From<ProgrammaticScryptoSborValueReference> for ProgrammaticScryptoSborValue {
        fn from(value: ProgrammaticScryptoSborValueReference) -> Self {
            Self::Reference(value)
        }
    }
    impl From<ProgrammaticScryptoSborValueOwn> for ProgrammaticScryptoSborValue {
        fn from(value: ProgrammaticScryptoSborValueOwn) -> Self {
            Self::Own(value)
        }
    }
    impl From<ProgrammaticScryptoSborValueDecimal> for ProgrammaticScryptoSborValue {
        fn from(value: ProgrammaticScryptoSborValueDecimal) -> Self {
            Self::Decimal(value)
        }
    }
    impl From<ProgrammaticScryptoSborValuePreciseDecimal>
    for ProgrammaticScryptoSborValue {
        fn from(value: ProgrammaticScryptoSborValuePreciseDecimal) -> Self {
            Self::PreciseDecimal(value)
        }
    }
    impl From<ProgrammaticScryptoSborValueNonFungibleLocalId>
    for ProgrammaticScryptoSborValue {
        fn from(value: ProgrammaticScryptoSborValueNonFungibleLocalId) -> Self {
            Self::NonFungibleLocalId(value)
        }
    }
    ///ProgrammaticScryptoSborValueArray
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "element_kind",
    ///        "elements"
    ///      ],
    ///      "properties": {
    ///        "element_kind": {
    ///          "$ref": "#/components/schemas/ProgrammaticScryptoSborValueKind"
    ///        },
    ///        "element_type_name": {
    ///          "type": "string"
    ///        },
    ///        "elements": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/ProgrammaticScryptoSborValue"
    ///          }
    ///        },
    ///        "kind": {
    ///          "type": "string",
    ///          "enum": [
    ///            "Array"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ProgrammaticScryptoSborValueArray {
        pub element_kind: ProgrammaticScryptoSborValueKind,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub element_type_name: Option<String>,
        pub elements: Vec<ProgrammaticScryptoSborValue>,
        /**The name of the field which hosts this value.
This property is only included if this value is a child of a `Tuple` or `Enum` with named fields.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub field_name: Option<String>,
        pub kind: ProgrammaticScryptoSborValueArrayKind,
        /**The name of the type of this value.
This is only output when a schema is present and the type has a name.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub type_name: Option<String>,
    }
    impl From<&ProgrammaticScryptoSborValueArray> for ProgrammaticScryptoSborValueArray {
        fn from(value: &ProgrammaticScryptoSborValueArray) -> Self {
            value.clone()
        }
    }
    impl ProgrammaticScryptoSborValueArray {
        pub fn builder() -> builder::ProgrammaticScryptoSborValueArray {
            Default::default()
        }
    }
    ///ProgrammaticScryptoSborValueArrayKind
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "Array"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum ProgrammaticScryptoSborValueArrayKind {
        Array,
    }
    impl From<&ProgrammaticScryptoSborValueArrayKind>
    for ProgrammaticScryptoSborValueArrayKind {
        fn from(value: &ProgrammaticScryptoSborValueArrayKind) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for ProgrammaticScryptoSborValueArrayKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Array => write!(f, "Array"),
            }
        }
    }
    impl std::str::FromStr for ProgrammaticScryptoSborValueArrayKind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "Array" => Ok(Self::Array),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for ProgrammaticScryptoSborValueArrayKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for ProgrammaticScryptoSborValueArrayKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for ProgrammaticScryptoSborValueArrayKind {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    /**Arbitrary SBOR value represented as programmatic JSON with optional property name annotations.

All scalar types (`Bool`, `I*`, `U*`, `String`, `Reference`, `Own`, `Decimal`, `PreciseDecimal`, `NonFungibleLocalId`)
convey their value via `value` string property with notable exception of `Bool` type that uses regular JSON boolean type.
Numeric values as string-encoded to preserve accuracy and simplify implementation on platforms with no native support
for 64-bit long numerical values.

Common properties represented as nullable strings:
  * `type_name` is only output when a schema is present and the type has a name,
  * `field_name` is only output when the value is a child of a `Tuple` or `Enum`, which has a type with named fields,
  * `variant_name` is only output when a schema is present and the type is an `Enum`.

The following is a non-normative example annotated `Tuple` value with `String` and `U32` fields:
```
{
  "kind": "Tuple",
  "type_name": "CustomStructure",
  "fields": [
    {
      "kind": "String",
      "field_name": "favorite_color",
      "value": "Blue"
    },
    {
      "kind": "U32",
      "field_name": "usage_counter",
      "value": "462231"
    }
  ]
}
```
*/
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Arbitrary SBOR value represented as programmatic JSON with optional property name annotations.\n\nAll scalar types (`Bool`, `I*`, `U*`, `String`, `Reference`, `Own`, `Decimal`, `PreciseDecimal`, `NonFungibleLocalId`)\nconvey their value via `value` string property with notable exception of `Bool` type that uses regular JSON boolean type.\nNumeric values as string-encoded to preserve accuracy and simplify implementation on platforms with no native support\nfor 64-bit long numerical values.\n\nCommon properties represented as nullable strings:\n  * `type_name` is only output when a schema is present and the type has a name,\n  * `field_name` is only output when the value is a child of a `Tuple` or `Enum`, which has a type with named fields,\n  * `variant_name` is only output when a schema is present and the type is an `Enum`.\n\nThe following is a non-normative example annotated `Tuple` value with `String` and `U32` fields:\n```\n{\n  \"kind\": \"Tuple\",\n  \"type_name\": \"CustomStructure\",\n  \"fields\": [\n    {\n      \"kind\": \"String\",\n      \"field_name\": \"favorite_color\",\n      \"value\": \"Blue\"\n    },\n    {\n      \"kind\": \"U32\",\n      \"field_name\": \"usage_counter\",\n      \"value\": \"462231\"\n    }\n  ]\n}\n```\n",
    ///  "type": "object",
    ///  "required": [
    ///    "kind"
    ///  ],
    ///  "properties": {
    ///    "field_name": {
    ///      "description": "The name of the field which hosts this value.\nThis property is only included if this value is a child of a `Tuple` or `Enum` with named fields.\nThis property is ignored when the value is used as an input to the API.\n",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "kind": {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValueKind"
    ///    },
    ///    "type_name": {
    ///      "description": "The name of the type of this value.\nThis is only output when a schema is present and the type has a name.\nThis property is ignored when the value is used as an input to the API.\n",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ProgrammaticScryptoSborValueBase {
        /**The name of the field which hosts this value.
This property is only included if this value is a child of a `Tuple` or `Enum` with named fields.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub field_name: Option<String>,
        pub kind: ProgrammaticScryptoSborValueKind,
        /**The name of the type of this value.
This is only output when a schema is present and the type has a name.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub type_name: Option<String>,
    }
    impl From<&ProgrammaticScryptoSborValueBase> for ProgrammaticScryptoSborValueBase {
        fn from(value: &ProgrammaticScryptoSborValueBase) -> Self {
            value.clone()
        }
    }
    impl ProgrammaticScryptoSborValueBase {
        pub fn builder() -> builder::ProgrammaticScryptoSborValueBase {
            Default::default()
        }
    }
    ///ProgrammaticScryptoSborValueBool
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "kind": {
    ///          "type": "string",
    ///          "enum": [
    ///            "Bool"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "boolean"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ProgrammaticScryptoSborValueBool {
        /**The name of the field which hosts this value.
This property is only included if this value is a child of a `Tuple` or `Enum` with named fields.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub field_name: Option<String>,
        pub kind: ProgrammaticScryptoSborValueBoolKind,
        /**The name of the type of this value.
This is only output when a schema is present and the type has a name.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub type_name: Option<String>,
        pub value: bool,
    }
    impl From<&ProgrammaticScryptoSborValueBool> for ProgrammaticScryptoSborValueBool {
        fn from(value: &ProgrammaticScryptoSborValueBool) -> Self {
            value.clone()
        }
    }
    impl ProgrammaticScryptoSborValueBool {
        pub fn builder() -> builder::ProgrammaticScryptoSborValueBool {
            Default::default()
        }
    }
    ///ProgrammaticScryptoSborValueBoolKind
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "Bool"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum ProgrammaticScryptoSborValueBoolKind {
        Bool,
    }
    impl From<&ProgrammaticScryptoSborValueBoolKind>
    for ProgrammaticScryptoSborValueBoolKind {
        fn from(value: &ProgrammaticScryptoSborValueBoolKind) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for ProgrammaticScryptoSborValueBoolKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Bool => write!(f, "Bool"),
            }
        }
    }
    impl std::str::FromStr for ProgrammaticScryptoSborValueBoolKind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "Bool" => Ok(Self::Bool),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for ProgrammaticScryptoSborValueBoolKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for ProgrammaticScryptoSborValueBoolKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for ProgrammaticScryptoSborValueBoolKind {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///ProgrammaticScryptoSborValueBytes
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "element_kind",
    ///        "hex"
    ///      ],
    ///      "properties": {
    ///        "element_kind": {
    ///          "$ref": "#/components/schemas/ProgrammaticScryptoSborValueKind"
    ///        },
    ///        "element_type_name": {
    ///          "type": "string"
    ///        },
    ///        "hex": {
    ///          "$ref": "#/components/schemas/HexString"
    ///        },
    ///        "kind": {
    ///          "type": "string",
    ///          "enum": [
    ///            "Bytes"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ProgrammaticScryptoSborValueBytes {
        pub element_kind: ProgrammaticScryptoSborValueKind,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub element_type_name: Option<String>,
        /**The name of the field which hosts this value.
This property is only included if this value is a child of a `Tuple` or `Enum` with named fields.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub field_name: Option<String>,
        pub hex: HexString,
        pub kind: ProgrammaticScryptoSborValueBytesKind,
        /**The name of the type of this value.
This is only output when a schema is present and the type has a name.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub type_name: Option<String>,
    }
    impl From<&ProgrammaticScryptoSborValueBytes> for ProgrammaticScryptoSborValueBytes {
        fn from(value: &ProgrammaticScryptoSborValueBytes) -> Self {
            value.clone()
        }
    }
    impl ProgrammaticScryptoSborValueBytes {
        pub fn builder() -> builder::ProgrammaticScryptoSborValueBytes {
            Default::default()
        }
    }
    ///ProgrammaticScryptoSborValueBytesKind
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "Bytes"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum ProgrammaticScryptoSborValueBytesKind {
        Bytes,
    }
    impl From<&ProgrammaticScryptoSborValueBytesKind>
    for ProgrammaticScryptoSborValueBytesKind {
        fn from(value: &ProgrammaticScryptoSborValueBytesKind) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for ProgrammaticScryptoSborValueBytesKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Bytes => write!(f, "Bytes"),
            }
        }
    }
    impl std::str::FromStr for ProgrammaticScryptoSborValueBytesKind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "Bytes" => Ok(Self::Bytes),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for ProgrammaticScryptoSborValueBytesKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for ProgrammaticScryptoSborValueBytesKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for ProgrammaticScryptoSborValueBytesKind {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///ProgrammaticScryptoSborValueDecimal
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "kind": {
    ///          "type": "string",
    ///          "enum": [
    ///            "Decimal"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ProgrammaticScryptoSborValueDecimal {
        /**The name of the field which hosts this value.
This property is only included if this value is a child of a `Tuple` or `Enum` with named fields.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub field_name: Option<String>,
        pub kind: ProgrammaticScryptoSborValueDecimalKind,
        /**The name of the type of this value.
This is only output when a schema is present and the type has a name.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub type_name: Option<String>,
        pub value: String,
    }
    impl From<&ProgrammaticScryptoSborValueDecimal>
    for ProgrammaticScryptoSborValueDecimal {
        fn from(value: &ProgrammaticScryptoSborValueDecimal) -> Self {
            value.clone()
        }
    }
    impl ProgrammaticScryptoSborValueDecimal {
        pub fn builder() -> builder::ProgrammaticScryptoSborValueDecimal {
            Default::default()
        }
    }
    ///ProgrammaticScryptoSborValueDecimalKind
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "Decimal"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum ProgrammaticScryptoSborValueDecimalKind {
        Decimal,
    }
    impl From<&ProgrammaticScryptoSborValueDecimalKind>
    for ProgrammaticScryptoSborValueDecimalKind {
        fn from(value: &ProgrammaticScryptoSborValueDecimalKind) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for ProgrammaticScryptoSborValueDecimalKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Decimal => write!(f, "Decimal"),
            }
        }
    }
    impl std::str::FromStr for ProgrammaticScryptoSborValueDecimalKind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "Decimal" => Ok(Self::Decimal),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for ProgrammaticScryptoSborValueDecimalKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for ProgrammaticScryptoSborValueDecimalKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for ProgrammaticScryptoSborValueDecimalKind {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///ProgrammaticScryptoSborValueEnum
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "fields",
    ///        "variant_id"
    ///      ],
    ///      "properties": {
    ///        "fields": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/ProgrammaticScryptoSborValue"
    ///          }
    ///        },
    ///        "kind": {
    ///          "type": "string",
    ///          "enum": [
    ///            "Enum"
    ///          ]
    ///        },
    ///        "variant_id": {
    ///          "type": "string"
    ///        },
    ///        "variant_name": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ProgrammaticScryptoSborValueEnum {
        /**The name of the field which hosts this value.
This property is only included if this value is a child of a `Tuple` or `Enum` with named fields.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub field_name: Option<String>,
        pub fields: Vec<ProgrammaticScryptoSborValue>,
        pub kind: ProgrammaticScryptoSborValueEnumKind,
        /**The name of the type of this value.
This is only output when a schema is present and the type has a name.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub type_name: Option<String>,
        pub variant_id: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub variant_name: Option<String>,
    }
    impl From<&ProgrammaticScryptoSborValueEnum> for ProgrammaticScryptoSborValueEnum {
        fn from(value: &ProgrammaticScryptoSborValueEnum) -> Self {
            value.clone()
        }
    }
    impl ProgrammaticScryptoSborValueEnum {
        pub fn builder() -> builder::ProgrammaticScryptoSborValueEnum {
            Default::default()
        }
    }
    ///ProgrammaticScryptoSborValueEnumKind
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "Enum"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum ProgrammaticScryptoSborValueEnumKind {
        Enum,
    }
    impl From<&ProgrammaticScryptoSborValueEnumKind>
    for ProgrammaticScryptoSborValueEnumKind {
        fn from(value: &ProgrammaticScryptoSborValueEnumKind) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for ProgrammaticScryptoSborValueEnumKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Enum => write!(f, "Enum"),
            }
        }
    }
    impl std::str::FromStr for ProgrammaticScryptoSborValueEnumKind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "Enum" => Ok(Self::Enum),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for ProgrammaticScryptoSborValueEnumKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for ProgrammaticScryptoSborValueEnumKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for ProgrammaticScryptoSborValueEnumKind {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///ProgrammaticScryptoSborValueI128
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "kind": {
    ///          "type": "string",
    ///          "enum": [
    ///            "I128"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ProgrammaticScryptoSborValueI128 {
        /**The name of the field which hosts this value.
This property is only included if this value is a child of a `Tuple` or `Enum` with named fields.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub field_name: Option<String>,
        pub kind: ProgrammaticScryptoSborValueI128Kind,
        /**The name of the type of this value.
This is only output when a schema is present and the type has a name.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub type_name: Option<String>,
        pub value: String,
    }
    impl From<&ProgrammaticScryptoSborValueI128> for ProgrammaticScryptoSborValueI128 {
        fn from(value: &ProgrammaticScryptoSborValueI128) -> Self {
            value.clone()
        }
    }
    impl ProgrammaticScryptoSborValueI128 {
        pub fn builder() -> builder::ProgrammaticScryptoSborValueI128 {
            Default::default()
        }
    }
    ///ProgrammaticScryptoSborValueI128Kind
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "I128"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum ProgrammaticScryptoSborValueI128Kind {
        I128,
    }
    impl From<&ProgrammaticScryptoSborValueI128Kind>
    for ProgrammaticScryptoSborValueI128Kind {
        fn from(value: &ProgrammaticScryptoSborValueI128Kind) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for ProgrammaticScryptoSborValueI128Kind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::I128 => write!(f, "I128"),
            }
        }
    }
    impl std::str::FromStr for ProgrammaticScryptoSborValueI128Kind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "I128" => Ok(Self::I128),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for ProgrammaticScryptoSborValueI128Kind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for ProgrammaticScryptoSborValueI128Kind {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for ProgrammaticScryptoSborValueI128Kind {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///ProgrammaticScryptoSborValueI16
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "kind": {
    ///          "type": "string",
    ///          "enum": [
    ///            "I16"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ProgrammaticScryptoSborValueI16 {
        /**The name of the field which hosts this value.
This property is only included if this value is a child of a `Tuple` or `Enum` with named fields.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub field_name: Option<String>,
        pub kind: ProgrammaticScryptoSborValueI16Kind,
        /**The name of the type of this value.
This is only output when a schema is present and the type has a name.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub type_name: Option<String>,
        pub value: String,
    }
    impl From<&ProgrammaticScryptoSborValueI16> for ProgrammaticScryptoSborValueI16 {
        fn from(value: &ProgrammaticScryptoSborValueI16) -> Self {
            value.clone()
        }
    }
    impl ProgrammaticScryptoSborValueI16 {
        pub fn builder() -> builder::ProgrammaticScryptoSborValueI16 {
            Default::default()
        }
    }
    ///ProgrammaticScryptoSborValueI16Kind
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "I16"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum ProgrammaticScryptoSborValueI16Kind {
        I16,
    }
    impl From<&ProgrammaticScryptoSborValueI16Kind>
    for ProgrammaticScryptoSborValueI16Kind {
        fn from(value: &ProgrammaticScryptoSborValueI16Kind) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for ProgrammaticScryptoSborValueI16Kind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::I16 => write!(f, "I16"),
            }
        }
    }
    impl std::str::FromStr for ProgrammaticScryptoSborValueI16Kind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "I16" => Ok(Self::I16),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for ProgrammaticScryptoSborValueI16Kind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for ProgrammaticScryptoSborValueI16Kind {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for ProgrammaticScryptoSborValueI16Kind {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///ProgrammaticScryptoSborValueI32
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "kind": {
    ///          "type": "string",
    ///          "enum": [
    ///            "I32"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ProgrammaticScryptoSborValueI32 {
        /**The name of the field which hosts this value.
This property is only included if this value is a child of a `Tuple` or `Enum` with named fields.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub field_name: Option<String>,
        pub kind: ProgrammaticScryptoSborValueI32Kind,
        /**The name of the type of this value.
This is only output when a schema is present and the type has a name.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub type_name: Option<String>,
        pub value: String,
    }
    impl From<&ProgrammaticScryptoSborValueI32> for ProgrammaticScryptoSborValueI32 {
        fn from(value: &ProgrammaticScryptoSborValueI32) -> Self {
            value.clone()
        }
    }
    impl ProgrammaticScryptoSborValueI32 {
        pub fn builder() -> builder::ProgrammaticScryptoSborValueI32 {
            Default::default()
        }
    }
    ///ProgrammaticScryptoSborValueI32Kind
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "I32"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum ProgrammaticScryptoSborValueI32Kind {
        I32,
    }
    impl From<&ProgrammaticScryptoSborValueI32Kind>
    for ProgrammaticScryptoSborValueI32Kind {
        fn from(value: &ProgrammaticScryptoSborValueI32Kind) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for ProgrammaticScryptoSborValueI32Kind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::I32 => write!(f, "I32"),
            }
        }
    }
    impl std::str::FromStr for ProgrammaticScryptoSborValueI32Kind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "I32" => Ok(Self::I32),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for ProgrammaticScryptoSborValueI32Kind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for ProgrammaticScryptoSborValueI32Kind {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for ProgrammaticScryptoSborValueI32Kind {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///ProgrammaticScryptoSborValueI64
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "kind": {
    ///          "type": "string",
    ///          "enum": [
    ///            "I64"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ProgrammaticScryptoSborValueI64 {
        /**The name of the field which hosts this value.
This property is only included if this value is a child of a `Tuple` or `Enum` with named fields.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub field_name: Option<String>,
        pub kind: ProgrammaticScryptoSborValueI64Kind,
        /**The name of the type of this value.
This is only output when a schema is present and the type has a name.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub type_name: Option<String>,
        pub value: String,
    }
    impl From<&ProgrammaticScryptoSborValueI64> for ProgrammaticScryptoSborValueI64 {
        fn from(value: &ProgrammaticScryptoSborValueI64) -> Self {
            value.clone()
        }
    }
    impl ProgrammaticScryptoSborValueI64 {
        pub fn builder() -> builder::ProgrammaticScryptoSborValueI64 {
            Default::default()
        }
    }
    ///ProgrammaticScryptoSborValueI64Kind
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "I64"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum ProgrammaticScryptoSborValueI64Kind {
        I64,
    }
    impl From<&ProgrammaticScryptoSborValueI64Kind>
    for ProgrammaticScryptoSborValueI64Kind {
        fn from(value: &ProgrammaticScryptoSborValueI64Kind) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for ProgrammaticScryptoSborValueI64Kind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::I64 => write!(f, "I64"),
            }
        }
    }
    impl std::str::FromStr for ProgrammaticScryptoSborValueI64Kind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "I64" => Ok(Self::I64),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for ProgrammaticScryptoSborValueI64Kind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for ProgrammaticScryptoSborValueI64Kind {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for ProgrammaticScryptoSborValueI64Kind {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///ProgrammaticScryptoSborValueI8
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "kind": {
    ///          "type": "string",
    ///          "enum": [
    ///            "I8"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ProgrammaticScryptoSborValueI8 {
        /**The name of the field which hosts this value.
This property is only included if this value is a child of a `Tuple` or `Enum` with named fields.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub field_name: Option<String>,
        pub kind: ProgrammaticScryptoSborValueI8Kind,
        /**The name of the type of this value.
This is only output when a schema is present and the type has a name.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub type_name: Option<String>,
        pub value: String,
    }
    impl From<&ProgrammaticScryptoSborValueI8> for ProgrammaticScryptoSborValueI8 {
        fn from(value: &ProgrammaticScryptoSborValueI8) -> Self {
            value.clone()
        }
    }
    impl ProgrammaticScryptoSborValueI8 {
        pub fn builder() -> builder::ProgrammaticScryptoSborValueI8 {
            Default::default()
        }
    }
    ///ProgrammaticScryptoSborValueI8Kind
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "I8"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum ProgrammaticScryptoSborValueI8Kind {
        I8,
    }
    impl From<&ProgrammaticScryptoSborValueI8Kind>
    for ProgrammaticScryptoSborValueI8Kind {
        fn from(value: &ProgrammaticScryptoSborValueI8Kind) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for ProgrammaticScryptoSborValueI8Kind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::I8 => write!(f, "I8"),
            }
        }
    }
    impl std::str::FromStr for ProgrammaticScryptoSborValueI8Kind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "I8" => Ok(Self::I8),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for ProgrammaticScryptoSborValueI8Kind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for ProgrammaticScryptoSborValueI8Kind {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for ProgrammaticScryptoSborValueI8Kind {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    /**These are the Scrypto SBOR `ValueKind`s, but with `Bytes` added as an alias for `Vec`, to display such values as hex-encoded strings.
*/
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "These are the Scrypto SBOR `ValueKind`s, but with `Bytes` added as an alias for `Vec`, to display such values as hex-encoded strings.\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "Bool",
    ///    "I8",
    ///    "I16",
    ///    "I32",
    ///    "I64",
    ///    "I128",
    ///    "U8",
    ///    "U16",
    ///    "U32",
    ///    "U64",
    ///    "U128",
    ///    "String",
    ///    "Enum",
    ///    "Array",
    ///    "Bytes",
    ///    "Map",
    ///    "Tuple",
    ///    "Reference",
    ///    "Own",
    ///    "Decimal",
    ///    "PreciseDecimal",
    ///    "NonFungibleLocalId"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum ProgrammaticScryptoSborValueKind {
        Bool,
        I8,
        I16,
        I32,
        I64,
        I128,
        U8,
        U16,
        U32,
        U64,
        U128,
        String,
        Enum,
        Array,
        Bytes,
        Map,
        Tuple,
        Reference,
        Own,
        Decimal,
        PreciseDecimal,
        NonFungibleLocalId,
    }
    impl From<&ProgrammaticScryptoSborValueKind> for ProgrammaticScryptoSborValueKind {
        fn from(value: &ProgrammaticScryptoSborValueKind) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for ProgrammaticScryptoSborValueKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Bool => write!(f, "Bool"),
                Self::I8 => write!(f, "I8"),
                Self::I16 => write!(f, "I16"),
                Self::I32 => write!(f, "I32"),
                Self::I64 => write!(f, "I64"),
                Self::I128 => write!(f, "I128"),
                Self::U8 => write!(f, "U8"),
                Self::U16 => write!(f, "U16"),
                Self::U32 => write!(f, "U32"),
                Self::U64 => write!(f, "U64"),
                Self::U128 => write!(f, "U128"),
                Self::String => write!(f, "String"),
                Self::Enum => write!(f, "Enum"),
                Self::Array => write!(f, "Array"),
                Self::Bytes => write!(f, "Bytes"),
                Self::Map => write!(f, "Map"),
                Self::Tuple => write!(f, "Tuple"),
                Self::Reference => write!(f, "Reference"),
                Self::Own => write!(f, "Own"),
                Self::Decimal => write!(f, "Decimal"),
                Self::PreciseDecimal => write!(f, "PreciseDecimal"),
                Self::NonFungibleLocalId => write!(f, "NonFungibleLocalId"),
            }
        }
    }
    impl std::str::FromStr for ProgrammaticScryptoSborValueKind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "Bool" => Ok(Self::Bool),
                "I8" => Ok(Self::I8),
                "I16" => Ok(Self::I16),
                "I32" => Ok(Self::I32),
                "I64" => Ok(Self::I64),
                "I128" => Ok(Self::I128),
                "U8" => Ok(Self::U8),
                "U16" => Ok(Self::U16),
                "U32" => Ok(Self::U32),
                "U64" => Ok(Self::U64),
                "U128" => Ok(Self::U128),
                "String" => Ok(Self::String),
                "Enum" => Ok(Self::Enum),
                "Array" => Ok(Self::Array),
                "Bytes" => Ok(Self::Bytes),
                "Map" => Ok(Self::Map),
                "Tuple" => Ok(Self::Tuple),
                "Reference" => Ok(Self::Reference),
                "Own" => Ok(Self::Own),
                "Decimal" => Ok(Self::Decimal),
                "PreciseDecimal" => Ok(Self::PreciseDecimal),
                "NonFungibleLocalId" => Ok(Self::NonFungibleLocalId),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for ProgrammaticScryptoSborValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for ProgrammaticScryptoSborValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for ProgrammaticScryptoSborValueKind {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///ProgrammaticScryptoSborValueMap
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "entries",
    ///        "key_kind",
    ///        "value_kind"
    ///      ],
    ///      "properties": {
    ///        "entries": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/ProgrammaticScryptoSborValueMapEntry"
    ///          }
    ///        },
    ///        "key_kind": {
    ///          "$ref": "#/components/schemas/ProgrammaticScryptoSborValueKind"
    ///        },
    ///        "key_type_name": {
    ///          "type": "string"
    ///        },
    ///        "kind": {
    ///          "type": "string",
    ///          "enum": [
    ///            "Map"
    ///          ]
    ///        },
    ///        "value_kind": {
    ///          "$ref": "#/components/schemas/ProgrammaticScryptoSborValueKind"
    ///        },
    ///        "value_type_name": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ProgrammaticScryptoSborValueMap {
        pub entries: Vec<ProgrammaticScryptoSborValueMapEntry>,
        /**The name of the field which hosts this value.
This property is only included if this value is a child of a `Tuple` or `Enum` with named fields.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub field_name: Option<String>,
        pub key_kind: ProgrammaticScryptoSborValueKind,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub key_type_name: Option<String>,
        pub kind: ProgrammaticScryptoSborValueMapKind,
        /**The name of the type of this value.
This is only output when a schema is present and the type has a name.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub type_name: Option<String>,
        pub value_kind: ProgrammaticScryptoSborValueKind,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub value_type_name: Option<String>,
    }
    impl From<&ProgrammaticScryptoSborValueMap> for ProgrammaticScryptoSborValueMap {
        fn from(value: &ProgrammaticScryptoSborValueMap) -> Self {
            value.clone()
        }
    }
    impl ProgrammaticScryptoSborValueMap {
        pub fn builder() -> builder::ProgrammaticScryptoSborValueMap {
            Default::default()
        }
    }
    ///ProgrammaticScryptoSborValueMapEntry
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "key",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "key": {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValue"
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValue"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ProgrammaticScryptoSborValueMapEntry {
        pub key: ProgrammaticScryptoSborValue,
        pub value: ProgrammaticScryptoSborValue,
    }
    impl From<&ProgrammaticScryptoSborValueMapEntry>
    for ProgrammaticScryptoSborValueMapEntry {
        fn from(value: &ProgrammaticScryptoSborValueMapEntry) -> Self {
            value.clone()
        }
    }
    impl ProgrammaticScryptoSborValueMapEntry {
        pub fn builder() -> builder::ProgrammaticScryptoSborValueMapEntry {
            Default::default()
        }
    }
    ///ProgrammaticScryptoSborValueMapKind
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "Map"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum ProgrammaticScryptoSborValueMapKind {
        Map,
    }
    impl From<&ProgrammaticScryptoSborValueMapKind>
    for ProgrammaticScryptoSborValueMapKind {
        fn from(value: &ProgrammaticScryptoSborValueMapKind) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for ProgrammaticScryptoSborValueMapKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Map => write!(f, "Map"),
            }
        }
    }
    impl std::str::FromStr for ProgrammaticScryptoSborValueMapKind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "Map" => Ok(Self::Map),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for ProgrammaticScryptoSborValueMapKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for ProgrammaticScryptoSborValueMapKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for ProgrammaticScryptoSborValueMapKind {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///ProgrammaticScryptoSborValueNonFungibleLocalId
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "kind": {
    ///          "type": "string",
    ///          "enum": [
    ///            "NonFungibleLocalId"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ProgrammaticScryptoSborValueNonFungibleLocalId {
        /**The name of the field which hosts this value.
This property is only included if this value is a child of a `Tuple` or `Enum` with named fields.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub field_name: Option<String>,
        pub kind: ProgrammaticScryptoSborValueNonFungibleLocalIdKind,
        /**The name of the type of this value.
This is only output when a schema is present and the type has a name.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub type_name: Option<String>,
        pub value: String,
    }
    impl From<&ProgrammaticScryptoSborValueNonFungibleLocalId>
    for ProgrammaticScryptoSborValueNonFungibleLocalId {
        fn from(value: &ProgrammaticScryptoSborValueNonFungibleLocalId) -> Self {
            value.clone()
        }
    }
    impl ProgrammaticScryptoSborValueNonFungibleLocalId {
        pub fn builder() -> builder::ProgrammaticScryptoSborValueNonFungibleLocalId {
            Default::default()
        }
    }
    ///ProgrammaticScryptoSborValueNonFungibleLocalIdKind
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "NonFungibleLocalId"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum ProgrammaticScryptoSborValueNonFungibleLocalIdKind {
        NonFungibleLocalId,
    }
    impl From<&ProgrammaticScryptoSborValueNonFungibleLocalIdKind>
    for ProgrammaticScryptoSborValueNonFungibleLocalIdKind {
        fn from(value: &ProgrammaticScryptoSborValueNonFungibleLocalIdKind) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for ProgrammaticScryptoSborValueNonFungibleLocalIdKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::NonFungibleLocalId => write!(f, "NonFungibleLocalId"),
            }
        }
    }
    impl std::str::FromStr for ProgrammaticScryptoSborValueNonFungibleLocalIdKind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "NonFungibleLocalId" => Ok(Self::NonFungibleLocalId),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str>
    for ProgrammaticScryptoSborValueNonFungibleLocalIdKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String>
    for ProgrammaticScryptoSborValueNonFungibleLocalIdKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String>
    for ProgrammaticScryptoSborValueNonFungibleLocalIdKind {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///ProgrammaticScryptoSborValueOwn
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "kind": {
    ///          "type": "string",
    ///          "enum": [
    ///            "Own"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/Address"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ProgrammaticScryptoSborValueOwn {
        /**The name of the field which hosts this value.
This property is only included if this value is a child of a `Tuple` or `Enum` with named fields.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub field_name: Option<String>,
        pub kind: ProgrammaticScryptoSborValueOwnKind,
        /**The name of the type of this value.
This is only output when a schema is present and the type has a name.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub type_name: Option<String>,
        pub value: Address,
    }
    impl From<&ProgrammaticScryptoSborValueOwn> for ProgrammaticScryptoSborValueOwn {
        fn from(value: &ProgrammaticScryptoSborValueOwn) -> Self {
            value.clone()
        }
    }
    impl ProgrammaticScryptoSborValueOwn {
        pub fn builder() -> builder::ProgrammaticScryptoSborValueOwn {
            Default::default()
        }
    }
    ///ProgrammaticScryptoSborValueOwnKind
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "Own"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum ProgrammaticScryptoSborValueOwnKind {
        Own,
    }
    impl From<&ProgrammaticScryptoSborValueOwnKind>
    for ProgrammaticScryptoSborValueOwnKind {
        fn from(value: &ProgrammaticScryptoSborValueOwnKind) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for ProgrammaticScryptoSborValueOwnKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Own => write!(f, "Own"),
            }
        }
    }
    impl std::str::FromStr for ProgrammaticScryptoSborValueOwnKind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "Own" => Ok(Self::Own),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for ProgrammaticScryptoSborValueOwnKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for ProgrammaticScryptoSborValueOwnKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for ProgrammaticScryptoSborValueOwnKind {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///ProgrammaticScryptoSborValuePreciseDecimal
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "kind": {
    ///          "type": "string",
    ///          "enum": [
    ///            "PreciseDecimal"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ProgrammaticScryptoSborValuePreciseDecimal {
        /**The name of the field which hosts this value.
This property is only included if this value is a child of a `Tuple` or `Enum` with named fields.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub field_name: Option<String>,
        pub kind: ProgrammaticScryptoSborValuePreciseDecimalKind,
        /**The name of the type of this value.
This is only output when a schema is present and the type has a name.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub type_name: Option<String>,
        pub value: String,
    }
    impl From<&ProgrammaticScryptoSborValuePreciseDecimal>
    for ProgrammaticScryptoSborValuePreciseDecimal {
        fn from(value: &ProgrammaticScryptoSborValuePreciseDecimal) -> Self {
            value.clone()
        }
    }
    impl ProgrammaticScryptoSborValuePreciseDecimal {
        pub fn builder() -> builder::ProgrammaticScryptoSborValuePreciseDecimal {
            Default::default()
        }
    }
    ///ProgrammaticScryptoSborValuePreciseDecimalKind
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "PreciseDecimal"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum ProgrammaticScryptoSborValuePreciseDecimalKind {
        PreciseDecimal,
    }
    impl From<&ProgrammaticScryptoSborValuePreciseDecimalKind>
    for ProgrammaticScryptoSborValuePreciseDecimalKind {
        fn from(value: &ProgrammaticScryptoSborValuePreciseDecimalKind) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for ProgrammaticScryptoSborValuePreciseDecimalKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::PreciseDecimal => write!(f, "PreciseDecimal"),
            }
        }
    }
    impl std::str::FromStr for ProgrammaticScryptoSborValuePreciseDecimalKind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "PreciseDecimal" => Ok(Self::PreciseDecimal),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for ProgrammaticScryptoSborValuePreciseDecimalKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String>
    for ProgrammaticScryptoSborValuePreciseDecimalKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String>
    for ProgrammaticScryptoSborValuePreciseDecimalKind {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///ProgrammaticScryptoSborValueReference
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "kind": {
    ///          "type": "string",
    ///          "enum": [
    ///            "Reference"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/Address"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ProgrammaticScryptoSborValueReference {
        /**The name of the field which hosts this value.
This property is only included if this value is a child of a `Tuple` or `Enum` with named fields.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub field_name: Option<String>,
        pub kind: ProgrammaticScryptoSborValueReferenceKind,
        /**The name of the type of this value.
This is only output when a schema is present and the type has a name.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub type_name: Option<String>,
        pub value: Address,
    }
    impl From<&ProgrammaticScryptoSborValueReference>
    for ProgrammaticScryptoSborValueReference {
        fn from(value: &ProgrammaticScryptoSborValueReference) -> Self {
            value.clone()
        }
    }
    impl ProgrammaticScryptoSborValueReference {
        pub fn builder() -> builder::ProgrammaticScryptoSborValueReference {
            Default::default()
        }
    }
    ///ProgrammaticScryptoSborValueReferenceKind
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "Reference"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum ProgrammaticScryptoSborValueReferenceKind {
        Reference,
    }
    impl From<&ProgrammaticScryptoSborValueReferenceKind>
    for ProgrammaticScryptoSborValueReferenceKind {
        fn from(value: &ProgrammaticScryptoSborValueReferenceKind) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for ProgrammaticScryptoSborValueReferenceKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Reference => write!(f, "Reference"),
            }
        }
    }
    impl std::str::FromStr for ProgrammaticScryptoSborValueReferenceKind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "Reference" => Ok(Self::Reference),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for ProgrammaticScryptoSborValueReferenceKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for ProgrammaticScryptoSborValueReferenceKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for ProgrammaticScryptoSborValueReferenceKind {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///ProgrammaticScryptoSborValueString
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "kind": {
    ///          "type": "string",
    ///          "enum": [
    ///            "String"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ProgrammaticScryptoSborValueString {
        /**The name of the field which hosts this value.
This property is only included if this value is a child of a `Tuple` or `Enum` with named fields.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub field_name: Option<String>,
        pub kind: ProgrammaticScryptoSborValueStringKind,
        /**The name of the type of this value.
This is only output when a schema is present and the type has a name.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub type_name: Option<String>,
        pub value: String,
    }
    impl From<&ProgrammaticScryptoSborValueString>
    for ProgrammaticScryptoSborValueString {
        fn from(value: &ProgrammaticScryptoSborValueString) -> Self {
            value.clone()
        }
    }
    impl ProgrammaticScryptoSborValueString {
        pub fn builder() -> builder::ProgrammaticScryptoSborValueString {
            Default::default()
        }
    }
    ///ProgrammaticScryptoSborValueStringKind
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "String"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum ProgrammaticScryptoSborValueStringKind {
        String,
    }
    impl From<&ProgrammaticScryptoSborValueStringKind>
    for ProgrammaticScryptoSborValueStringKind {
        fn from(value: &ProgrammaticScryptoSborValueStringKind) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for ProgrammaticScryptoSborValueStringKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::String => write!(f, "String"),
            }
        }
    }
    impl std::str::FromStr for ProgrammaticScryptoSborValueStringKind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "String" => Ok(Self::String),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for ProgrammaticScryptoSborValueStringKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for ProgrammaticScryptoSborValueStringKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for ProgrammaticScryptoSborValueStringKind {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///ProgrammaticScryptoSborValueTuple
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "fields"
    ///      ],
    ///      "properties": {
    ///        "fields": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/ProgrammaticScryptoSborValue"
    ///          }
    ///        },
    ///        "kind": {
    ///          "type": "string",
    ///          "enum": [
    ///            "Tuple"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ProgrammaticScryptoSborValueTuple {
        /**The name of the field which hosts this value.
This property is only included if this value is a child of a `Tuple` or `Enum` with named fields.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub field_name: Option<String>,
        pub fields: Vec<ProgrammaticScryptoSborValue>,
        pub kind: ProgrammaticScryptoSborValueTupleKind,
        /**The name of the type of this value.
This is only output when a schema is present and the type has a name.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub type_name: Option<String>,
    }
    impl From<&ProgrammaticScryptoSborValueTuple> for ProgrammaticScryptoSborValueTuple {
        fn from(value: &ProgrammaticScryptoSborValueTuple) -> Self {
            value.clone()
        }
    }
    impl ProgrammaticScryptoSborValueTuple {
        pub fn builder() -> builder::ProgrammaticScryptoSborValueTuple {
            Default::default()
        }
    }
    ///ProgrammaticScryptoSborValueTupleKind
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "Tuple"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum ProgrammaticScryptoSborValueTupleKind {
        Tuple,
    }
    impl From<&ProgrammaticScryptoSborValueTupleKind>
    for ProgrammaticScryptoSborValueTupleKind {
        fn from(value: &ProgrammaticScryptoSborValueTupleKind) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for ProgrammaticScryptoSborValueTupleKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Tuple => write!(f, "Tuple"),
            }
        }
    }
    impl std::str::FromStr for ProgrammaticScryptoSborValueTupleKind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "Tuple" => Ok(Self::Tuple),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for ProgrammaticScryptoSborValueTupleKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for ProgrammaticScryptoSborValueTupleKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for ProgrammaticScryptoSborValueTupleKind {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///ProgrammaticScryptoSborValueU128
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "kind": {
    ///          "type": "string",
    ///          "enum": [
    ///            "U128"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ProgrammaticScryptoSborValueU128 {
        /**The name of the field which hosts this value.
This property is only included if this value is a child of a `Tuple` or `Enum` with named fields.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub field_name: Option<String>,
        pub kind: ProgrammaticScryptoSborValueU128Kind,
        /**The name of the type of this value.
This is only output when a schema is present and the type has a name.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub type_name: Option<String>,
        pub value: String,
    }
    impl From<&ProgrammaticScryptoSborValueU128> for ProgrammaticScryptoSborValueU128 {
        fn from(value: &ProgrammaticScryptoSborValueU128) -> Self {
            value.clone()
        }
    }
    impl ProgrammaticScryptoSborValueU128 {
        pub fn builder() -> builder::ProgrammaticScryptoSborValueU128 {
            Default::default()
        }
    }
    ///ProgrammaticScryptoSborValueU128Kind
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "U128"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum ProgrammaticScryptoSborValueU128Kind {
        U128,
    }
    impl From<&ProgrammaticScryptoSborValueU128Kind>
    for ProgrammaticScryptoSborValueU128Kind {
        fn from(value: &ProgrammaticScryptoSborValueU128Kind) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for ProgrammaticScryptoSborValueU128Kind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::U128 => write!(f, "U128"),
            }
        }
    }
    impl std::str::FromStr for ProgrammaticScryptoSborValueU128Kind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "U128" => Ok(Self::U128),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for ProgrammaticScryptoSborValueU128Kind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for ProgrammaticScryptoSborValueU128Kind {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for ProgrammaticScryptoSborValueU128Kind {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///ProgrammaticScryptoSborValueU16
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "kind": {
    ///          "type": "string",
    ///          "enum": [
    ///            "U16"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ProgrammaticScryptoSborValueU16 {
        /**The name of the field which hosts this value.
This property is only included if this value is a child of a `Tuple` or `Enum` with named fields.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub field_name: Option<String>,
        pub kind: ProgrammaticScryptoSborValueU16Kind,
        /**The name of the type of this value.
This is only output when a schema is present and the type has a name.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub type_name: Option<String>,
        pub value: String,
    }
    impl From<&ProgrammaticScryptoSborValueU16> for ProgrammaticScryptoSborValueU16 {
        fn from(value: &ProgrammaticScryptoSborValueU16) -> Self {
            value.clone()
        }
    }
    impl ProgrammaticScryptoSborValueU16 {
        pub fn builder() -> builder::ProgrammaticScryptoSborValueU16 {
            Default::default()
        }
    }
    ///ProgrammaticScryptoSborValueU16Kind
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "U16"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum ProgrammaticScryptoSborValueU16Kind {
        U16,
    }
    impl From<&ProgrammaticScryptoSborValueU16Kind>
    for ProgrammaticScryptoSborValueU16Kind {
        fn from(value: &ProgrammaticScryptoSborValueU16Kind) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for ProgrammaticScryptoSborValueU16Kind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::U16 => write!(f, "U16"),
            }
        }
    }
    impl std::str::FromStr for ProgrammaticScryptoSborValueU16Kind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "U16" => Ok(Self::U16),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for ProgrammaticScryptoSborValueU16Kind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for ProgrammaticScryptoSborValueU16Kind {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for ProgrammaticScryptoSborValueU16Kind {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///ProgrammaticScryptoSborValueU32
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "kind": {
    ///          "type": "string",
    ///          "enum": [
    ///            "U32"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ProgrammaticScryptoSborValueU32 {
        /**The name of the field which hosts this value.
This property is only included if this value is a child of a `Tuple` or `Enum` with named fields.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub field_name: Option<String>,
        pub kind: ProgrammaticScryptoSborValueU32Kind,
        /**The name of the type of this value.
This is only output when a schema is present and the type has a name.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub type_name: Option<String>,
        pub value: String,
    }
    impl From<&ProgrammaticScryptoSborValueU32> for ProgrammaticScryptoSborValueU32 {
        fn from(value: &ProgrammaticScryptoSborValueU32) -> Self {
            value.clone()
        }
    }
    impl ProgrammaticScryptoSborValueU32 {
        pub fn builder() -> builder::ProgrammaticScryptoSborValueU32 {
            Default::default()
        }
    }
    ///ProgrammaticScryptoSborValueU32Kind
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "U32"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum ProgrammaticScryptoSborValueU32Kind {
        U32,
    }
    impl From<&ProgrammaticScryptoSborValueU32Kind>
    for ProgrammaticScryptoSborValueU32Kind {
        fn from(value: &ProgrammaticScryptoSborValueU32Kind) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for ProgrammaticScryptoSborValueU32Kind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::U32 => write!(f, "U32"),
            }
        }
    }
    impl std::str::FromStr for ProgrammaticScryptoSborValueU32Kind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "U32" => Ok(Self::U32),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for ProgrammaticScryptoSborValueU32Kind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for ProgrammaticScryptoSborValueU32Kind {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for ProgrammaticScryptoSborValueU32Kind {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///ProgrammaticScryptoSborValueU64
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "kind": {
    ///          "type": "string",
    ///          "enum": [
    ///            "U64"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ProgrammaticScryptoSborValueU64 {
        /**The name of the field which hosts this value.
This property is only included if this value is a child of a `Tuple` or `Enum` with named fields.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub field_name: Option<String>,
        pub kind: ProgrammaticScryptoSborValueU64Kind,
        /**The name of the type of this value.
This is only output when a schema is present and the type has a name.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub type_name: Option<String>,
        pub value: String,
    }
    impl From<&ProgrammaticScryptoSborValueU64> for ProgrammaticScryptoSborValueU64 {
        fn from(value: &ProgrammaticScryptoSborValueU64) -> Self {
            value.clone()
        }
    }
    impl ProgrammaticScryptoSborValueU64 {
        pub fn builder() -> builder::ProgrammaticScryptoSborValueU64 {
            Default::default()
        }
    }
    ///ProgrammaticScryptoSborValueU64Kind
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "U64"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum ProgrammaticScryptoSborValueU64Kind {
        U64,
    }
    impl From<&ProgrammaticScryptoSborValueU64Kind>
    for ProgrammaticScryptoSborValueU64Kind {
        fn from(value: &ProgrammaticScryptoSborValueU64Kind) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for ProgrammaticScryptoSborValueU64Kind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::U64 => write!(f, "U64"),
            }
        }
    }
    impl std::str::FromStr for ProgrammaticScryptoSborValueU64Kind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "U64" => Ok(Self::U64),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for ProgrammaticScryptoSborValueU64Kind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for ProgrammaticScryptoSborValueU64Kind {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for ProgrammaticScryptoSborValueU64Kind {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///ProgrammaticScryptoSborValueU8
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValueBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "kind": {
    ///          "type": "string",
    ///          "enum": [
    ///            "U8"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ProgrammaticScryptoSborValueU8 {
        /**The name of the field which hosts this value.
This property is only included if this value is a child of a `Tuple` or `Enum` with named fields.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub field_name: Option<String>,
        pub kind: ProgrammaticScryptoSborValueU8Kind,
        /**The name of the type of this value.
This is only output when a schema is present and the type has a name.
This property is ignored when the value is used as an input to the API.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub type_name: Option<String>,
        pub value: String,
    }
    impl From<&ProgrammaticScryptoSborValueU8> for ProgrammaticScryptoSborValueU8 {
        fn from(value: &ProgrammaticScryptoSborValueU8) -> Self {
            value.clone()
        }
    }
    impl ProgrammaticScryptoSborValueU8 {
        pub fn builder() -> builder::ProgrammaticScryptoSborValueU8 {
            Default::default()
        }
    }
    ///ProgrammaticScryptoSborValueU8Kind
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "U8"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum ProgrammaticScryptoSborValueU8Kind {
        U8,
    }
    impl From<&ProgrammaticScryptoSborValueU8Kind>
    for ProgrammaticScryptoSborValueU8Kind {
        fn from(value: &ProgrammaticScryptoSborValueU8Kind) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for ProgrammaticScryptoSborValueU8Kind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::U8 => write!(f, "U8"),
            }
        }
    }
    impl std::str::FromStr for ProgrammaticScryptoSborValueU8Kind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "U8" => Ok(Self::U8),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for ProgrammaticScryptoSborValueU8Kind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for ProgrammaticScryptoSborValueU8Kind {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for ProgrammaticScryptoSborValueU8Kind {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///PublicKey
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/PublicKeyEcdsaSecp256k1"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/PublicKeyEddsaEd25519"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum PublicKey {
        EcdsaSecp256k1(PublicKeyEcdsaSecp256k1),
        EddsaEd25519(PublicKeyEddsaEd25519),
    }
    impl From<&PublicKey> for PublicKey {
        fn from(value: &PublicKey) -> Self {
            value.clone()
        }
    }
    impl From<PublicKeyEcdsaSecp256k1> for PublicKey {
        fn from(value: PublicKeyEcdsaSecp256k1) -> Self {
            Self::EcdsaSecp256k1(value)
        }
    }
    impl From<PublicKeyEddsaEd25519> for PublicKey {
        fn from(value: PublicKeyEddsaEd25519) -> Self {
            Self::EddsaEd25519(value)
        }
    }
    ///PublicKeyBase
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "key_type"
    ///  ],
    ///  "properties": {
    ///    "key_type": {
    ///      "$ref": "#/components/schemas/PublicKeyType"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PublicKeyBase {
        pub key_type: PublicKeyType,
    }
    impl From<&PublicKeyBase> for PublicKeyBase {
        fn from(value: &PublicKeyBase) -> Self {
            value.clone()
        }
    }
    impl PublicKeyBase {
        pub fn builder() -> builder::PublicKeyBase {
            Default::default()
        }
    }
    ///PublicKeyEcdsaSecp256k1
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/PublicKeyBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "key_hex"
    ///      ],
    ///      "properties": {
    ///        "key_hex": {
    ///          "description": "The hex-encoded compressed ECDSA Secp256k1 public key (33 bytes)",
    ///          "type": "string",
    ///          "maxLength": 66,
    ///          "minLength": 66
    ///        },
    ///        "key_type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "EcdsaSecp256k1"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PublicKeyEcdsaSecp256k1 {
        ///The hex-encoded compressed ECDSA Secp256k1 public key (33 bytes)
        pub key_hex: PublicKeyEcdsaSecp256k1KeyHex,
        pub key_type: PublicKeyEcdsaSecp256k1KeyType,
    }
    impl From<&PublicKeyEcdsaSecp256k1> for PublicKeyEcdsaSecp256k1 {
        fn from(value: &PublicKeyEcdsaSecp256k1) -> Self {
            value.clone()
        }
    }
    impl PublicKeyEcdsaSecp256k1 {
        pub fn builder() -> builder::PublicKeyEcdsaSecp256k1 {
            Default::default()
        }
    }
    ///The hex-encoded compressed ECDSA Secp256k1 public key (33 bytes)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The hex-encoded compressed ECDSA Secp256k1 public key (33 bytes)",
    ///  "type": "string",
    ///  "maxLength": 66,
    ///  "minLength": 66
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct PublicKeyEcdsaSecp256k1KeyHex(String);
    impl ::std::ops::Deref for PublicKeyEcdsaSecp256k1KeyHex {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<PublicKeyEcdsaSecp256k1KeyHex> for String {
        fn from(value: PublicKeyEcdsaSecp256k1KeyHex) -> Self {
            value.0
        }
    }
    impl From<&PublicKeyEcdsaSecp256k1KeyHex> for PublicKeyEcdsaSecp256k1KeyHex {
        fn from(value: &PublicKeyEcdsaSecp256k1KeyHex) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for PublicKeyEcdsaSecp256k1KeyHex {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 66usize {
                return Err("longer than 66 characters".into());
            }
            if value.len() < 66usize {
                return Err("shorter than 66 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for PublicKeyEcdsaSecp256k1KeyHex {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for PublicKeyEcdsaSecp256k1KeyHex {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for PublicKeyEcdsaSecp256k1KeyHex {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PublicKeyEcdsaSecp256k1KeyHex {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///PublicKeyEcdsaSecp256k1KeyType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "EcdsaSecp256k1"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PublicKeyEcdsaSecp256k1KeyType {
        EcdsaSecp256k1,
    }
    impl From<&PublicKeyEcdsaSecp256k1KeyType> for PublicKeyEcdsaSecp256k1KeyType {
        fn from(value: &PublicKeyEcdsaSecp256k1KeyType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for PublicKeyEcdsaSecp256k1KeyType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EcdsaSecp256k1 => write!(f, "EcdsaSecp256k1"),
            }
        }
    }
    impl std::str::FromStr for PublicKeyEcdsaSecp256k1KeyType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "EcdsaSecp256k1" => Ok(Self::EcdsaSecp256k1),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for PublicKeyEcdsaSecp256k1KeyType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for PublicKeyEcdsaSecp256k1KeyType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for PublicKeyEcdsaSecp256k1KeyType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///PublicKeyEddsaEd25519
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/PublicKeyBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "key_hex"
    ///      ],
    ///      "properties": {
    ///        "key_hex": {
    ///          "description": "The hex-encoded compressed EdDSA Ed25519 public key (32 bytes)",
    ///          "type": "string",
    ///          "maxLength": 64,
    ///          "minLength": 64
    ///        },
    ///        "key_type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "EddsaEd25519"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PublicKeyEddsaEd25519 {
        ///The hex-encoded compressed EdDSA Ed25519 public key (32 bytes)
        pub key_hex: PublicKeyEddsaEd25519KeyHex,
        pub key_type: PublicKeyEddsaEd25519KeyType,
    }
    impl From<&PublicKeyEddsaEd25519> for PublicKeyEddsaEd25519 {
        fn from(value: &PublicKeyEddsaEd25519) -> Self {
            value.clone()
        }
    }
    impl PublicKeyEddsaEd25519 {
        pub fn builder() -> builder::PublicKeyEddsaEd25519 {
            Default::default()
        }
    }
    ///The hex-encoded compressed EdDSA Ed25519 public key (32 bytes)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The hex-encoded compressed EdDSA Ed25519 public key (32 bytes)",
    ///  "type": "string",
    ///  "maxLength": 64,
    ///  "minLength": 64
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct PublicKeyEddsaEd25519KeyHex(String);
    impl ::std::ops::Deref for PublicKeyEddsaEd25519KeyHex {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<PublicKeyEddsaEd25519KeyHex> for String {
        fn from(value: PublicKeyEddsaEd25519KeyHex) -> Self {
            value.0
        }
    }
    impl From<&PublicKeyEddsaEd25519KeyHex> for PublicKeyEddsaEd25519KeyHex {
        fn from(value: &PublicKeyEddsaEd25519KeyHex) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for PublicKeyEddsaEd25519KeyHex {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 64usize {
                return Err("longer than 64 characters".into());
            }
            if value.len() < 64usize {
                return Err("shorter than 64 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for PublicKeyEddsaEd25519KeyHex {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for PublicKeyEddsaEd25519KeyHex {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for PublicKeyEddsaEd25519KeyHex {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PublicKeyEddsaEd25519KeyHex {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    ///PublicKeyEddsaEd25519KeyType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "EddsaEd25519"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PublicKeyEddsaEd25519KeyType {
        EddsaEd25519,
    }
    impl From<&PublicKeyEddsaEd25519KeyType> for PublicKeyEddsaEd25519KeyType {
        fn from(value: &PublicKeyEddsaEd25519KeyType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for PublicKeyEddsaEd25519KeyType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EddsaEd25519 => write!(f, "EddsaEd25519"),
            }
        }
    }
    impl std::str::FromStr for PublicKeyEddsaEd25519KeyType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "EddsaEd25519" => Ok(Self::EddsaEd25519),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for PublicKeyEddsaEd25519KeyType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for PublicKeyEddsaEd25519KeyType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for PublicKeyEddsaEd25519KeyType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///PublicKeyHash
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/PublicKeyHashEcdsaSecp256k1"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/PublicKeyHashEddsaEd25519"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum PublicKeyHash {
        EcdsaSecp256k1(PublicKeyHashEcdsaSecp256k1),
        EddsaEd25519(PublicKeyHashEddsaEd25519),
    }
    impl From<&PublicKeyHash> for PublicKeyHash {
        fn from(value: &PublicKeyHash) -> Self {
            value.clone()
        }
    }
    impl From<PublicKeyHashEcdsaSecp256k1> for PublicKeyHash {
        fn from(value: PublicKeyHashEcdsaSecp256k1) -> Self {
            Self::EcdsaSecp256k1(value)
        }
    }
    impl From<PublicKeyHashEddsaEd25519> for PublicKeyHash {
        fn from(value: PublicKeyHashEddsaEd25519) -> Self {
            Self::EddsaEd25519(value)
        }
    }
    ///PublicKeyHashBase
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "key_hash_type"
    ///  ],
    ///  "properties": {
    ///    "key_hash_type": {
    ///      "$ref": "#/components/schemas/PublicKeyHashType"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PublicKeyHashBase {
        pub key_hash_type: PublicKeyHashType,
    }
    impl From<&PublicKeyHashBase> for PublicKeyHashBase {
        fn from(value: &PublicKeyHashBase) -> Self {
            value.clone()
        }
    }
    impl PublicKeyHashBase {
        pub fn builder() -> builder::PublicKeyHashBase {
            Default::default()
        }
    }
    ///PublicKeyHashEcdsaSecp256k1
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/PublicKeyHashBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "hash_hex"
    ///      ],
    ///      "properties": {
    ///        "hash_hex": {
    ///          "$ref": "#/components/schemas/HashHexString"
    ///        },
    ///        "key_hash_type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "EcdsaSecp256k1"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PublicKeyHashEcdsaSecp256k1 {
        pub hash_hex: HashHexString,
        pub key_hash_type: PublicKeyHashEcdsaSecp256k1KeyHashType,
    }
    impl From<&PublicKeyHashEcdsaSecp256k1> for PublicKeyHashEcdsaSecp256k1 {
        fn from(value: &PublicKeyHashEcdsaSecp256k1) -> Self {
            value.clone()
        }
    }
    impl PublicKeyHashEcdsaSecp256k1 {
        pub fn builder() -> builder::PublicKeyHashEcdsaSecp256k1 {
            Default::default()
        }
    }
    ///PublicKeyHashEcdsaSecp256k1KeyHashType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "EcdsaSecp256k1"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PublicKeyHashEcdsaSecp256k1KeyHashType {
        EcdsaSecp256k1,
    }
    impl From<&PublicKeyHashEcdsaSecp256k1KeyHashType>
    for PublicKeyHashEcdsaSecp256k1KeyHashType {
        fn from(value: &PublicKeyHashEcdsaSecp256k1KeyHashType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for PublicKeyHashEcdsaSecp256k1KeyHashType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EcdsaSecp256k1 => write!(f, "EcdsaSecp256k1"),
            }
        }
    }
    impl std::str::FromStr for PublicKeyHashEcdsaSecp256k1KeyHashType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "EcdsaSecp256k1" => Ok(Self::EcdsaSecp256k1),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for PublicKeyHashEcdsaSecp256k1KeyHashType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for PublicKeyHashEcdsaSecp256k1KeyHashType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for PublicKeyHashEcdsaSecp256k1KeyHashType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///PublicKeyHashEddsaEd25519
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/PublicKeyHashBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "hash_hex"
    ///      ],
    ///      "properties": {
    ///        "hash_hex": {
    ///          "$ref": "#/components/schemas/HashHexString"
    ///        },
    ///        "key_hash_type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "EddsaEd25519"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PublicKeyHashEddsaEd25519 {
        pub hash_hex: HashHexString,
        pub key_hash_type: PublicKeyHashEddsaEd25519KeyHashType,
    }
    impl From<&PublicKeyHashEddsaEd25519> for PublicKeyHashEddsaEd25519 {
        fn from(value: &PublicKeyHashEddsaEd25519) -> Self {
            value.clone()
        }
    }
    impl PublicKeyHashEddsaEd25519 {
        pub fn builder() -> builder::PublicKeyHashEddsaEd25519 {
            Default::default()
        }
    }
    ///PublicKeyHashEddsaEd25519KeyHashType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "EddsaEd25519"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PublicKeyHashEddsaEd25519KeyHashType {
        EddsaEd25519,
    }
    impl From<&PublicKeyHashEddsaEd25519KeyHashType>
    for PublicKeyHashEddsaEd25519KeyHashType {
        fn from(value: &PublicKeyHashEddsaEd25519KeyHashType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for PublicKeyHashEddsaEd25519KeyHashType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EddsaEd25519 => write!(f, "EddsaEd25519"),
            }
        }
    }
    impl std::str::FromStr for PublicKeyHashEddsaEd25519KeyHashType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "EddsaEd25519" => Ok(Self::EddsaEd25519),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for PublicKeyHashEddsaEd25519KeyHashType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for PublicKeyHashEddsaEd25519KeyHashType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for PublicKeyHashEddsaEd25519KeyHashType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///PublicKeyHashType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "EcdsaSecp256k1",
    ///    "EddsaEd25519"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PublicKeyHashType {
        EcdsaSecp256k1,
        EddsaEd25519,
    }
    impl From<&PublicKeyHashType> for PublicKeyHashType {
        fn from(value: &PublicKeyHashType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for PublicKeyHashType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EcdsaSecp256k1 => write!(f, "EcdsaSecp256k1"),
                Self::EddsaEd25519 => write!(f, "EddsaEd25519"),
            }
        }
    }
    impl std::str::FromStr for PublicKeyHashType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "EcdsaSecp256k1" => Ok(Self::EcdsaSecp256k1),
                "EddsaEd25519" => Ok(Self::EddsaEd25519),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for PublicKeyHashType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for PublicKeyHashType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for PublicKeyHashType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///PublicKeyType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "EcdsaSecp256k1",
    ///    "EddsaEd25519"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PublicKeyType {
        EcdsaSecp256k1,
        EddsaEd25519,
    }
    impl From<&PublicKeyType> for PublicKeyType {
        fn from(value: &PublicKeyType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for PublicKeyType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EcdsaSecp256k1 => write!(f, "EcdsaSecp256k1"),
                Self::EddsaEd25519 => write!(f, "EddsaEd25519"),
            }
        }
    }
    impl std::str::FromStr for PublicKeyType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "EcdsaSecp256k1" => Ok(Self::EcdsaSecp256k1),
                "EddsaEd25519" => Ok(Self::EddsaEd25519),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for PublicKeyType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for PublicKeyType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for PublicKeyType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///ResourceAggregationLevel
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "Global",
    ///    "Vault"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum ResourceAggregationLevel {
        Global,
        Vault,
    }
    impl From<&ResourceAggregationLevel> for ResourceAggregationLevel {
        fn from(value: &ResourceAggregationLevel) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for ResourceAggregationLevel {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Global => write!(f, "Global"),
                Self::Vault => write!(f, "Vault"),
            }
        }
    }
    impl std::str::FromStr for ResourceAggregationLevel {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "Global" => Ok(Self::Global),
                "Vault" => Ok(Self::Vault),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for ResourceAggregationLevel {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for ResourceAggregationLevel {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for ResourceAggregationLevel {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///ResourceHoldersCollection
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ResultSetCursorMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "items"
    ///      ],
    ///      "properties": {
    ///        "items": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/ResourceHoldersCollectionItem"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ResourceHoldersCollection {
        pub items: Vec<ResourceHoldersCollectionItem>,
        ///If specified, contains a cursor to query next page of the `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_cursor: Option<String>,
        ///Total number of items in underlying collection, fragment of which is available in `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_count: Option<i64>,
    }
    impl From<&ResourceHoldersCollection> for ResourceHoldersCollection {
        fn from(value: &ResourceHoldersCollection) -> Self {
            value.clone()
        }
    }
    impl ResourceHoldersCollection {
        pub fn builder() -> builder::ResourceHoldersCollection {
            Default::default()
        }
    }
    ///ResourceHoldersCollectionFungibleResourceItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ResourceHoldersCollectionItemBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "amount"
    ///      ],
    ///      "properties": {
    ///        "amount": {
    ///          "$ref": "#/components/schemas/BigDecimal"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "FungibleResource"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ResourceHoldersCollectionFungibleResourceItem {
        pub amount: BigDecimal,
        pub holder_address: Address,
        pub last_updated_at_state_version: i64,
        #[serde(rename = "type")]
        pub type_: ResourceHoldersCollectionFungibleResourceItemType,
    }
    impl From<&ResourceHoldersCollectionFungibleResourceItem>
    for ResourceHoldersCollectionFungibleResourceItem {
        fn from(value: &ResourceHoldersCollectionFungibleResourceItem) -> Self {
            value.clone()
        }
    }
    impl ResourceHoldersCollectionFungibleResourceItem {
        pub fn builder() -> builder::ResourceHoldersCollectionFungibleResourceItem {
            Default::default()
        }
    }
    ///ResourceHoldersCollectionFungibleResourceItemType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "FungibleResource"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum ResourceHoldersCollectionFungibleResourceItemType {
        FungibleResource,
    }
    impl From<&ResourceHoldersCollectionFungibleResourceItemType>
    for ResourceHoldersCollectionFungibleResourceItemType {
        fn from(value: &ResourceHoldersCollectionFungibleResourceItemType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for ResourceHoldersCollectionFungibleResourceItemType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::FungibleResource => write!(f, "FungibleResource"),
            }
        }
    }
    impl std::str::FromStr for ResourceHoldersCollectionFungibleResourceItemType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "FungibleResource" => Ok(Self::FungibleResource),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str>
    for ResourceHoldersCollectionFungibleResourceItemType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String>
    for ResourceHoldersCollectionFungibleResourceItemType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String>
    for ResourceHoldersCollectionFungibleResourceItemType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///ResourceHoldersCollectionItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ResourceHoldersCollectionFungibleResourceItem"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/ResourceHoldersCollectionNonFungibleResourceItem"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum ResourceHoldersCollectionItem {
        FungibleResourceItem(ResourceHoldersCollectionFungibleResourceItem),
        NonFungibleResourceItem(ResourceHoldersCollectionNonFungibleResourceItem),
    }
    impl From<&ResourceHoldersCollectionItem> for ResourceHoldersCollectionItem {
        fn from(value: &ResourceHoldersCollectionItem) -> Self {
            value.clone()
        }
    }
    impl From<ResourceHoldersCollectionFungibleResourceItem>
    for ResourceHoldersCollectionItem {
        fn from(value: ResourceHoldersCollectionFungibleResourceItem) -> Self {
            Self::FungibleResourceItem(value)
        }
    }
    impl From<ResourceHoldersCollectionNonFungibleResourceItem>
    for ResourceHoldersCollectionItem {
        fn from(value: ResourceHoldersCollectionNonFungibleResourceItem) -> Self {
            Self::NonFungibleResourceItem(value)
        }
    }
    ///ResourceHoldersCollectionItemBase
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "holder_address",
    ///    "last_updated_at_state_version",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "holder_address": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "last_updated_at_state_version": {
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "type": {
    ///      "$ref": "#/components/schemas/ResourceHoldersResourceType"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ResourceHoldersCollectionItemBase {
        pub holder_address: Address,
        pub last_updated_at_state_version: i64,
        #[serde(rename = "type")]
        pub type_: ResourceHoldersResourceType,
    }
    impl From<&ResourceHoldersCollectionItemBase> for ResourceHoldersCollectionItemBase {
        fn from(value: &ResourceHoldersCollectionItemBase) -> Self {
            value.clone()
        }
    }
    impl ResourceHoldersCollectionItemBase {
        pub fn builder() -> builder::ResourceHoldersCollectionItemBase {
            Default::default()
        }
    }
    ///ResourceHoldersCollectionNonFungibleResourceItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ResourceHoldersCollectionItemBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "non_fungible_ids_count"
    ///      ],
    ///      "properties": {
    ///        "non_fungible_ids_count": {
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "NonFungibleResource"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ResourceHoldersCollectionNonFungibleResourceItem {
        pub holder_address: Address,
        pub last_updated_at_state_version: i64,
        pub non_fungible_ids_count: i64,
        #[serde(rename = "type")]
        pub type_: ResourceHoldersCollectionNonFungibleResourceItemType,
    }
    impl From<&ResourceHoldersCollectionNonFungibleResourceItem>
    for ResourceHoldersCollectionNonFungibleResourceItem {
        fn from(value: &ResourceHoldersCollectionNonFungibleResourceItem) -> Self {
            value.clone()
        }
    }
    impl ResourceHoldersCollectionNonFungibleResourceItem {
        pub fn builder() -> builder::ResourceHoldersCollectionNonFungibleResourceItem {
            Default::default()
        }
    }
    ///ResourceHoldersCollectionNonFungibleResourceItemType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "NonFungibleResource"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum ResourceHoldersCollectionNonFungibleResourceItemType {
        NonFungibleResource,
    }
    impl From<&ResourceHoldersCollectionNonFungibleResourceItemType>
    for ResourceHoldersCollectionNonFungibleResourceItemType {
        fn from(value: &ResourceHoldersCollectionNonFungibleResourceItemType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for ResourceHoldersCollectionNonFungibleResourceItemType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::NonFungibleResource => write!(f, "NonFungibleResource"),
            }
        }
    }
    impl std::str::FromStr for ResourceHoldersCollectionNonFungibleResourceItemType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "NonFungibleResource" => Ok(Self::NonFungibleResource),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str>
    for ResourceHoldersCollectionNonFungibleResourceItemType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String>
    for ResourceHoldersCollectionNonFungibleResourceItemType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String>
    for ResourceHoldersCollectionNonFungibleResourceItemType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///ResourceHoldersRequest
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "limit_per_page": 100,
    ///      "resource_address": "<resource-address>"
    ///    }
    ///  ],
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/CursorLimitMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "properties": {
    ///        "resource_address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ResourceHoldersRequest {
        ///This cursor allows forward pagination, by providing the cursor from the previous request.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub cursor: Option<String>,
        ///The page size requested.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub limit_per_page: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub resource_address: Option<Address>,
    }
    impl From<&ResourceHoldersRequest> for ResourceHoldersRequest {
        fn from(value: &ResourceHoldersRequest) -> Self {
            value.clone()
        }
    }
    impl ResourceHoldersRequest {
        pub fn builder() -> builder::ResourceHoldersRequest {
            Default::default()
        }
    }
    ///ResourceHoldersResourceType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "FungibleResource",
    ///    "NonFungibleResource"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum ResourceHoldersResourceType {
        FungibleResource,
        NonFungibleResource,
    }
    impl From<&ResourceHoldersResourceType> for ResourceHoldersResourceType {
        fn from(value: &ResourceHoldersResourceType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for ResourceHoldersResourceType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::FungibleResource => write!(f, "FungibleResource"),
                Self::NonFungibleResource => write!(f, "NonFungibleResource"),
            }
        }
    }
    impl std::str::FromStr for ResourceHoldersResourceType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "FungibleResource" => Ok(Self::FungibleResource),
                "NonFungibleResource" => Ok(Self::NonFungibleResource),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for ResourceHoldersResourceType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for ResourceHoldersResourceType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for ResourceHoldersResourceType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///ResourceHoldersResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ResourceHoldersCollection"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ResourceHoldersResponse(pub ResourceHoldersCollection);
    impl ::std::ops::Deref for ResourceHoldersResponse {
        type Target = ResourceHoldersCollection;
        fn deref(&self) -> &ResourceHoldersCollection {
            &self.0
        }
    }
    impl From<ResourceHoldersResponse> for ResourceHoldersCollection {
        fn from(value: ResourceHoldersResponse) -> Self {
            value.0
        }
    }
    impl From<&ResourceHoldersResponse> for ResourceHoldersResponse {
        fn from(value: &ResourceHoldersResponse) -> Self {
            value.clone()
        }
    }
    impl From<ResourceHoldersCollection> for ResourceHoldersResponse {
        fn from(value: ResourceHoldersCollection) -> Self {
            Self(value)
        }
    }
    ///ResultSetCursorMixin
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "next_cursor": {
    ///      "description": "If specified, contains a cursor to query next page of the `items` collection.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "total_count": {
    ///      "description": "Total number of items in underlying collection, fragment of which is available in `items` collection.",
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ],
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ResultSetCursorMixin {
        ///If specified, contains a cursor to query next page of the `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_cursor: Option<String>,
        ///Total number of items in underlying collection, fragment of which is available in `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_count: Option<i64>,
    }
    impl From<&ResultSetCursorMixin> for ResultSetCursorMixin {
        fn from(value: &ResultSetCursorMixin) -> Self {
            value.clone()
        }
    }
    impl ResultSetCursorMixin {
        pub fn builder() -> builder::ResultSetCursorMixin {
            Default::default()
        }
    }
    ///RoleAssignmentResolution
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "Explicit",
    ///    "Owner"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum RoleAssignmentResolution {
        Explicit,
        Owner,
    }
    impl From<&RoleAssignmentResolution> for RoleAssignmentResolution {
        fn from(value: &RoleAssignmentResolution) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for RoleAssignmentResolution {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Explicit => write!(f, "Explicit"),
                Self::Owner => write!(f, "Owner"),
            }
        }
    }
    impl std::str::FromStr for RoleAssignmentResolution {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "Explicit" => Ok(Self::Explicit),
                "Owner" => Ok(Self::Owner),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for RoleAssignmentResolution {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for RoleAssignmentResolution {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for RoleAssignmentResolution {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///RoleKey
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "module",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "module": {
    ///      "$ref": "#/components/schemas/ObjectModuleId"
    ///    },
    ///    "name": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct RoleKey {
        pub module: ObjectModuleId,
        pub name: String,
    }
    impl From<&RoleKey> for RoleKey {
        fn from(value: &RoleKey) -> Self {
            value.clone()
        }
    }
    impl RoleKey {
        pub fn builder() -> builder::RoleKey {
            Default::default()
        }
    }
    ///RoyaltyAmount
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "unit"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "$ref": "#/components/schemas/BigDecimal"
    ///    },
    ///    "unit": {
    ///      "type": "string",
    ///      "enum": [
    ///        "XRD",
    ///        "USD"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct RoyaltyAmount {
        pub amount: BigDecimal,
        pub unit: RoyaltyAmountUnit,
    }
    impl From<&RoyaltyAmount> for RoyaltyAmount {
        fn from(value: &RoyaltyAmount) -> Self {
            value.clone()
        }
    }
    impl RoyaltyAmount {
        pub fn builder() -> builder::RoyaltyAmount {
            Default::default()
        }
    }
    ///RoyaltyAmountUnit
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "XRD",
    ///    "USD"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum RoyaltyAmountUnit {
        #[serde(rename = "XRD")]
        Xrd,
        #[serde(rename = "USD")]
        Usd,
    }
    impl From<&RoyaltyAmountUnit> for RoyaltyAmountUnit {
        fn from(value: &RoyaltyAmountUnit) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for RoyaltyAmountUnit {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Xrd => write!(f, "XRD"),
                Self::Usd => write!(f, "USD"),
            }
        }
    }
    impl std::str::FromStr for RoyaltyAmountUnit {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "XRD" => Ok(Self::Xrd),
                "USD" => Ok(Self::Usd),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for RoyaltyAmountUnit {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for RoyaltyAmountUnit {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for RoyaltyAmountUnit {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///SborData
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "hex",
    ///    "programmatic_json"
    ///  ],
    ///  "properties": {
    ///    "hex": {
    ///      "$ref": "#/components/schemas/HexString"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SborData {
        pub hex: HexString,
        pub programmatic_json: ::serde_json::Value,
    }
    impl From<&SborData> for SborData {
        fn from(value: &SborData) -> Self {
            value.clone()
        }
    }
    impl SborData {
        pub fn builder() -> builder::SborData {
            Default::default()
        }
    }
    ///ScryptoSborValue
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "programmatic_json",
    ///    "raw_hex"
    ///  ],
    ///  "properties": {
    ///    "programmatic_json": {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValue"
    ///    },
    ///    "raw_hex": {
    ///      "$ref": "#/components/schemas/HexString"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ScryptoSborValue {
        pub programmatic_json: ProgrammaticScryptoSborValue,
        pub raw_hex: HexString,
    }
    impl From<&ScryptoSborValue> for ScryptoSborValue {
        fn from(value: &ScryptoSborValue) -> Self {
            value.clone()
        }
    }
    impl ScryptoSborValue {
        pub fn builder() -> builder::ScryptoSborValue {
            Default::default()
        }
    }
    ///StateAccountAuthorizedDepositorsPageRequest
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "account_address": null
    ///    }
    ///  ],
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/AtLedgerStateMixin"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/CursorLimitMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "account_address"
    ///      ],
    ///      "properties": {
    ///        "account_address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateAccountAuthorizedDepositorsPageRequest {
        pub account_address: Address,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub at_ledger_state: Option<LedgerStateSelector>,
        ///This cursor allows forward pagination, by providing the cursor from the previous request.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub cursor: Option<String>,
        ///The page size requested.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub limit_per_page: Option<i64>,
    }
    impl From<&StateAccountAuthorizedDepositorsPageRequest>
    for StateAccountAuthorizedDepositorsPageRequest {
        fn from(value: &StateAccountAuthorizedDepositorsPageRequest) -> Self {
            value.clone()
        }
    }
    impl StateAccountAuthorizedDepositorsPageRequest {
        pub fn builder() -> builder::StateAccountAuthorizedDepositorsPageRequest {
            Default::default()
        }
    }
    ///StateAccountAuthorizedDepositorsPageResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/LedgerStateMixin"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/AccountAuthorizedDepositorsCollection"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "account_address"
    ///      ],
    ///      "properties": {
    ///        "account_address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateAccountAuthorizedDepositorsPageResponse {
        pub account_address: Address,
        pub items: Vec<AccountAuthorizedDepositorsResponseItem>,
        pub ledger_state: LedgerState,
        ///If specified, contains a cursor to query next page of the `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_cursor: Option<String>,
        ///Total number of items in underlying collection, fragment of which is available in `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_count: Option<i64>,
    }
    impl From<&StateAccountAuthorizedDepositorsPageResponse>
    for StateAccountAuthorizedDepositorsPageResponse {
        fn from(value: &StateAccountAuthorizedDepositorsPageResponse) -> Self {
            value.clone()
        }
    }
    impl StateAccountAuthorizedDepositorsPageResponse {
        pub fn builder() -> builder::StateAccountAuthorizedDepositorsPageResponse {
            Default::default()
        }
    }
    ///StateAccountLockerPageVaultsRequest
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "account_address": "<account-address>",
    ///      "locker_address": "<locker-address>"
    ///    }
    ///  ],
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/AtLedgerStateMixin"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/CursorLimitMixin"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/AccountLockerAddress"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateAccountLockerPageVaultsRequest {
        pub account_address: Address,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub at_ledger_state: Option<LedgerStateSelector>,
        ///This cursor allows forward pagination, by providing the cursor from the previous request.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub cursor: Option<String>,
        ///The page size requested.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub limit_per_page: Option<i64>,
        pub locker_address: Address,
    }
    impl From<&StateAccountLockerPageVaultsRequest>
    for StateAccountLockerPageVaultsRequest {
        fn from(value: &StateAccountLockerPageVaultsRequest) -> Self {
            value.clone()
        }
    }
    impl StateAccountLockerPageVaultsRequest {
        pub fn builder() -> builder::StateAccountLockerPageVaultsRequest {
            Default::default()
        }
    }
    ///StateAccountLockerPageVaultsResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/LedgerStateMixin"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/AccountLockerVaultCollection"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/AccountLockerAddress"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateAccountLockerPageVaultsResponse {
        pub account_address: Address,
        pub items: Vec<AccountLockerVaultCollectionItem>,
        pub ledger_state: LedgerState,
        pub locker_address: Address,
        ///If specified, contains a cursor to query next page of the `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_cursor: Option<String>,
        ///Total number of items in underlying collection, fragment of which is available in `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_count: Option<i64>,
    }
    impl From<&StateAccountLockerPageVaultsResponse>
    for StateAccountLockerPageVaultsResponse {
        fn from(value: &StateAccountLockerPageVaultsResponse) -> Self {
            value.clone()
        }
    }
    impl StateAccountLockerPageVaultsResponse {
        pub fn builder() -> builder::StateAccountLockerPageVaultsResponse {
            Default::default()
        }
    }
    ///StateAccountLockersTouchedAtRequest
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "account_lockers": [
    ///        {
    ///          "account_address": "<account-address>",
    ///          "locker_address": "<locker-address>"
    ///        }
    ///      ]
    ///    }
    ///  ],
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/AtLedgerStateMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "account_lockers"
    ///      ],
    ///      "properties": {
    ///        "account_lockers": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/AccountLockerAddress"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateAccountLockersTouchedAtRequest {
        pub account_lockers: Vec<AccountLockerAddress>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub at_ledger_state: Option<LedgerStateSelector>,
    }
    impl From<&StateAccountLockersTouchedAtRequest>
    for StateAccountLockersTouchedAtRequest {
        fn from(value: &StateAccountLockersTouchedAtRequest) -> Self {
            value.clone()
        }
    }
    impl StateAccountLockersTouchedAtRequest {
        pub fn builder() -> builder::StateAccountLockersTouchedAtRequest {
            Default::default()
        }
    }
    ///StateAccountLockersTouchedAtResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/LedgerStateMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "items"
    ///      ],
    ///      "properties": {
    ///        "items": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/StateAccountLockersTouchedAtResponseItem"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateAccountLockersTouchedAtResponse {
        pub items: Vec<StateAccountLockersTouchedAtResponseItem>,
        pub ledger_state: LedgerState,
    }
    impl From<&StateAccountLockersTouchedAtResponse>
    for StateAccountLockersTouchedAtResponse {
        fn from(value: &StateAccountLockersTouchedAtResponse) -> Self {
            value.clone()
        }
    }
    impl StateAccountLockersTouchedAtResponse {
        pub fn builder() -> builder::StateAccountLockersTouchedAtResponse {
            Default::default()
        }
    }
    ///StateAccountLockersTouchedAtResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/AccountLockerAddress"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "last_touched_at_state_version"
    ///      ],
    ///      "properties": {
    ///        "last_touched_at_state_version": {
    ///          "$ref": "#/components/schemas/LastUpdatedAtStateVersion"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateAccountLockersTouchedAtResponseItem {
        pub account_address: Address,
        pub last_touched_at_state_version: LastUpdatedAtStateVersion,
        pub locker_address: Address,
    }
    impl From<&StateAccountLockersTouchedAtResponseItem>
    for StateAccountLockersTouchedAtResponseItem {
        fn from(value: &StateAccountLockersTouchedAtResponseItem) -> Self {
            value.clone()
        }
    }
    impl StateAccountLockersTouchedAtResponseItem {
        pub fn builder() -> builder::StateAccountLockersTouchedAtResponseItem {
            Default::default()
        }
    }
    ///StateAccountResourcePreferencesPageRequest
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "account_address": null
    ///    }
    ///  ],
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/AtLedgerStateMixin"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/CursorLimitMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "account_address"
    ///      ],
    ///      "properties": {
    ///        "account_address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateAccountResourcePreferencesPageRequest {
        pub account_address: Address,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub at_ledger_state: Option<LedgerStateSelector>,
        ///This cursor allows forward pagination, by providing the cursor from the previous request.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub cursor: Option<String>,
        ///The page size requested.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub limit_per_page: Option<i64>,
    }
    impl From<&StateAccountResourcePreferencesPageRequest>
    for StateAccountResourcePreferencesPageRequest {
        fn from(value: &StateAccountResourcePreferencesPageRequest) -> Self {
            value.clone()
        }
    }
    impl StateAccountResourcePreferencesPageRequest {
        pub fn builder() -> builder::StateAccountResourcePreferencesPageRequest {
            Default::default()
        }
    }
    ///StateAccountResourcePreferencesPageResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/LedgerStateMixin"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/AccountResourcePreferencesCollection"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "account_address"
    ///      ],
    ///      "properties": {
    ///        "account_address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateAccountResourcePreferencesPageResponse {
        pub account_address: Address,
        pub items: Vec<AccountResourcePreferencesResponseItem>,
        pub ledger_state: LedgerState,
        ///If specified, contains a cursor to query next page of the `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_cursor: Option<String>,
        ///Total number of items in underlying collection, fragment of which is available in `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_count: Option<i64>,
    }
    impl From<&StateAccountResourcePreferencesPageResponse>
    for StateAccountResourcePreferencesPageResponse {
        fn from(value: &StateAccountResourcePreferencesPageResponse) -> Self {
            value.clone()
        }
    }
    impl StateAccountResourcePreferencesPageResponse {
        pub fn builder() -> builder::StateAccountResourcePreferencesPageResponse {
            Default::default()
        }
    }
    ///Check detailed [OptIns](#section/Using-endpoints-with-opt-in-features) documentation for more details
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Check detailed [OptIns](#section/Using-endpoints-with-opt-in-features) documentation for more details",
    ///  "type": "object",
    ///  "properties": {
    ///    "ancestor_identities": {
    ///      "description": "if set to `true`, ancestor addresses - `parent_address`, `owner_address` and `global_address` for entities are returned.",
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "component_royalty_config": {
    ///      "description": "if set to `true`, `royalty_config` for component entities is returned.",
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "component_royalty_vault_balance": {
    ///      "description": "if set to `true`, `royalty_vault_balance` for component entities is returned.",
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "dapp_two_way_links": {
    ///      "description": "if set to `true`, on-ledger dApp two-way links (resolved & verified) are returned. See https://docs.radixdlt.com/docs/metadata-for-verification for more details.",
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "explicit_metadata": {
    ///      "description": "allows specifying explicitly metadata properties which should be returned in response.",
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      }
    ///    },
    ///    "native_resource_details": {
    ///      "description": "if set to `true`, additional details for the Network native resources are returned.",
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "non_fungible_include_nfids": {
    ///      "description": "if set to `true`, first page of non fungible ids are returned for each non fungible resource, with `next_cursor` which can be later used at `/state/entity/page/non-fungible-vault/ids` endpoint.",
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "package_royalty_vault_balance": {
    ///      "description": "if set to `true`, `royalty_vault_balance` for package entities is returned.",
    ///      "default": false,
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateEntityDetailsOptIns {
        ///if set to `true`, ancestor addresses - `parent_address`, `owner_address` and `global_address` for entities are returned.
        #[serde(default)]
        pub ancestor_identities: bool,
        ///if set to `true`, `royalty_config` for component entities is returned.
        #[serde(default)]
        pub component_royalty_config: bool,
        ///if set to `true`, `royalty_vault_balance` for component entities is returned.
        #[serde(default)]
        pub component_royalty_vault_balance: bool,
        ///if set to `true`, on-ledger dApp two-way links (resolved & verified) are returned. See https://docs.radixdlt.com/docs/metadata-for-verification for more details.
        #[serde(default)]
        pub dapp_two_way_links: bool,
        ///allows specifying explicitly metadata properties which should be returned in response.
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub explicit_metadata: Vec<String>,
        ///if set to `true`, additional details for the Network native resources are returned.
        #[serde(default)]
        pub native_resource_details: bool,
        ///if set to `true`, first page of non fungible ids are returned for each non fungible resource, with `next_cursor` which can be later used at `/state/entity/page/non-fungible-vault/ids` endpoint.
        #[serde(default)]
        pub non_fungible_include_nfids: bool,
        ///if set to `true`, `royalty_vault_balance` for package entities is returned.
        #[serde(default)]
        pub package_royalty_vault_balance: bool,
    }
    impl From<&StateEntityDetailsOptIns> for StateEntityDetailsOptIns {
        fn from(value: &StateEntityDetailsOptIns) -> Self {
            value.clone()
        }
    }
    impl StateEntityDetailsOptIns {
        pub fn builder() -> builder::StateEntityDetailsOptIns {
            Default::default()
        }
    }
    ///StateEntityDetailsRequest
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "addresses": [
    ///        "<entity-address>"
    ///      ],
    ///      "aggregation_level": "Vault",
    ///      "opt_ins": {
    ///        "ancestor_identities": true,
    ///        "component_royalty_config": true,
    ///        "component_royalty_vault_balance": true,
    ///        "dapp_two_way_links": true,
    ///        "explicit_metadata": [
    ///          "name",
    ///          "description"
    ///        ],
    ///        "native_resource_details": true,
    ///        "non_fungible_include_nfids": true,
    ///        "package_royalty_vault_balance": true
    ///      }
    ///    }
    ///  ],
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/AtLedgerStateMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "addresses"
    ///      ],
    ///      "properties": {
    ///        "addresses": {
    ///          "description": "limited to max 20 items.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/Address"
    ///          }
    ///        },
    ///        "aggregation_level": {
    ///          "$ref": "#/components/schemas/ResourceAggregationLevel"
    ///        },
    ///        "opt_ins": {
    ///          "$ref": "#/components/schemas/StateEntityDetailsOptIns"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateEntityDetailsRequest {
        ///limited to max 20 items.
        pub addresses: Vec<Address>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub aggregation_level: Option<ResourceAggregationLevel>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub at_ledger_state: Option<LedgerStateSelector>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub opt_ins: Option<StateEntityDetailsOptIns>,
    }
    impl From<&StateEntityDetailsRequest> for StateEntityDetailsRequest {
        fn from(value: &StateEntityDetailsRequest) -> Self {
            value.clone()
        }
    }
    impl StateEntityDetailsRequest {
        pub fn builder() -> builder::StateEntityDetailsRequest {
            Default::default()
        }
    }
    ///StateEntityDetailsResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/LedgerStateMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "items"
    ///      ],
    ///      "properties": {
    ///        "items": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/StateEntityDetailsResponseItem"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateEntityDetailsResponse {
        pub items: Vec<StateEntityDetailsResponseItem>,
        pub ledger_state: LedgerState,
    }
    impl From<&StateEntityDetailsResponse> for StateEntityDetailsResponse {
        fn from(value: &StateEntityDetailsResponse) -> Self {
            value.clone()
        }
    }
    impl StateEntityDetailsResponse {
        pub fn builder() -> builder::StateEntityDetailsResponse {
            Default::default()
        }
    }
    ///StateEntityDetailsResponseComponentDetails
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/StateEntityDetailsResponseItemDetailsBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "blueprint_name",
    ///        "blueprint_version"
    ///      ],
    ///      "properties": {
    ///        "blueprint_name": {
    ///          "type": "string"
    ///        },
    ///        "blueprint_version": {
    ///          "type": "string"
    ///        },
    ///        "native_resource_details": {
    ///          "$ref": "#/components/schemas/NativeResourceDetails"
    ///        },
    ///        "package_address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "role_assignments": {
    ///          "$ref": "#/components/schemas/ComponentEntityRoleAssignments"
    ///        },
    ///        "royalty_config": {
    ///          "$ref": "#/components/schemas/ComponentRoyaltyConfig"
    ///        },
    ///        "royalty_vault_balance": {
    ///          "$ref": "#/components/schemas/BigDecimal"
    ///        },
    ///        "state": {
    ///          "description": "A representation of a component's inner state. If this entity is a `GenericComponent`, this field will be in a programmatic JSON\nstructure (you can deserialize it as a `ProgrammaticScryptoSborValue`). Otherwise, for \"native\" components such as `Account`,\n`Validator`, `AccessController`, `OneResourcePool`, `TwoResourcePool`, and `MultiResourcePool`, this field will be a\ncustom JSON model defined in the Core API schema.\n",
    ///          "type": "object"
    ///        },
    ///        "two_way_linked_dapp_address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "two_way_linked_dapp_details": {
    ///          "$ref": "#/components/schemas/TwoWayLinkedDappOnLedgerDetails"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "Component"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateEntityDetailsResponseComponentDetails {
        pub blueprint_name: String,
        pub blueprint_version: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub native_resource_details: Option<NativeResourceDetails>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub package_address: Option<Address>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub role_assignments: Option<ComponentEntityRoleAssignments>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub royalty_config: Option<ComponentRoyaltyConfig>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub royalty_vault_balance: Option<BigDecimal>,
        /**A representation of a component's inner state. If this entity is a `GenericComponent`, this field will be in a programmatic JSON
structure (you can deserialize it as a `ProgrammaticScryptoSborValue`). Otherwise, for "native" components such as `Account`,
`Validator`, `AccessController`, `OneResourcePool`, `TwoResourcePool`, and `MultiResourcePool`, this field will be a
custom JSON model defined in the Core API schema.
*/
        #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
        pub state: ::serde_json::Map<String, ::serde_json::Value>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub two_way_linked_dapp_address: Option<Address>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub two_way_linked_dapp_details: Option<TwoWayLinkedDappOnLedgerDetails>,
        #[serde(rename = "type")]
        pub type_: StateEntityDetailsResponseComponentDetailsType,
    }
    impl From<&StateEntityDetailsResponseComponentDetails>
    for StateEntityDetailsResponseComponentDetails {
        fn from(value: &StateEntityDetailsResponseComponentDetails) -> Self {
            value.clone()
        }
    }
    impl StateEntityDetailsResponseComponentDetails {
        pub fn builder() -> builder::StateEntityDetailsResponseComponentDetails {
            Default::default()
        }
    }
    ///StateEntityDetailsResponseComponentDetailsType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "Component"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum StateEntityDetailsResponseComponentDetailsType {
        Component,
    }
    impl From<&StateEntityDetailsResponseComponentDetailsType>
    for StateEntityDetailsResponseComponentDetailsType {
        fn from(value: &StateEntityDetailsResponseComponentDetailsType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for StateEntityDetailsResponseComponentDetailsType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Component => write!(f, "Component"),
            }
        }
    }
    impl std::str::FromStr for StateEntityDetailsResponseComponentDetailsType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "Component" => Ok(Self::Component),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for StateEntityDetailsResponseComponentDetailsType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String>
    for StateEntityDetailsResponseComponentDetailsType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String>
    for StateEntityDetailsResponseComponentDetailsType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///StateEntityDetailsResponseFungibleResourceDetails
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/StateEntityDetailsResponseItemDetailsBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "divisibility",
    ///        "role_assignments",
    ///        "total_burned",
    ///        "total_minted",
    ///        "total_supply"
    ///      ],
    ///      "properties": {
    ///        "divisibility": {
    ///          "type": "integer",
    ///          "minimum": 0.0
    ///        },
    ///        "native_resource_details": {
    ///          "$ref": "#/components/schemas/NativeResourceDetails"
    ///        },
    ///        "role_assignments": {
    ///          "$ref": "#/components/schemas/ComponentEntityRoleAssignments"
    ///        },
    ///        "total_burned": {
    ///          "$ref": "#/components/schemas/BigDecimal"
    ///        },
    ///        "total_minted": {
    ///          "$ref": "#/components/schemas/BigDecimal"
    ///        },
    ///        "total_supply": {
    ///          "$ref": "#/components/schemas/BigDecimal"
    ///        },
    ///        "two_way_linked_dapps": {
    ///          "$ref": "#/components/schemas/TwoWayLinkedDappsCollection"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "FungibleResource"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateEntityDetailsResponseFungibleResourceDetails {
        pub divisibility: u64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub native_resource_details: Option<NativeResourceDetails>,
        pub role_assignments: ComponentEntityRoleAssignments,
        pub total_burned: BigDecimal,
        pub total_minted: BigDecimal,
        pub total_supply: BigDecimal,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub two_way_linked_dapps: Option<TwoWayLinkedDappsCollection>,
        #[serde(rename = "type")]
        pub type_: StateEntityDetailsResponseFungibleResourceDetailsType,
    }
    impl From<&StateEntityDetailsResponseFungibleResourceDetails>
    for StateEntityDetailsResponseFungibleResourceDetails {
        fn from(value: &StateEntityDetailsResponseFungibleResourceDetails) -> Self {
            value.clone()
        }
    }
    impl StateEntityDetailsResponseFungibleResourceDetails {
        pub fn builder() -> builder::StateEntityDetailsResponseFungibleResourceDetails {
            Default::default()
        }
    }
    ///StateEntityDetailsResponseFungibleResourceDetailsType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "FungibleResource"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum StateEntityDetailsResponseFungibleResourceDetailsType {
        FungibleResource,
    }
    impl From<&StateEntityDetailsResponseFungibleResourceDetailsType>
    for StateEntityDetailsResponseFungibleResourceDetailsType {
        fn from(value: &StateEntityDetailsResponseFungibleResourceDetailsType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for StateEntityDetailsResponseFungibleResourceDetailsType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::FungibleResource => write!(f, "FungibleResource"),
            }
        }
    }
    impl std::str::FromStr for StateEntityDetailsResponseFungibleResourceDetailsType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "FungibleResource" => Ok(Self::FungibleResource),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str>
    for StateEntityDetailsResponseFungibleResourceDetailsType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String>
    for StateEntityDetailsResponseFungibleResourceDetailsType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String>
    for StateEntityDetailsResponseFungibleResourceDetailsType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///StateEntityDetailsResponseFungibleVaultDetails
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/StateEntityDetailsResponseItemDetailsBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "balance",
    ///        "resource_address"
    ///      ],
    ///      "properties": {
    ///        "balance": {
    ///          "$ref": "#/components/schemas/FungibleResourcesCollectionItemVaultAggregatedVaultItem"
    ///        },
    ///        "resource_address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "FungibleVault"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateEntityDetailsResponseFungibleVaultDetails {
        pub balance: FungibleResourcesCollectionItemVaultAggregatedVaultItem,
        pub resource_address: Address,
        #[serde(rename = "type")]
        pub type_: StateEntityDetailsResponseFungibleVaultDetailsType,
    }
    impl From<&StateEntityDetailsResponseFungibleVaultDetails>
    for StateEntityDetailsResponseFungibleVaultDetails {
        fn from(value: &StateEntityDetailsResponseFungibleVaultDetails) -> Self {
            value.clone()
        }
    }
    impl StateEntityDetailsResponseFungibleVaultDetails {
        pub fn builder() -> builder::StateEntityDetailsResponseFungibleVaultDetails {
            Default::default()
        }
    }
    ///StateEntityDetailsResponseFungibleVaultDetailsType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "FungibleVault"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum StateEntityDetailsResponseFungibleVaultDetailsType {
        FungibleVault,
    }
    impl From<&StateEntityDetailsResponseFungibleVaultDetailsType>
    for StateEntityDetailsResponseFungibleVaultDetailsType {
        fn from(value: &StateEntityDetailsResponseFungibleVaultDetailsType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for StateEntityDetailsResponseFungibleVaultDetailsType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::FungibleVault => write!(f, "FungibleVault"),
            }
        }
    }
    impl std::str::FromStr for StateEntityDetailsResponseFungibleVaultDetailsType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "FungibleVault" => Ok(Self::FungibleVault),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str>
    for StateEntityDetailsResponseFungibleVaultDetailsType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String>
    for StateEntityDetailsResponseFungibleVaultDetailsType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String>
    for StateEntityDetailsResponseFungibleVaultDetailsType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///StateEntityDetailsResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "address",
    ///    "metadata"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "ancestor_identities": {
    ///      "$ref": "#/components/schemas/StateEntityDetailsResponseItemAncestorIdentities"
    ///    },
    ///    "details": {
    ///      "$ref": "#/components/schemas/StateEntityDetailsResponseItemDetails"
    ///    },
    ///    "explicit_metadata": {
    ///      "$ref": "#/components/schemas/EntityMetadataCollection"
    ///    },
    ///    "fungible_resources": {
    ///      "$ref": "#/components/schemas/FungibleResourcesCollection"
    ///    },
    ///    "metadata": {
    ///      "$ref": "#/components/schemas/EntityMetadataCollection"
    ///    },
    ///    "non_fungible_resources": {
    ///      "$ref": "#/components/schemas/NonFungibleResourcesCollection"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateEntityDetailsResponseItem {
        pub address: Address,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ancestor_identities: Option<
            StateEntityDetailsResponseItemAncestorIdentities,
        >,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub details: Option<StateEntityDetailsResponseItemDetails>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub explicit_metadata: Option<EntityMetadataCollection>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fungible_resources: Option<FungibleResourcesCollection>,
        pub metadata: EntityMetadataCollection,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub non_fungible_resources: Option<NonFungibleResourcesCollection>,
    }
    impl From<&StateEntityDetailsResponseItem> for StateEntityDetailsResponseItem {
        fn from(value: &StateEntityDetailsResponseItem) -> Self {
            value.clone()
        }
    }
    impl StateEntityDetailsResponseItem {
        pub fn builder() -> builder::StateEntityDetailsResponseItem {
            Default::default()
        }
    }
    ///StateEntityDetailsResponseItemAncestorIdentities
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "global_address": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "owner_address": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "parent_address": {
    ///      "$ref": "#/components/schemas/Address"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateEntityDetailsResponseItemAncestorIdentities {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub global_address: Option<Address>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub owner_address: Option<Address>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub parent_address: Option<Address>,
    }
    impl From<&StateEntityDetailsResponseItemAncestorIdentities>
    for StateEntityDetailsResponseItemAncestorIdentities {
        fn from(value: &StateEntityDetailsResponseItemAncestorIdentities) -> Self {
            value.clone()
        }
    }
    impl StateEntityDetailsResponseItemAncestorIdentities {
        pub fn builder() -> builder::StateEntityDetailsResponseItemAncestorIdentities {
            Default::default()
        }
    }
    ///StateEntityDetailsResponseItemDetails
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/StateEntityDetailsResponseFungibleResourceDetails"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/StateEntityDetailsResponseNonFungibleResourceDetails"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/StateEntityDetailsResponseFungibleVaultDetails"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/StateEntityDetailsResponseNonFungibleVaultDetails"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/StateEntityDetailsResponsePackageDetails"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/StateEntityDetailsResponseComponentDetails"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum StateEntityDetailsResponseItemDetails {
        FungibleResourceDetails(StateEntityDetailsResponseFungibleResourceDetails),
        NonFungibleResourceDetails(StateEntityDetailsResponseNonFungibleResourceDetails),
        FungibleVaultDetails(StateEntityDetailsResponseFungibleVaultDetails),
        NonFungibleVaultDetails(StateEntityDetailsResponseNonFungibleVaultDetails),
        PackageDetails(StateEntityDetailsResponsePackageDetails),
        ComponentDetails(StateEntityDetailsResponseComponentDetails),
    }
    impl From<&StateEntityDetailsResponseItemDetails>
    for StateEntityDetailsResponseItemDetails {
        fn from(value: &StateEntityDetailsResponseItemDetails) -> Self {
            value.clone()
        }
    }
    impl From<StateEntityDetailsResponseFungibleResourceDetails>
    for StateEntityDetailsResponseItemDetails {
        fn from(value: StateEntityDetailsResponseFungibleResourceDetails) -> Self {
            Self::FungibleResourceDetails(value)
        }
    }
    impl From<StateEntityDetailsResponseNonFungibleResourceDetails>
    for StateEntityDetailsResponseItemDetails {
        fn from(value: StateEntityDetailsResponseNonFungibleResourceDetails) -> Self {
            Self::NonFungibleResourceDetails(value)
        }
    }
    impl From<StateEntityDetailsResponseFungibleVaultDetails>
    for StateEntityDetailsResponseItemDetails {
        fn from(value: StateEntityDetailsResponseFungibleVaultDetails) -> Self {
            Self::FungibleVaultDetails(value)
        }
    }
    impl From<StateEntityDetailsResponseNonFungibleVaultDetails>
    for StateEntityDetailsResponseItemDetails {
        fn from(value: StateEntityDetailsResponseNonFungibleVaultDetails) -> Self {
            Self::NonFungibleVaultDetails(value)
        }
    }
    impl From<StateEntityDetailsResponsePackageDetails>
    for StateEntityDetailsResponseItemDetails {
        fn from(value: StateEntityDetailsResponsePackageDetails) -> Self {
            Self::PackageDetails(value)
        }
    }
    impl From<StateEntityDetailsResponseComponentDetails>
    for StateEntityDetailsResponseItemDetails {
        fn from(value: StateEntityDetailsResponseComponentDetails) -> Self {
            Self::ComponentDetails(value)
        }
    }
    ///StateEntityDetailsResponseItemDetailsBase
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "type": {
    ///      "$ref": "#/components/schemas/StateEntityDetailsResponseItemDetailsType"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateEntityDetailsResponseItemDetailsBase {
        #[serde(rename = "type")]
        pub type_: StateEntityDetailsResponseItemDetailsType,
    }
    impl From<&StateEntityDetailsResponseItemDetailsBase>
    for StateEntityDetailsResponseItemDetailsBase {
        fn from(value: &StateEntityDetailsResponseItemDetailsBase) -> Self {
            value.clone()
        }
    }
    impl StateEntityDetailsResponseItemDetailsBase {
        pub fn builder() -> builder::StateEntityDetailsResponseItemDetailsBase {
            Default::default()
        }
    }
    ///StateEntityDetailsResponseItemDetailsType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "FungibleResource",
    ///    "NonFungibleResource",
    ///    "FungibleVault",
    ///    "NonFungibleVault",
    ///    "Package",
    ///    "Component"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum StateEntityDetailsResponseItemDetailsType {
        FungibleResource,
        NonFungibleResource,
        FungibleVault,
        NonFungibleVault,
        Package,
        Component,
    }
    impl From<&StateEntityDetailsResponseItemDetailsType>
    for StateEntityDetailsResponseItemDetailsType {
        fn from(value: &StateEntityDetailsResponseItemDetailsType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for StateEntityDetailsResponseItemDetailsType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::FungibleResource => write!(f, "FungibleResource"),
                Self::NonFungibleResource => write!(f, "NonFungibleResource"),
                Self::FungibleVault => write!(f, "FungibleVault"),
                Self::NonFungibleVault => write!(f, "NonFungibleVault"),
                Self::Package => write!(f, "Package"),
                Self::Component => write!(f, "Component"),
            }
        }
    }
    impl std::str::FromStr for StateEntityDetailsResponseItemDetailsType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "FungibleResource" => Ok(Self::FungibleResource),
                "NonFungibleResource" => Ok(Self::NonFungibleResource),
                "FungibleVault" => Ok(Self::FungibleVault),
                "NonFungibleVault" => Ok(Self::NonFungibleVault),
                "Package" => Ok(Self::Package),
                "Component" => Ok(Self::Component),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for StateEntityDetailsResponseItemDetailsType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for StateEntityDetailsResponseItemDetailsType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for StateEntityDetailsResponseItemDetailsType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///StateEntityDetailsResponseNonFungibleResourceDetails
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/StateEntityDetailsResponseItemDetailsBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "non_fungible_data_mutable_fields",
    ///        "non_fungible_id_type",
    ///        "role_assignments",
    ///        "total_burned",
    ///        "total_minted",
    ///        "total_supply"
    ///      ],
    ///      "properties": {
    ///        "native_resource_details": {
    ///          "$ref": "#/components/schemas/NativeResourceDetails"
    ///        },
    ///        "non_fungible_data_mutable_fields": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": "string"
    ///          }
    ///        },
    ///        "non_fungible_id_type": {
    ///          "$ref": "#/components/schemas/NonFungibleIdType"
    ///        },
    ///        "role_assignments": {
    ///          "$ref": "#/components/schemas/ComponentEntityRoleAssignments"
    ///        },
    ///        "total_burned": {
    ///          "$ref": "#/components/schemas/BigDecimal"
    ///        },
    ///        "total_minted": {
    ///          "$ref": "#/components/schemas/BigDecimal"
    ///        },
    ///        "total_supply": {
    ///          "$ref": "#/components/schemas/BigDecimal"
    ///        },
    ///        "two_way_linked_dapps": {
    ///          "$ref": "#/components/schemas/TwoWayLinkedDappsCollection"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "NonFungibleResource"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateEntityDetailsResponseNonFungibleResourceDetails {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub native_resource_details: Option<NativeResourceDetails>,
        pub non_fungible_data_mutable_fields: Vec<String>,
        pub non_fungible_id_type: NonFungibleIdType,
        pub role_assignments: ComponentEntityRoleAssignments,
        pub total_burned: BigDecimal,
        pub total_minted: BigDecimal,
        pub total_supply: BigDecimal,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub two_way_linked_dapps: Option<TwoWayLinkedDappsCollection>,
        #[serde(rename = "type")]
        pub type_: StateEntityDetailsResponseNonFungibleResourceDetailsType,
    }
    impl From<&StateEntityDetailsResponseNonFungibleResourceDetails>
    for StateEntityDetailsResponseNonFungibleResourceDetails {
        fn from(value: &StateEntityDetailsResponseNonFungibleResourceDetails) -> Self {
            value.clone()
        }
    }
    impl StateEntityDetailsResponseNonFungibleResourceDetails {
        pub fn builder() -> builder::StateEntityDetailsResponseNonFungibleResourceDetails {
            Default::default()
        }
    }
    ///StateEntityDetailsResponseNonFungibleResourceDetailsType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "NonFungibleResource"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum StateEntityDetailsResponseNonFungibleResourceDetailsType {
        NonFungibleResource,
    }
    impl From<&StateEntityDetailsResponseNonFungibleResourceDetailsType>
    for StateEntityDetailsResponseNonFungibleResourceDetailsType {
        fn from(
            value: &StateEntityDetailsResponseNonFungibleResourceDetailsType,
        ) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display
    for StateEntityDetailsResponseNonFungibleResourceDetailsType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::NonFungibleResource => write!(f, "NonFungibleResource"),
            }
        }
    }
    impl std::str::FromStr for StateEntityDetailsResponseNonFungibleResourceDetailsType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "NonFungibleResource" => Ok(Self::NonFungibleResource),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str>
    for StateEntityDetailsResponseNonFungibleResourceDetailsType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String>
    for StateEntityDetailsResponseNonFungibleResourceDetailsType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String>
    for StateEntityDetailsResponseNonFungibleResourceDetailsType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///StateEntityDetailsResponseNonFungibleVaultDetails
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/StateEntityDetailsResponseItemDetailsBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "balance",
    ///        "resource_address"
    ///      ],
    ///      "properties": {
    ///        "balance": {
    ///          "$ref": "#/components/schemas/NonFungibleResourcesCollectionItemVaultAggregatedVaultItem"
    ///        },
    ///        "resource_address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "NonFungibleVault"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateEntityDetailsResponseNonFungibleVaultDetails {
        pub balance: NonFungibleResourcesCollectionItemVaultAggregatedVaultItem,
        pub resource_address: Address,
        #[serde(rename = "type")]
        pub type_: StateEntityDetailsResponseNonFungibleVaultDetailsType,
    }
    impl From<&StateEntityDetailsResponseNonFungibleVaultDetails>
    for StateEntityDetailsResponseNonFungibleVaultDetails {
        fn from(value: &StateEntityDetailsResponseNonFungibleVaultDetails) -> Self {
            value.clone()
        }
    }
    impl StateEntityDetailsResponseNonFungibleVaultDetails {
        pub fn builder() -> builder::StateEntityDetailsResponseNonFungibleVaultDetails {
            Default::default()
        }
    }
    ///StateEntityDetailsResponseNonFungibleVaultDetailsType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "NonFungibleVault"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum StateEntityDetailsResponseNonFungibleVaultDetailsType {
        NonFungibleVault,
    }
    impl From<&StateEntityDetailsResponseNonFungibleVaultDetailsType>
    for StateEntityDetailsResponseNonFungibleVaultDetailsType {
        fn from(value: &StateEntityDetailsResponseNonFungibleVaultDetailsType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for StateEntityDetailsResponseNonFungibleVaultDetailsType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::NonFungibleVault => write!(f, "NonFungibleVault"),
            }
        }
    }
    impl std::str::FromStr for StateEntityDetailsResponseNonFungibleVaultDetailsType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "NonFungibleVault" => Ok(Self::NonFungibleVault),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str>
    for StateEntityDetailsResponseNonFungibleVaultDetailsType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String>
    for StateEntityDetailsResponseNonFungibleVaultDetailsType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String>
    for StateEntityDetailsResponseNonFungibleVaultDetailsType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///vm_type, code_hash_hex and code_hex are always going to be empty, use `codes` property which will return collection (it's possible after protocol update that package might have multiple codes)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "vm_type, code_hash_hex and code_hex are always going to be empty, use `codes` property which will return collection (it's possible after protocol update that package might have multiple codes)",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/StateEntityDetailsResponseItemDetailsBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "code_hash_hex",
    ///        "code_hex",
    ///        "codes",
    ///        "vm_type"
    ///      ],
    ///      "properties": {
    ///        "blueprints": {
    ///          "$ref": "#/components/schemas/PackageBlueprintCollection"
    ///        },
    ///        "code_hash_hex": {
    ///          "$ref": "#/components/schemas/HexString"
    ///        },
    ///        "code_hex": {
    ///          "$ref": "#/components/schemas/HexString"
    ///        },
    ///        "codes": {
    ///          "$ref": "#/components/schemas/PackageCodeCollection"
    ///        },
    ///        "role_assignments": {
    ///          "$ref": "#/components/schemas/ComponentEntityRoleAssignments"
    ///        },
    ///        "royalty_vault_balance": {
    ///          "$ref": "#/components/schemas/BigDecimal"
    ///        },
    ///        "schemas": {
    ///          "$ref": "#/components/schemas/EntitySchemaCollection"
    ///        },
    ///        "two_way_linked_dapp_address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "Package"
    ///          ]
    ///        },
    ///        "vm_type": {
    ///          "$ref": "#/components/schemas/PackageVmType"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateEntityDetailsResponsePackageDetails {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub blueprints: Option<PackageBlueprintCollection>,
        pub code_hash_hex: HexString,
        pub code_hex: HexString,
        pub codes: PackageCodeCollection,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub role_assignments: Option<ComponentEntityRoleAssignments>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub royalty_vault_balance: Option<BigDecimal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub schemas: Option<EntitySchemaCollection>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub two_way_linked_dapp_address: Option<Address>,
        #[serde(rename = "type")]
        pub type_: StateEntityDetailsResponsePackageDetailsType,
        pub vm_type: PackageVmType,
    }
    impl From<&StateEntityDetailsResponsePackageDetails>
    for StateEntityDetailsResponsePackageDetails {
        fn from(value: &StateEntityDetailsResponsePackageDetails) -> Self {
            value.clone()
        }
    }
    impl StateEntityDetailsResponsePackageDetails {
        pub fn builder() -> builder::StateEntityDetailsResponsePackageDetails {
            Default::default()
        }
    }
    ///StateEntityDetailsResponsePackageDetailsType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "Package"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum StateEntityDetailsResponsePackageDetailsType {
        Package,
    }
    impl From<&StateEntityDetailsResponsePackageDetailsType>
    for StateEntityDetailsResponsePackageDetailsType {
        fn from(value: &StateEntityDetailsResponsePackageDetailsType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for StateEntityDetailsResponsePackageDetailsType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Package => write!(f, "Package"),
            }
        }
    }
    impl std::str::FromStr for StateEntityDetailsResponsePackageDetailsType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "Package" => Ok(Self::Package),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for StateEntityDetailsResponsePackageDetailsType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String>
    for StateEntityDetailsResponsePackageDetailsType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for StateEntityDetailsResponsePackageDetailsType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///StateEntityFungibleResourceVaultsPageRequest
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "address": "<component-entity-address>",
    ///      "resource_address": "<resource-address>"
    ///    }
    ///  ],
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/AtLedgerStateMixin"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/CursorLimitMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "address",
    ///        "resource_address"
    ///      ],
    ///      "properties": {
    ///        "address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "resource_address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateEntityFungibleResourceVaultsPageRequest {
        pub address: Address,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub at_ledger_state: Option<LedgerStateSelector>,
        ///This cursor allows forward pagination, by providing the cursor from the previous request.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub cursor: Option<String>,
        ///The page size requested.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub limit_per_page: Option<i64>,
        pub resource_address: Address,
    }
    impl From<&StateEntityFungibleResourceVaultsPageRequest>
    for StateEntityFungibleResourceVaultsPageRequest {
        fn from(value: &StateEntityFungibleResourceVaultsPageRequest) -> Self {
            value.clone()
        }
    }
    impl StateEntityFungibleResourceVaultsPageRequest {
        pub fn builder() -> builder::StateEntityFungibleResourceVaultsPageRequest {
            Default::default()
        }
    }
    ///StateEntityFungibleResourceVaultsPageResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/LedgerStateMixin"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/FungibleResourcesCollectionItemVaultAggregatedVault"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "address",
    ///        "resource_address"
    ///      ],
    ///      "properties": {
    ///        "address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "resource_address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateEntityFungibleResourceVaultsPageResponse {
        pub address: Address,
        pub items: Vec<FungibleResourcesCollectionItemVaultAggregatedVaultItem>,
        pub ledger_state: LedgerState,
        ///If specified, contains a cursor to query next page of the `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_cursor: Option<String>,
        pub resource_address: Address,
        ///Total number of items in underlying collection, fragment of which is available in `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_count: Option<i64>,
    }
    impl From<&StateEntityFungibleResourceVaultsPageResponse>
    for StateEntityFungibleResourceVaultsPageResponse {
        fn from(value: &StateEntityFungibleResourceVaultsPageResponse) -> Self {
            value.clone()
        }
    }
    impl StateEntityFungibleResourceVaultsPageResponse {
        pub fn builder() -> builder::StateEntityFungibleResourceVaultsPageResponse {
            Default::default()
        }
    }
    ///StateEntityFungiblesPageRequest
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "address": "<component-entity-address>"
    ///    }
    ///  ],
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/AtLedgerStateMixin"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/CursorLimitMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "address"
    ///      ],
    ///      "properties": {
    ///        "address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "aggregation_level": {
    ///          "$ref": "#/components/schemas/ResourceAggregationLevel"
    ///        },
    ///        "opt_ins": {
    ///          "$ref": "#/components/schemas/StateEntityFungiblesPageRequestOptIns"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateEntityFungiblesPageRequest {
        pub address: Address,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub aggregation_level: Option<ResourceAggregationLevel>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub at_ledger_state: Option<LedgerStateSelector>,
        ///This cursor allows forward pagination, by providing the cursor from the previous request.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub cursor: Option<String>,
        ///The page size requested.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub limit_per_page: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub opt_ins: Option<StateEntityFungiblesPageRequestOptIns>,
    }
    impl From<&StateEntityFungiblesPageRequest> for StateEntityFungiblesPageRequest {
        fn from(value: &StateEntityFungiblesPageRequest) -> Self {
            value.clone()
        }
    }
    impl StateEntityFungiblesPageRequest {
        pub fn builder() -> builder::StateEntityFungiblesPageRequest {
            Default::default()
        }
    }
    ///Check detailed [OptIns](#section/Using-endpoints-with-opt-in-features) documentation for more details
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Check detailed [OptIns](#section/Using-endpoints-with-opt-in-features) documentation for more details",
    ///  "type": "object",
    ///  "properties": {
    ///    "explicit_metadata": {
    ///      "description": "allows specifying explicitly metadata properties which should be returned in response, limited to max 20 items.",
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateEntityFungiblesPageRequestOptIns {
        ///allows specifying explicitly metadata properties which should be returned in response, limited to max 20 items.
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub explicit_metadata: Vec<String>,
    }
    impl From<&StateEntityFungiblesPageRequestOptIns>
    for StateEntityFungiblesPageRequestOptIns {
        fn from(value: &StateEntityFungiblesPageRequestOptIns) -> Self {
            value.clone()
        }
    }
    impl StateEntityFungiblesPageRequestOptIns {
        pub fn builder() -> builder::StateEntityFungiblesPageRequestOptIns {
            Default::default()
        }
    }
    ///StateEntityFungiblesPageResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/LedgerStateMixin"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/FungibleResourcesCollection"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "address"
    ///      ],
    ///      "properties": {
    ///        "address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateEntityFungiblesPageResponse {
        pub address: Address,
        pub items: Vec<FungibleResourcesCollectionItem>,
        pub ledger_state: LedgerState,
        ///If specified, contains a cursor to query next page of the `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_cursor: Option<String>,
        ///Total number of items in underlying collection, fragment of which is available in `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_count: Option<i64>,
    }
    impl From<&StateEntityFungiblesPageResponse> for StateEntityFungiblesPageResponse {
        fn from(value: &StateEntityFungiblesPageResponse) -> Self {
            value.clone()
        }
    }
    impl StateEntityFungiblesPageResponse {
        pub fn builder() -> builder::StateEntityFungiblesPageResponse {
            Default::default()
        }
    }
    ///StateEntityMetadataPageRequest
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "address": "<entity-address>"
    ///    }
    ///  ],
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/AtLedgerStateMixin"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/CursorLimitMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "address"
    ///      ],
    ///      "properties": {
    ///        "address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateEntityMetadataPageRequest {
        pub address: Address,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub at_ledger_state: Option<LedgerStateSelector>,
        ///This cursor allows forward pagination, by providing the cursor from the previous request.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub cursor: Option<String>,
        ///The page size requested.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub limit_per_page: Option<i64>,
    }
    impl From<&StateEntityMetadataPageRequest> for StateEntityMetadataPageRequest {
        fn from(value: &StateEntityMetadataPageRequest) -> Self {
            value.clone()
        }
    }
    impl StateEntityMetadataPageRequest {
        pub fn builder() -> builder::StateEntityMetadataPageRequest {
            Default::default()
        }
    }
    ///StateEntityMetadataPageResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/LedgerStateMixin"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/EntityMetadataCollection"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "address"
    ///      ],
    ///      "properties": {
    ///        "address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateEntityMetadataPageResponse {
        pub address: Address,
        pub items: Vec<EntityMetadataItem>,
        pub ledger_state: LedgerState,
        ///If specified, contains a cursor to query next page of the `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_cursor: Option<String>,
        ///Total number of items in underlying collection, fragment of which is available in `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_count: Option<i64>,
    }
    impl From<&StateEntityMetadataPageResponse> for StateEntityMetadataPageResponse {
        fn from(value: &StateEntityMetadataPageResponse) -> Self {
            value.clone()
        }
    }
    impl StateEntityMetadataPageResponse {
        pub fn builder() -> builder::StateEntityMetadataPageResponse {
            Default::default()
        }
    }
    ///StateEntityNonFungibleIdsPageRequest
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "address": "<component-entity-address>",
    ///      "resource_address": null,
    ///      "vault_address": null
    ///    }
    ///  ],
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/AtLedgerStateMixin"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/CursorLimitMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "address",
    ///        "resource_address",
    ///        "vault_address"
    ///      ],
    ///      "properties": {
    ///        "address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "resource_address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "vault_address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateEntityNonFungibleIdsPageRequest {
        pub address: Address,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub at_ledger_state: Option<LedgerStateSelector>,
        ///This cursor allows forward pagination, by providing the cursor from the previous request.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub cursor: Option<String>,
        ///The page size requested.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub limit_per_page: Option<i64>,
        pub resource_address: Address,
        pub vault_address: Address,
    }
    impl From<&StateEntityNonFungibleIdsPageRequest>
    for StateEntityNonFungibleIdsPageRequest {
        fn from(value: &StateEntityNonFungibleIdsPageRequest) -> Self {
            value.clone()
        }
    }
    impl StateEntityNonFungibleIdsPageRequest {
        pub fn builder() -> builder::StateEntityNonFungibleIdsPageRequest {
            Default::default()
        }
    }
    ///StateEntityNonFungibleIdsPageResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/LedgerStateMixin"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/NonFungibleIdsCollection"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "address",
    ///        "resource_address"
    ///      ],
    ///      "properties": {
    ///        "address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "resource_address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateEntityNonFungibleIdsPageResponse {
        pub address: Address,
        pub items: Vec<NonFungibleId>,
        pub ledger_state: LedgerState,
        ///If specified, contains a cursor to query next page of the `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_cursor: Option<String>,
        pub resource_address: Address,
        ///Total number of items in underlying collection, fragment of which is available in `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_count: Option<i64>,
    }
    impl From<&StateEntityNonFungibleIdsPageResponse>
    for StateEntityNonFungibleIdsPageResponse {
        fn from(value: &StateEntityNonFungibleIdsPageResponse) -> Self {
            value.clone()
        }
    }
    impl StateEntityNonFungibleIdsPageResponse {
        pub fn builder() -> builder::StateEntityNonFungibleIdsPageResponse {
            Default::default()
        }
    }
    ///Check detailed [OptIns](#section/Using-endpoints-with-opt-in-features) documentation for more details
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Check detailed [OptIns](#section/Using-endpoints-with-opt-in-features) documentation for more details",
    ///  "type": "object",
    ///  "properties": {
    ///    "non_fungible_include_nfids": {
    ///      "description": "if set to `true`, first page of non fungible ids are returned for each non fungible resource, with cursor which can be later used at `/state/entity/page/non-fungible-vault/ids` endpoint.",
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateEntityNonFungibleResourceVaultsPageOptIns {
        ///if set to `true`, first page of non fungible ids are returned for each non fungible resource, with cursor which can be later used at `/state/entity/page/non-fungible-vault/ids` endpoint.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub non_fungible_include_nfids: Option<bool>,
    }
    impl From<&StateEntityNonFungibleResourceVaultsPageOptIns>
    for StateEntityNonFungibleResourceVaultsPageOptIns {
        fn from(value: &StateEntityNonFungibleResourceVaultsPageOptIns) -> Self {
            value.clone()
        }
    }
    impl StateEntityNonFungibleResourceVaultsPageOptIns {
        pub fn builder() -> builder::StateEntityNonFungibleResourceVaultsPageOptIns {
            Default::default()
        }
    }
    ///StateEntityNonFungibleResourceVaultsPageRequest
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "address": "<component-entity-address>",
    ///      "resource_address": "<resource-address>"
    ///    }
    ///  ],
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/AtLedgerStateMixin"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/CursorLimitMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "address",
    ///        "resource_address"
    ///      ],
    ///      "properties": {
    ///        "address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "opt_ins": {
    ///          "$ref": "#/components/schemas/StateEntityNonFungibleResourceVaultsPageOptIns"
    ///        },
    ///        "resource_address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateEntityNonFungibleResourceVaultsPageRequest {
        pub address: Address,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub at_ledger_state: Option<LedgerStateSelector>,
        ///This cursor allows forward pagination, by providing the cursor from the previous request.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub cursor: Option<String>,
        ///The page size requested.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub limit_per_page: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub opt_ins: Option<StateEntityNonFungibleResourceVaultsPageOptIns>,
        pub resource_address: Address,
    }
    impl From<&StateEntityNonFungibleResourceVaultsPageRequest>
    for StateEntityNonFungibleResourceVaultsPageRequest {
        fn from(value: &StateEntityNonFungibleResourceVaultsPageRequest) -> Self {
            value.clone()
        }
    }
    impl StateEntityNonFungibleResourceVaultsPageRequest {
        pub fn builder() -> builder::StateEntityNonFungibleResourceVaultsPageRequest {
            Default::default()
        }
    }
    ///StateEntityNonFungibleResourceVaultsPageResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/LedgerStateMixin"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/NonFungibleResourcesCollectionItemVaultAggregatedVault"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "address",
    ///        "resource_address"
    ///      ],
    ///      "properties": {
    ///        "address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "resource_address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateEntityNonFungibleResourceVaultsPageResponse {
        pub address: Address,
        pub items: Vec<NonFungibleResourcesCollectionItemVaultAggregatedVaultItem>,
        pub ledger_state: LedgerState,
        ///If specified, contains a cursor to query next page of the `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_cursor: Option<String>,
        pub resource_address: Address,
        ///Total number of items in underlying collection, fragment of which is available in `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_count: Option<i64>,
    }
    impl From<&StateEntityNonFungibleResourceVaultsPageResponse>
    for StateEntityNonFungibleResourceVaultsPageResponse {
        fn from(value: &StateEntityNonFungibleResourceVaultsPageResponse) -> Self {
            value.clone()
        }
    }
    impl StateEntityNonFungibleResourceVaultsPageResponse {
        pub fn builder() -> builder::StateEntityNonFungibleResourceVaultsPageResponse {
            Default::default()
        }
    }
    ///StateEntityNonFungiblesPageRequest
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "address": "<component-entity-address>"
    ///    }
    ///  ],
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/AtLedgerStateMixin"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/CursorLimitMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "address"
    ///      ],
    ///      "properties": {
    ///        "address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "aggregation_level": {
    ///          "$ref": "#/components/schemas/ResourceAggregationLevel"
    ///        },
    ///        "opt_ins": {
    ///          "$ref": "#/components/schemas/StateEntityNonFungiblesPageRequestOptIns"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateEntityNonFungiblesPageRequest {
        pub address: Address,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub aggregation_level: Option<ResourceAggregationLevel>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub at_ledger_state: Option<LedgerStateSelector>,
        ///This cursor allows forward pagination, by providing the cursor from the previous request.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub cursor: Option<String>,
        ///The page size requested.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub limit_per_page: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub opt_ins: Option<StateEntityNonFungiblesPageRequestOptIns>,
    }
    impl From<&StateEntityNonFungiblesPageRequest>
    for StateEntityNonFungiblesPageRequest {
        fn from(value: &StateEntityNonFungiblesPageRequest) -> Self {
            value.clone()
        }
    }
    impl StateEntityNonFungiblesPageRequest {
        pub fn builder() -> builder::StateEntityNonFungiblesPageRequest {
            Default::default()
        }
    }
    ///Check detailed [OptIns](#section/Using-endpoints-with-opt-in-features) documentation for more details
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Check detailed [OptIns](#section/Using-endpoints-with-opt-in-features) documentation for more details",
    ///  "type": "object",
    ///  "properties": {
    ///    "explicit_metadata": {
    ///      "description": "allows specifying explicitly metadata properties which should be returned in response, limited to max 20 items.",
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      }
    ///    },
    ///    "non_fungible_include_nfids": {
    ///      "description": "if set to `true`, first page of non fungible ids are returned for each non fungible resource, with cursor which can be later used at `/state/entity/page/non-fungible-vault/ids` endpoint.",
    ///      "default": false,
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateEntityNonFungiblesPageRequestOptIns {
        ///allows specifying explicitly metadata properties which should be returned in response, limited to max 20 items.
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub explicit_metadata: Vec<String>,
        ///if set to `true`, first page of non fungible ids are returned for each non fungible resource, with cursor which can be later used at `/state/entity/page/non-fungible-vault/ids` endpoint.
        #[serde(default)]
        pub non_fungible_include_nfids: bool,
    }
    impl From<&StateEntityNonFungiblesPageRequestOptIns>
    for StateEntityNonFungiblesPageRequestOptIns {
        fn from(value: &StateEntityNonFungiblesPageRequestOptIns) -> Self {
            value.clone()
        }
    }
    impl StateEntityNonFungiblesPageRequestOptIns {
        pub fn builder() -> builder::StateEntityNonFungiblesPageRequestOptIns {
            Default::default()
        }
    }
    ///StateEntityNonFungiblesPageResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/LedgerStateMixin"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/NonFungibleResourcesCollection"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "address"
    ///      ],
    ///      "properties": {
    ///        "address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateEntityNonFungiblesPageResponse {
        pub address: Address,
        pub items: Vec<NonFungibleResourcesCollectionItem>,
        pub ledger_state: LedgerState,
        ///If specified, contains a cursor to query next page of the `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_cursor: Option<String>,
        ///Total number of items in underlying collection, fragment of which is available in `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_count: Option<i64>,
    }
    impl From<&StateEntityNonFungiblesPageResponse>
    for StateEntityNonFungiblesPageResponse {
        fn from(value: &StateEntityNonFungiblesPageResponse) -> Self {
            value.clone()
        }
    }
    impl StateEntityNonFungiblesPageResponse {
        pub fn builder() -> builder::StateEntityNonFungiblesPageResponse {
            Default::default()
        }
    }
    ///StateEntitySchemaPageRequest
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "address": "<package-address>"
    ///    }
    ///  ],
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/AtLedgerStateMixin"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/CursorLimitMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "address"
    ///      ],
    ///      "properties": {
    ///        "address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateEntitySchemaPageRequest {
        pub address: Address,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub at_ledger_state: Option<LedgerStateSelector>,
        ///This cursor allows forward pagination, by providing the cursor from the previous request.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub cursor: Option<String>,
        ///The page size requested.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub limit_per_page: Option<i64>,
    }
    impl From<&StateEntitySchemaPageRequest> for StateEntitySchemaPageRequest {
        fn from(value: &StateEntitySchemaPageRequest) -> Self {
            value.clone()
        }
    }
    impl StateEntitySchemaPageRequest {
        pub fn builder() -> builder::StateEntitySchemaPageRequest {
            Default::default()
        }
    }
    ///StateEntitySchemaPageResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/LedgerStateMixin"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/EntitySchemaCollection"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "address"
    ///      ],
    ///      "properties": {
    ///        "address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateEntitySchemaPageResponse {
        pub address: Address,
        pub items: Vec<EntitySchemaCollectionItem>,
        pub ledger_state: LedgerState,
        ///If specified, contains a cursor to query next page of the `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_cursor: Option<String>,
        ///Total number of items in underlying collection, fragment of which is available in `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_count: Option<i64>,
    }
    impl From<&StateEntitySchemaPageResponse> for StateEntitySchemaPageResponse {
        fn from(value: &StateEntitySchemaPageResponse) -> Self {
            value.clone()
        }
    }
    impl StateEntitySchemaPageResponse {
        pub fn builder() -> builder::StateEntitySchemaPageResponse {
            Default::default()
        }
    }
    ///StateKeyValueStoreDataRequest
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "key_value_store_address": "<key-value-store-address>",
    ///      "keys": [
    ///        {
    ///          "key_hex": "5C21010901000000"
    ///        },
    ///        {
    ///          "key_json": {
    ///            "fields": [
    ///              {
    ///                "kind": "U32",
    ///                "value": "1"
    ///              }
    ///            ],
    ///            "kind": "Tuple"
    ///          }
    ///        }
    ///      ]
    ///    }
    ///  ],
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/AtLedgerStateMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "key_value_store_address",
    ///        "keys"
    ///      ],
    ///      "properties": {
    ///        "key_value_store_address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        },
    ///        "keys": {
    ///          "description": "limited to max 100 items.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/StateKeyValueStoreDataRequestKeyItem"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateKeyValueStoreDataRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub at_ledger_state: Option<LedgerStateSelector>,
        pub key_value_store_address: Address,
        ///limited to max 100 items.
        pub keys: Vec<StateKeyValueStoreDataRequestKeyItem>,
    }
    impl From<&StateKeyValueStoreDataRequest> for StateKeyValueStoreDataRequest {
        fn from(value: &StateKeyValueStoreDataRequest) -> Self {
            value.clone()
        }
    }
    impl StateKeyValueStoreDataRequest {
        pub fn builder() -> builder::StateKeyValueStoreDataRequest {
            Default::default()
        }
    }
    ///Provide either `key_hex` or `key_json`. If both are provided, `key_hex` is used and `key_json` is ignored.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Provide either `key_hex` or `key_json`. If both are provided, `key_hex` is used and `key_json` is ignored.",
    ///  "type": "object",
    ///  "properties": {
    ///    "key_hex": {
    ///      "$ref": "#/components/schemas/HexString"
    ///    },
    ///    "key_json": {
    ///      "$ref": "#/components/schemas/ProgrammaticScryptoSborValue"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateKeyValueStoreDataRequestKeyItem {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub key_hex: Option<HexString>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub key_json: Option<ProgrammaticScryptoSborValue>,
    }
    impl From<&StateKeyValueStoreDataRequestKeyItem>
    for StateKeyValueStoreDataRequestKeyItem {
        fn from(value: &StateKeyValueStoreDataRequestKeyItem) -> Self {
            value.clone()
        }
    }
    impl StateKeyValueStoreDataRequestKeyItem {
        pub fn builder() -> builder::StateKeyValueStoreDataRequestKeyItem {
            Default::default()
        }
    }
    ///StateKeyValueStoreDataResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/LedgerStateMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "entries",
    ///        "key_value_store_address"
    ///      ],
    ///      "properties": {
    ///        "entries": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/StateKeyValueStoreDataResponseItem"
    ///          }
    ///        },
    ///        "key_value_store_address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateKeyValueStoreDataResponse {
        pub entries: Vec<StateKeyValueStoreDataResponseItem>,
        pub key_value_store_address: Address,
        pub ledger_state: LedgerState,
    }
    impl From<&StateKeyValueStoreDataResponse> for StateKeyValueStoreDataResponse {
        fn from(value: &StateKeyValueStoreDataResponse) -> Self {
            value.clone()
        }
    }
    impl StateKeyValueStoreDataResponse {
        pub fn builder() -> builder::StateKeyValueStoreDataResponse {
            Default::default()
        }
    }
    ///StateKeyValueStoreDataResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "is_locked",
    ///    "key",
    ///    "last_updated_at_state_version",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "is_locked": {
    ///      "type": "boolean"
    ///    },
    ///    "key": {
    ///      "$ref": "#/components/schemas/ScryptoSborValue"
    ///    },
    ///    "last_updated_at_state_version": {
    ///      "$ref": "#/components/schemas/LastUpdatedAtStateVersion"
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/ScryptoSborValue"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateKeyValueStoreDataResponseItem {
        pub is_locked: bool,
        pub key: ScryptoSborValue,
        pub last_updated_at_state_version: LastUpdatedAtStateVersion,
        pub value: ScryptoSborValue,
    }
    impl From<&StateKeyValueStoreDataResponseItem>
    for StateKeyValueStoreDataResponseItem {
        fn from(value: &StateKeyValueStoreDataResponseItem) -> Self {
            value.clone()
        }
    }
    impl StateKeyValueStoreDataResponseItem {
        pub fn builder() -> builder::StateKeyValueStoreDataResponseItem {
            Default::default()
        }
    }
    ///Key value store items collection.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Key value store items collection.",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ResultSetCursorMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "items"
    ///      ],
    ///      "properties": {
    ///        "items": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/StateKeyValueStoreKeysResponseItem"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateKeyValueStoreKeysCollection {
        pub items: Vec<StateKeyValueStoreKeysResponseItem>,
        ///If specified, contains a cursor to query next page of the `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_cursor: Option<String>,
        ///Total number of items in underlying collection, fragment of which is available in `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_count: Option<i64>,
    }
    impl From<&StateKeyValueStoreKeysCollection> for StateKeyValueStoreKeysCollection {
        fn from(value: &StateKeyValueStoreKeysCollection) -> Self {
            value.clone()
        }
    }
    impl StateKeyValueStoreKeysCollection {
        pub fn builder() -> builder::StateKeyValueStoreKeysCollection {
            Default::default()
        }
    }
    ///StateKeyValueStoreKeysRequest
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "key_value_store_address": "<key-value-store-address>"
    ///    }
    ///  ],
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/AtLedgerStateMixin"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/CursorLimitMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "key_value_store_address"
    ///      ],
    ///      "properties": {
    ///        "key_value_store_address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateKeyValueStoreKeysRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub at_ledger_state: Option<LedgerStateSelector>,
        ///This cursor allows forward pagination, by providing the cursor from the previous request.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub cursor: Option<String>,
        pub key_value_store_address: Address,
        ///The page size requested.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub limit_per_page: Option<i64>,
    }
    impl From<&StateKeyValueStoreKeysRequest> for StateKeyValueStoreKeysRequest {
        fn from(value: &StateKeyValueStoreKeysRequest) -> Self {
            value.clone()
        }
    }
    impl StateKeyValueStoreKeysRequest {
        pub fn builder() -> builder::StateKeyValueStoreKeysRequest {
            Default::default()
        }
    }
    ///StateKeyValueStoreKeysResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/LedgerStateMixin"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/StateKeyValueStoreKeysCollection"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "key_value_store_address"
    ///      ],
    ///      "properties": {
    ///        "key_value_store_address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateKeyValueStoreKeysResponse {
        pub items: Vec<StateKeyValueStoreKeysResponseItem>,
        pub key_value_store_address: Address,
        pub ledger_state: LedgerState,
        ///If specified, contains a cursor to query next page of the `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_cursor: Option<String>,
        ///Total number of items in underlying collection, fragment of which is available in `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_count: Option<i64>,
    }
    impl From<&StateKeyValueStoreKeysResponse> for StateKeyValueStoreKeysResponse {
        fn from(value: &StateKeyValueStoreKeysResponse) -> Self {
            value.clone()
        }
    }
    impl StateKeyValueStoreKeysResponse {
        pub fn builder() -> builder::StateKeyValueStoreKeysResponse {
            Default::default()
        }
    }
    ///StateKeyValueStoreKeysResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "key",
    ///    "last_updated_at_state_version"
    ///  ],
    ///  "properties": {
    ///    "key": {
    ///      "$ref": "#/components/schemas/ScryptoSborValue"
    ///    },
    ///    "last_updated_at_state_version": {
    ///      "$ref": "#/components/schemas/LastUpdatedAtStateVersion"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateKeyValueStoreKeysResponseItem {
        pub key: ScryptoSborValue,
        pub last_updated_at_state_version: LastUpdatedAtStateVersion,
    }
    impl From<&StateKeyValueStoreKeysResponseItem>
    for StateKeyValueStoreKeysResponseItem {
        fn from(value: &StateKeyValueStoreKeysResponseItem) -> Self {
            value.clone()
        }
    }
    impl StateKeyValueStoreKeysResponseItem {
        pub fn builder() -> builder::StateKeyValueStoreKeysResponseItem {
            Default::default()
        }
    }
    ///StateNonFungibleDataRequest
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "non_fungible_ids": [
    ///        "#1#"
    ///      ],
    ///      "resource_address": "<non-fungible-entity-address>"
    ///    }
    ///  ],
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/AtLedgerStateMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "non_fungible_ids",
    ///        "resource_address"
    ///      ],
    ///      "properties": {
    ///        "non_fungible_ids": {
    ///          "description": "limited to max 100 items.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/NonFungibleId"
    ///          }
    ///        },
    ///        "resource_address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateNonFungibleDataRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub at_ledger_state: Option<LedgerStateSelector>,
        ///limited to max 100 items.
        pub non_fungible_ids: Vec<NonFungibleId>,
        pub resource_address: Address,
    }
    impl From<&StateNonFungibleDataRequest> for StateNonFungibleDataRequest {
        fn from(value: &StateNonFungibleDataRequest) -> Self {
            value.clone()
        }
    }
    impl StateNonFungibleDataRequest {
        pub fn builder() -> builder::StateNonFungibleDataRequest {
            Default::default()
        }
    }
    ///StateNonFungibleDataResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/LedgerStateMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "non_fungible_id_type",
    ///        "non_fungible_ids",
    ///        "resource_address"
    ///      ],
    ///      "properties": {
    ///        "non_fungible_id_type": {
    ///          "$ref": "#/components/schemas/NonFungibleIdType"
    ///        },
    ///        "non_fungible_ids": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/StateNonFungibleDetailsResponseItem"
    ///          }
    ///        },
    ///        "resource_address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateNonFungibleDataResponse {
        pub ledger_state: LedgerState,
        pub non_fungible_id_type: NonFungibleIdType,
        pub non_fungible_ids: Vec<StateNonFungibleDetailsResponseItem>,
        pub resource_address: Address,
    }
    impl From<&StateNonFungibleDataResponse> for StateNonFungibleDataResponse {
        fn from(value: &StateNonFungibleDataResponse) -> Self {
            value.clone()
        }
    }
    impl StateNonFungibleDataResponse {
        pub fn builder() -> builder::StateNonFungibleDataResponse {
            Default::default()
        }
    }
    ///StateNonFungibleDetailsResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "is_burned",
    ///    "last_updated_at_state_version",
    ///    "non_fungible_id"
    ///  ],
    ///  "properties": {
    ///    "data": {
    ///      "$ref": "#/components/schemas/ScryptoSborValue"
    ///    },
    ///    "is_burned": {
    ///      "type": "boolean"
    ///    },
    ///    "last_updated_at_state_version": {
    ///      "$ref": "#/components/schemas/LastUpdatedAtStateVersion"
    ///    },
    ///    "non_fungible_id": {
    ///      "$ref": "#/components/schemas/NonFungibleId"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateNonFungibleDetailsResponseItem {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub data: Option<ScryptoSborValue>,
        pub is_burned: bool,
        pub last_updated_at_state_version: LastUpdatedAtStateVersion,
        pub non_fungible_id: NonFungibleId,
    }
    impl From<&StateNonFungibleDetailsResponseItem>
    for StateNonFungibleDetailsResponseItem {
        fn from(value: &StateNonFungibleDetailsResponseItem) -> Self {
            value.clone()
        }
    }
    impl StateNonFungibleDetailsResponseItem {
        pub fn builder() -> builder::StateNonFungibleDetailsResponseItem {
            Default::default()
        }
    }
    ///StateNonFungibleIdsRequest
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "resource_address": "<non-fungible-entity-address>"
    ///    }
    ///  ],
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/AtLedgerStateMixin"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/CursorLimitMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "resource_address"
    ///      ],
    ///      "properties": {
    ///        "resource_address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateNonFungibleIdsRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub at_ledger_state: Option<LedgerStateSelector>,
        ///This cursor allows forward pagination, by providing the cursor from the previous request.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub cursor: Option<String>,
        ///The page size requested.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub limit_per_page: Option<i64>,
        pub resource_address: Address,
    }
    impl From<&StateNonFungibleIdsRequest> for StateNonFungibleIdsRequest {
        fn from(value: &StateNonFungibleIdsRequest) -> Self {
            value.clone()
        }
    }
    impl StateNonFungibleIdsRequest {
        pub fn builder() -> builder::StateNonFungibleIdsRequest {
            Default::default()
        }
    }
    ///StateNonFungibleIdsResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/LedgerStateMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "non_fungible_ids",
    ///        "resource_address"
    ///      ],
    ///      "properties": {
    ///        "non_fungible_ids": {
    ///          "$ref": "#/components/schemas/NonFungibleIdsCollection"
    ///        },
    ///        "resource_address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateNonFungibleIdsResponse {
        pub ledger_state: LedgerState,
        pub non_fungible_ids: NonFungibleIdsCollection,
        pub resource_address: Address,
    }
    impl From<&StateNonFungibleIdsResponse> for StateNonFungibleIdsResponse {
        fn from(value: &StateNonFungibleIdsResponse) -> Self {
            value.clone()
        }
    }
    impl StateNonFungibleIdsResponse {
        pub fn builder() -> builder::StateNonFungibleIdsResponse {
            Default::default()
        }
    }
    ///StateNonFungibleLocationRequest
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "non_fungible_ids": [
    ///        "#1#"
    ///      ],
    ///      "resource_address": "<non-fungible-entity-address>"
    ///    }
    ///  ],
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/AtLedgerStateMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "non_fungible_ids",
    ///        "resource_address"
    ///      ],
    ///      "properties": {
    ///        "non_fungible_ids": {
    ///          "description": "limited to max 100 items.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/NonFungibleId"
    ///          }
    ///        },
    ///        "resource_address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateNonFungibleLocationRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub at_ledger_state: Option<LedgerStateSelector>,
        ///limited to max 100 items.
        pub non_fungible_ids: Vec<NonFungibleId>,
        pub resource_address: Address,
    }
    impl From<&StateNonFungibleLocationRequest> for StateNonFungibleLocationRequest {
        fn from(value: &StateNonFungibleLocationRequest) -> Self {
            value.clone()
        }
    }
    impl StateNonFungibleLocationRequest {
        pub fn builder() -> builder::StateNonFungibleLocationRequest {
            Default::default()
        }
    }
    ///StateNonFungibleLocationResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/LedgerStateMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "non_fungible_ids",
    ///        "resource_address"
    ///      ],
    ///      "properties": {
    ///        "non_fungible_ids": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/StateNonFungibleLocationResponseItem"
    ///          }
    ///        },
    ///        "resource_address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateNonFungibleLocationResponse {
        pub ledger_state: LedgerState,
        pub non_fungible_ids: Vec<StateNonFungibleLocationResponseItem>,
        pub resource_address: Address,
    }
    impl From<&StateNonFungibleLocationResponse> for StateNonFungibleLocationResponse {
        fn from(value: &StateNonFungibleLocationResponse) -> Self {
            value.clone()
        }
    }
    impl StateNonFungibleLocationResponse {
        pub fn builder() -> builder::StateNonFungibleLocationResponse {
            Default::default()
        }
    }
    ///StateNonFungibleLocationResponseItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "is_burned",
    ///    "last_updated_at_state_version",
    ///    "non_fungible_id"
    ///  ],
    ///  "properties": {
    ///    "is_burned": {
    ///      "type": "boolean"
    ///    },
    ///    "last_updated_at_state_version": {
    ///      "$ref": "#/components/schemas/LastUpdatedAtStateVersion"
    ///    },
    ///    "non_fungible_id": {
    ///      "$ref": "#/components/schemas/NonFungibleId"
    ///    },
    ///    "owning_vault_address": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "owning_vault_global_ancestor_address": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "owning_vault_parent_ancestor_address": {
    ///      "$ref": "#/components/schemas/Address"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateNonFungibleLocationResponseItem {
        pub is_burned: bool,
        pub last_updated_at_state_version: LastUpdatedAtStateVersion,
        pub non_fungible_id: NonFungibleId,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub owning_vault_address: Option<Address>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub owning_vault_global_ancestor_address: Option<Address>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub owning_vault_parent_ancestor_address: Option<Address>,
    }
    impl From<&StateNonFungibleLocationResponseItem>
    for StateNonFungibleLocationResponseItem {
        fn from(value: &StateNonFungibleLocationResponseItem) -> Self {
            value.clone()
        }
    }
    impl StateNonFungibleLocationResponseItem {
        pub fn builder() -> builder::StateNonFungibleLocationResponseItem {
            Default::default()
        }
    }
    ///StatePackageBlueprintPageRequest
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "package_address": "<package-address>"
    ///    }
    ///  ],
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/AtLedgerStateMixin"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/CursorLimitMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "package_address"
    ///      ],
    ///      "properties": {
    ///        "package_address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StatePackageBlueprintPageRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub at_ledger_state: Option<LedgerStateSelector>,
        ///This cursor allows forward pagination, by providing the cursor from the previous request.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub cursor: Option<String>,
        ///The page size requested.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub limit_per_page: Option<i64>,
        pub package_address: Address,
    }
    impl From<&StatePackageBlueprintPageRequest> for StatePackageBlueprintPageRequest {
        fn from(value: &StatePackageBlueprintPageRequest) -> Self {
            value.clone()
        }
    }
    impl StatePackageBlueprintPageRequest {
        pub fn builder() -> builder::StatePackageBlueprintPageRequest {
            Default::default()
        }
    }
    ///StatePackageBlueprintPageResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/LedgerStateMixin"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/PackageBlueprintCollection"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "package_address"
    ///      ],
    ///      "properties": {
    ///        "package_address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StatePackageBlueprintPageResponse {
        pub items: Vec<PackageBlueprintCollectionItem>,
        pub ledger_state: LedgerState,
        ///If specified, contains a cursor to query next page of the `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_cursor: Option<String>,
        pub package_address: Address,
        ///Total number of items in underlying collection, fragment of which is available in `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_count: Option<i64>,
    }
    impl From<&StatePackageBlueprintPageResponse> for StatePackageBlueprintPageResponse {
        fn from(value: &StatePackageBlueprintPageResponse) -> Self {
            value.clone()
        }
    }
    impl StatePackageBlueprintPageResponse {
        pub fn builder() -> builder::StatePackageBlueprintPageResponse {
            Default::default()
        }
    }
    ///StatePackageCodePageRequest
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "package_address": "<package-address>"
    ///    }
    ///  ],
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/AtLedgerStateMixin"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/CursorLimitMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "package_address"
    ///      ],
    ///      "properties": {
    ///        "package_address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StatePackageCodePageRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub at_ledger_state: Option<LedgerStateSelector>,
        ///This cursor allows forward pagination, by providing the cursor from the previous request.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub cursor: Option<String>,
        ///The page size requested.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub limit_per_page: Option<i64>,
        pub package_address: Address,
    }
    impl From<&StatePackageCodePageRequest> for StatePackageCodePageRequest {
        fn from(value: &StatePackageCodePageRequest) -> Self {
            value.clone()
        }
    }
    impl StatePackageCodePageRequest {
        pub fn builder() -> builder::StatePackageCodePageRequest {
            Default::default()
        }
    }
    ///StatePackageCodePageResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/LedgerStateMixin"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/PackageCodeCollection"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "package_address"
    ///      ],
    ///      "properties": {
    ///        "package_address": {
    ///          "$ref": "#/components/schemas/Address"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StatePackageCodePageResponse {
        pub items: Vec<PackageCodeCollectionItem>,
        pub ledger_state: LedgerState,
        ///If specified, contains a cursor to query next page of the `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_cursor: Option<String>,
        pub package_address: Address,
        ///Total number of items in underlying collection, fragment of which is available in `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_count: Option<i64>,
    }
    impl From<&StatePackageCodePageResponse> for StatePackageCodePageResponse {
        fn from(value: &StatePackageCodePageResponse) -> Self {
            value.clone()
        }
    }
    impl StatePackageCodePageResponse {
        pub fn builder() -> builder::StatePackageCodePageResponse {
            Default::default()
        }
    }
    ///StateValidatorsListRequest
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "at_ledger_state": null
    ///    }
    ///  ],
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/AtLedgerStateMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "properties": {
    ///        "cursor": {
    ///          "description": "This cursor allows forward pagination, by providing the cursor from the previous request.",
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateValidatorsListRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub at_ledger_state: Option<LedgerStateSelector>,
        ///This cursor allows forward pagination, by providing the cursor from the previous request.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub cursor: Option<String>,
    }
    impl From<&StateValidatorsListRequest> for StateValidatorsListRequest {
        fn from(value: &StateValidatorsListRequest) -> Self {
            value.clone()
        }
    }
    impl StateValidatorsListRequest {
        pub fn builder() -> builder::StateValidatorsListRequest {
            Default::default()
        }
    }
    ///StateValidatorsListResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/LedgerStateMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "validators"
    ///      ],
    ///      "properties": {
    ///        "validators": {
    ///          "$ref": "#/components/schemas/ValidatorCollection"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StateValidatorsListResponse {
        pub ledger_state: LedgerState,
        pub validators: ValidatorCollection,
    }
    impl From<&StateValidatorsListResponse> for StateValidatorsListResponse {
        fn from(value: &StateValidatorsListResponse) -> Self {
            value.clone()
        }
    }
    impl StateValidatorsListResponse {
        pub fn builder() -> builder::StateValidatorsListResponse {
            Default::default()
        }
    }
    ///StreamTransactionsRequest
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "limit_per_page": 5
    ///    }
    ///  ],
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/AtLedgerStateMixin"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/FromLedgerStateMixin"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/CursorLimitMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "properties": {
    ///        "accounts_with_manifest_owner_method_calls": {
    ///          "description": "Allows specifying an array of account addresses. If specified, the response will contain only transactions that, for all specified accounts, contain manifest method calls to that account which require the owner role. See the [account docs](https://docs.radixdlt.com/docs/account) for more information.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/Address"
    ///          }
    ///        },
    ///        "accounts_without_manifest_owner_method_calls": {
    ///          "description": "Allows specifying an array of account addresses. If specified, the response will contain only transactions that, for all specified accounts, do NOT contain manifest method calls to that account which require owner role. See the [account docs](https://docs.radixdlt.com/docs/account) for more information.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/Address"
    ///          }
    ///        },
    ///        "affected_global_entities_filter": {
    ///          "description": "Allows specifying an array of global addresses. If specified, the response will contain transactions that affected all of the given global entities. A global entity is marked as \"affected\" by a transaction if any of its state (or its descendents' state) was modified as a result of the transaction. For performance reasons consensus manager and transaction tracker are excluded from that filter.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/Address"
    ///          }
    ///        },
    ///        "event_global_emitters_filter": {
    ///          "description": "Allows specifying an array of global addresses. If specified, the response will contain transactions in which all entities emitted events. If an event was published by an internal entity, it is going to be indexed as it is a global ancestor. For performance reasons events published by consensus manager and native XRD resource are excluded from that filter.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/Address"
    ///          }
    ///        },
    ///        "events_filter": {
    ///          "description": "Filters the transaction stream to transactions which emitted at least one event matching each filter (each filter can be satisfied by a different event). Currently *only* deposit and withdrawal events emitted by an internal vault entity are tracked. For the purpose of filtering, the emitter address is replaced by the global ancestor of the emitter, for example, the top-level account / component which contains the vault which emitted the event.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/StreamTransactionsRequestEventFilterItem"
    ///          }
    ///        },
    ///        "kind_filter": {
    ///          "description": "Limit returned transactions by their kind. Defaults to `user`.",
    ///          "type": "string",
    ///          "enum": [
    ///            "User",
    ///            "EpochChange",
    ///            "All"
    ///          ]
    ///        },
    ///        "manifest_accounts_deposited_into_filter": {
    ///          "description": "Similar to `manifest_accounts_withdrawn_from_filter`, but will return only transactions with a manifest containing deposits to the given accounts.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/Address"
    ///          }
    ///        },
    ///        "manifest_accounts_withdrawn_from_filter": {
    ///          "description": "Allows specifying an array of account addresses. If specified, the response will contain only transactions with a manifest containing withdrawals from the given accounts.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/Address"
    ///          }
    ///        },
    ///        "manifest_badges_presented_filter": {
    ///          "description": "Allows specifying array of badge resource addresses. If specified, the response will contain only transactions where the given badges were presented.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/Address"
    ///          }
    ///        },
    ///        "manifest_class_filter": {
    ///          "description": "Allows filtering to transactions which match the given manifest classification. If specified, the response will contain only transactions which have a class that matches the filter. If `match_only_most_specific` set to true, only transactions where the queried class is most specific will be returned. See the [docs on manifest classification](https://docs.radixdlt.com/docs/conforming-transaction-manifest-types) for more information.",
    ///          "type": "object",
    ///          "required": [
    ///            "class"
    ///          ],
    ///          "properties": {
    ///            "class": {
    ///              "$ref": "#/components/schemas/ManifestClass"
    ///            },
    ///            "match_only_most_specific": {
    ///              "default": false,
    ///              "type": "boolean"
    ///            }
    ///          }
    ///        },
    ///        "manifest_resources_filter": {
    ///          "description": "Allows specifying array of resource addresses. If specified, the response will contain only transactions containing the given resources in the manifest (regardless of their usage).",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/Address"
    ///          }
    ///        },
    ///        "opt_ins": {
    ///          "$ref": "#/components/schemas/TransactionDetailsOptIns"
    ///        },
    ///        "order": {
    ///          "description": "Configures the order of returned result set. Defaults to `desc`.",
    ///          "type": "string",
    ///          "enum": [
    ///            "Asc",
    ///            "Desc"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StreamTransactionsRequest {
        ///Allows specifying an array of account addresses. If specified, the response will contain only transactions that, for all specified accounts, contain manifest method calls to that account which require the owner role. See the [account docs](https://docs.radixdlt.com/docs/account) for more information.
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub accounts_with_manifest_owner_method_calls: Vec<Address>,
        ///Allows specifying an array of account addresses. If specified, the response will contain only transactions that, for all specified accounts, do NOT contain manifest method calls to that account which require owner role. See the [account docs](https://docs.radixdlt.com/docs/account) for more information.
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub accounts_without_manifest_owner_method_calls: Vec<Address>,
        ///Allows specifying an array of global addresses. If specified, the response will contain transactions that affected all of the given global entities. A global entity is marked as "affected" by a transaction if any of its state (or its descendents' state) was modified as a result of the transaction. For performance reasons consensus manager and transaction tracker are excluded from that filter.
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub affected_global_entities_filter: Vec<Address>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub at_ledger_state: Option<LedgerStateSelector>,
        ///This cursor allows forward pagination, by providing the cursor from the previous request.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub cursor: Option<String>,
        ///Allows specifying an array of global addresses. If specified, the response will contain transactions in which all entities emitted events. If an event was published by an internal entity, it is going to be indexed as it is a global ancestor. For performance reasons events published by consensus manager and native XRD resource are excluded from that filter.
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub event_global_emitters_filter: Vec<Address>,
        ///Filters the transaction stream to transactions which emitted at least one event matching each filter (each filter can be satisfied by a different event). Currently *only* deposit and withdrawal events emitted by an internal vault entity are tracked. For the purpose of filtering, the emitter address is replaced by the global ancestor of the emitter, for example, the top-level account / component which contains the vault which emitted the event.
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub events_filter: Vec<StreamTransactionsRequestEventFilterItem>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub from_ledger_state: Option<LedgerStateSelector>,
        ///Limit returned transactions by their kind. Defaults to `user`.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub kind_filter: Option<StreamTransactionsRequestKindFilter>,
        ///The page size requested.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub limit_per_page: Option<i64>,
        ///Similar to `manifest_accounts_withdrawn_from_filter`, but will return only transactions with a manifest containing deposits to the given accounts.
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub manifest_accounts_deposited_into_filter: Vec<Address>,
        ///Allows specifying an array of account addresses. If specified, the response will contain only transactions with a manifest containing withdrawals from the given accounts.
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub manifest_accounts_withdrawn_from_filter: Vec<Address>,
        ///Allows specifying array of badge resource addresses. If specified, the response will contain only transactions where the given badges were presented.
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub manifest_badges_presented_filter: Vec<Address>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub manifest_class_filter: Option<StreamTransactionsRequestManifestClassFilter>,
        ///Allows specifying array of resource addresses. If specified, the response will contain only transactions containing the given resources in the manifest (regardless of their usage).
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub manifest_resources_filter: Vec<Address>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub opt_ins: Option<TransactionDetailsOptIns>,
        ///Configures the order of returned result set. Defaults to `desc`.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub order: Option<StreamTransactionsRequestOrder>,
    }
    impl From<&StreamTransactionsRequest> for StreamTransactionsRequest {
        fn from(value: &StreamTransactionsRequest) -> Self {
            value.clone()
        }
    }
    impl StreamTransactionsRequest {
        pub fn builder() -> builder::StreamTransactionsRequest {
            Default::default()
        }
    }
    ///StreamTransactionsRequestEventFilterItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "event"
    ///  ],
    ///  "properties": {
    ///    "emitter_address": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "event": {
    ///      "type": "string",
    ///      "enum": [
    ///        "Deposit",
    ///        "Withdrawal"
    ///      ]
    ///    },
    ///    "resource_address": {
    ///      "$ref": "#/components/schemas/Address"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StreamTransactionsRequestEventFilterItem {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub emitter_address: Option<Address>,
        pub event: StreamTransactionsRequestEventFilterItemEvent,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub resource_address: Option<Address>,
    }
    impl From<&StreamTransactionsRequestEventFilterItem>
    for StreamTransactionsRequestEventFilterItem {
        fn from(value: &StreamTransactionsRequestEventFilterItem) -> Self {
            value.clone()
        }
    }
    impl StreamTransactionsRequestEventFilterItem {
        pub fn builder() -> builder::StreamTransactionsRequestEventFilterItem {
            Default::default()
        }
    }
    ///StreamTransactionsRequestEventFilterItemEvent
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "Deposit",
    ///    "Withdrawal"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum StreamTransactionsRequestEventFilterItemEvent {
        Deposit,
        Withdrawal,
    }
    impl From<&StreamTransactionsRequestEventFilterItemEvent>
    for StreamTransactionsRequestEventFilterItemEvent {
        fn from(value: &StreamTransactionsRequestEventFilterItemEvent) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for StreamTransactionsRequestEventFilterItemEvent {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Deposit => write!(f, "Deposit"),
                Self::Withdrawal => write!(f, "Withdrawal"),
            }
        }
    }
    impl std::str::FromStr for StreamTransactionsRequestEventFilterItemEvent {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "Deposit" => Ok(Self::Deposit),
                "Withdrawal" => Ok(Self::Withdrawal),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for StreamTransactionsRequestEventFilterItemEvent {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String>
    for StreamTransactionsRequestEventFilterItemEvent {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String>
    for StreamTransactionsRequestEventFilterItemEvent {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///Limit returned transactions by their kind. Defaults to `user`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Limit returned transactions by their kind. Defaults to `user`.",
    ///  "type": "string",
    ///  "enum": [
    ///    "User",
    ///    "EpochChange",
    ///    "All"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum StreamTransactionsRequestKindFilter {
        User,
        EpochChange,
        All,
    }
    impl From<&StreamTransactionsRequestKindFilter>
    for StreamTransactionsRequestKindFilter {
        fn from(value: &StreamTransactionsRequestKindFilter) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for StreamTransactionsRequestKindFilter {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::User => write!(f, "User"),
                Self::EpochChange => write!(f, "EpochChange"),
                Self::All => write!(f, "All"),
            }
        }
    }
    impl std::str::FromStr for StreamTransactionsRequestKindFilter {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "User" => Ok(Self::User),
                "EpochChange" => Ok(Self::EpochChange),
                "All" => Ok(Self::All),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for StreamTransactionsRequestKindFilter {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for StreamTransactionsRequestKindFilter {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for StreamTransactionsRequestKindFilter {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///Allows filtering to transactions which match the given manifest classification. If specified, the response will contain only transactions which have a class that matches the filter. If `match_only_most_specific` set to true, only transactions where the queried class is most specific will be returned. See the [docs on manifest classification](https://docs.radixdlt.com/docs/conforming-transaction-manifest-types) for more information.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Allows filtering to transactions which match the given manifest classification. If specified, the response will contain only transactions which have a class that matches the filter. If `match_only_most_specific` set to true, only transactions where the queried class is most specific will be returned. See the [docs on manifest classification](https://docs.radixdlt.com/docs/conforming-transaction-manifest-types) for more information.",
    ///  "type": "object",
    ///  "required": [
    ///    "class"
    ///  ],
    ///  "properties": {
    ///    "class": {
    ///      "$ref": "#/components/schemas/ManifestClass"
    ///    },
    ///    "match_only_most_specific": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StreamTransactionsRequestManifestClassFilter {
        pub class: ManifestClass,
        #[serde(default)]
        pub match_only_most_specific: bool,
    }
    impl From<&StreamTransactionsRequestManifestClassFilter>
    for StreamTransactionsRequestManifestClassFilter {
        fn from(value: &StreamTransactionsRequestManifestClassFilter) -> Self {
            value.clone()
        }
    }
    impl StreamTransactionsRequestManifestClassFilter {
        pub fn builder() -> builder::StreamTransactionsRequestManifestClassFilter {
            Default::default()
        }
    }
    ///Configures the order of returned result set. Defaults to `desc`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Configures the order of returned result set. Defaults to `desc`.",
    ///  "type": "string",
    ///  "enum": [
    ///    "Asc",
    ///    "Desc"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum StreamTransactionsRequestOrder {
        Asc,
        Desc,
    }
    impl From<&StreamTransactionsRequestOrder> for StreamTransactionsRequestOrder {
        fn from(value: &StreamTransactionsRequestOrder) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for StreamTransactionsRequestOrder {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Asc => write!(f, "Asc"),
                Self::Desc => write!(f, "Desc"),
            }
        }
    }
    impl std::str::FromStr for StreamTransactionsRequestOrder {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "Asc" => Ok(Self::Asc),
                "Desc" => Ok(Self::Desc),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for StreamTransactionsRequestOrder {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for StreamTransactionsRequestOrder {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for StreamTransactionsRequestOrder {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///StreamTransactionsResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/LedgerStateMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "items"
    ///      ],
    ///      "properties": {
    ///        "items": {
    ///          "description": "The page of user transactions.",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/CommittedTransactionInfo"
    ///          }
    ///        },
    ///        "next_cursor": {
    ///          "description": "If specified, contains a cursor to query next page of the `items` collection.",
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct StreamTransactionsResponse {
        ///The page of user transactions.
        pub items: Vec<CommittedTransactionInfo>,
        pub ledger_state: LedgerState,
        ///If specified, contains a cursor to query next page of the `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_cursor: Option<String>,
    }
    impl From<&StreamTransactionsResponse> for StreamTransactionsResponse {
        fn from(value: &StreamTransactionsResponse) -> Self {
            value.clone()
        }
    }
    impl StreamTransactionsResponse {
        pub fn builder() -> builder::StreamTransactionsResponse {
            Default::default()
        }
    }
    /**The finalization status of this subintent. Each subintent can only be *successfully* committed once,
but unlike a transaction intent, could be committed as a failure zero or more times first.
*/
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The finalization status of this subintent. Each subintent can only be *successfully* committed once,\nbut unlike a transaction intent, could be committed as a failure zero or more times first.\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "Unknown",
    ///    "CommittedSuccess"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum SubintentStatus {
        Unknown,
        CommittedSuccess,
    }
    impl From<&SubintentStatus> for SubintentStatus {
        fn from(value: &SubintentStatus) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SubintentStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Unknown => write!(f, "Unknown"),
                Self::CommittedSuccess => write!(f, "CommittedSuccess"),
            }
        }
    }
    impl std::str::FromStr for SubintentStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "Unknown" => Ok(Self::Unknown),
                "CommittedSuccess" => Ok(Self::CommittedSuccess),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for SubintentStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for SubintentStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for SubintentStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///TransactionAccountDepositPreValidationAuthorizedDepositorBadge
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/AccountDepositPreValidationResourceBadge"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/AccountDepositPreValidationNonFungibleBadge"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum TransactionAccountDepositPreValidationAuthorizedDepositorBadge {
        ResourceBadge(AccountDepositPreValidationResourceBadge),
        NonFungibleBadge(AccountDepositPreValidationNonFungibleBadge),
    }
    impl From<&TransactionAccountDepositPreValidationAuthorizedDepositorBadge>
    for TransactionAccountDepositPreValidationAuthorizedDepositorBadge {
        fn from(
            value: &TransactionAccountDepositPreValidationAuthorizedDepositorBadge,
        ) -> Self {
            value.clone()
        }
    }
    impl From<AccountDepositPreValidationResourceBadge>
    for TransactionAccountDepositPreValidationAuthorizedDepositorBadge {
        fn from(value: AccountDepositPreValidationResourceBadge) -> Self {
            Self::ResourceBadge(value)
        }
    }
    impl From<AccountDepositPreValidationNonFungibleBadge>
    for TransactionAccountDepositPreValidationAuthorizedDepositorBadge {
        fn from(value: AccountDepositPreValidationNonFungibleBadge) -> Self {
            Self::NonFungibleBadge(value)
        }
    }
    ///TransactionAccountDepositPreValidationAuthorizedDepositorBadgeBase
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "badge_type",
    ///    "resource_address"
    ///  ],
    ///  "properties": {
    ///    "badge_type": {
    ///      "$ref": "#/components/schemas/AccountAuthorizedDepositorBadgeType"
    ///    },
    ///    "resource_address": {
    ///      "$ref": "#/components/schemas/Address"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct TransactionAccountDepositPreValidationAuthorizedDepositorBadgeBase {
        pub badge_type: AccountAuthorizedDepositorBadgeType,
        pub resource_address: Address,
    }
    impl From<&TransactionAccountDepositPreValidationAuthorizedDepositorBadgeBase>
    for TransactionAccountDepositPreValidationAuthorizedDepositorBadgeBase {
        fn from(
            value: &TransactionAccountDepositPreValidationAuthorizedDepositorBadgeBase,
        ) -> Self {
            value.clone()
        }
    }
    impl TransactionAccountDepositPreValidationAuthorizedDepositorBadgeBase {
        pub fn builder() -> builder::TransactionAccountDepositPreValidationAuthorizedDepositorBadgeBase {
            Default::default()
        }
    }
    ///TransactionBalanceChanges
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": [
    ///    "object",
    ///    "null"
    ///  ],
    ///  "required": [
    ///    "fungible_balance_changes",
    ///    "fungible_fee_balance_changes",
    ///    "non_fungible_balance_changes"
    ///  ],
    ///  "properties": {
    ///    "fungible_balance_changes": {
    ///      "description": "A list of all non-fee-related fungible balance changes per entity and resource.\n",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/TransactionFungibleBalanceChanges"
    ///      }
    ///    },
    ///    "fungible_fee_balance_changes": {
    ///      "description": "A list of all fee-related fungible balance changes per entity and resource.\n",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/TransactionFungibleFeeBalanceChanges"
    ///      }
    ///    },
    ///    "non_fungible_balance_changes": {
    ///      "description": "A list of all non-fungible changes per entity and resource.\n",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/TransactionNonFungibleBalanceChanges"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct TransactionBalanceChanges(pub Option<TransactionBalanceChangesInner>);
    impl ::std::ops::Deref for TransactionBalanceChanges {
        type Target = Option<TransactionBalanceChangesInner>;
        fn deref(&self) -> &Option<TransactionBalanceChangesInner> {
            &self.0
        }
    }
    impl From<TransactionBalanceChanges> for Option<TransactionBalanceChangesInner> {
        fn from(value: TransactionBalanceChanges) -> Self {
            value.0
        }
    }
    impl From<&TransactionBalanceChanges> for TransactionBalanceChanges {
        fn from(value: &TransactionBalanceChanges) -> Self {
            value.clone()
        }
    }
    impl From<Option<TransactionBalanceChangesInner>> for TransactionBalanceChanges {
        fn from(value: Option<TransactionBalanceChangesInner>) -> Self {
            Self(value)
        }
    }
    ///TransactionBalanceChangesInner
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "fungible_balance_changes",
    ///    "fungible_fee_balance_changes",
    ///    "non_fungible_balance_changes"
    ///  ],
    ///  "properties": {
    ///    "fungible_balance_changes": {
    ///      "description": "A list of all non-fee-related fungible balance changes per entity and resource.\n",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/TransactionFungibleBalanceChanges"
    ///      }
    ///    },
    ///    "fungible_fee_balance_changes": {
    ///      "description": "A list of all fee-related fungible balance changes per entity and resource.\n",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/TransactionFungibleFeeBalanceChanges"
    ///      }
    ///    },
    ///    "non_fungible_balance_changes": {
    ///      "description": "A list of all non-fungible changes per entity and resource.\n",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/TransactionNonFungibleBalanceChanges"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct TransactionBalanceChangesInner {
        /**A list of all non-fee-related fungible balance changes per entity and resource.
*/
        pub fungible_balance_changes: Vec<TransactionFungibleBalanceChanges>,
        /**A list of all fee-related fungible balance changes per entity and resource.
*/
        pub fungible_fee_balance_changes: Vec<TransactionFungibleFeeBalanceChanges>,
        /**A list of all non-fungible changes per entity and resource.
*/
        pub non_fungible_balance_changes: Vec<TransactionNonFungibleBalanceChanges>,
    }
    impl From<&TransactionBalanceChangesInner> for TransactionBalanceChangesInner {
        fn from(value: &TransactionBalanceChangesInner) -> Self {
            value.clone()
        }
    }
    impl TransactionBalanceChangesInner {
        pub fn builder() -> builder::TransactionBalanceChangesInner {
            Default::default()
        }
    }
    ///TransactionCommittedDetailsRequest
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "intent_hash": "<transaction-intent-hash>"
    ///    }
    ///  ],
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/AtLedgerStateMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "intent_hash"
    ///      ],
    ///      "properties": {
    ///        "intent_hash": {
    ///          "$ref": "#/components/schemas/HashBech32mString"
    ///        },
    ///        "opt_ins": {
    ///          "$ref": "#/components/schemas/TransactionDetailsOptIns"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct TransactionCommittedDetailsRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub at_ledger_state: Option<LedgerStateSelector>,
        pub intent_hash: HashBech32mString,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub opt_ins: Option<TransactionDetailsOptIns>,
    }
    impl From<&TransactionCommittedDetailsRequest>
    for TransactionCommittedDetailsRequest {
        fn from(value: &TransactionCommittedDetailsRequest) -> Self {
            value.clone()
        }
    }
    impl TransactionCommittedDetailsRequest {
        pub fn builder() -> builder::TransactionCommittedDetailsRequest {
            Default::default()
        }
    }
    ///TransactionCommittedDetailsResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/LedgerStateMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "transaction"
    ///      ],
    ///      "properties": {
    ///        "transaction": {
    ///          "$ref": "#/components/schemas/CommittedTransactionInfo"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct TransactionCommittedDetailsResponse {
        pub ledger_state: LedgerState,
        pub transaction: CommittedTransactionInfo,
    }
    impl From<&TransactionCommittedDetailsResponse>
    for TransactionCommittedDetailsResponse {
        fn from(value: &TransactionCommittedDetailsResponse) -> Self {
            value.clone()
        }
    }
    impl TransactionCommittedDetailsResponse {
        pub fn builder() -> builder::TransactionCommittedDetailsResponse {
            Default::default()
        }
    }
    ///TransactionConstructionResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "type": "object"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/LedgerStateMixin"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct TransactionConstructionResponse(pub LedgerStateMixin);
    impl ::std::ops::Deref for TransactionConstructionResponse {
        type Target = LedgerStateMixin;
        fn deref(&self) -> &LedgerStateMixin {
            &self.0
        }
    }
    impl From<TransactionConstructionResponse> for LedgerStateMixin {
        fn from(value: TransactionConstructionResponse) -> Self {
            value.0
        }
    }
    impl From<&TransactionConstructionResponse> for TransactionConstructionResponse {
        fn from(value: &TransactionConstructionResponse) -> Self {
            value.clone()
        }
    }
    impl From<LedgerStateMixin> for TransactionConstructionResponse {
        fn from(value: LedgerStateMixin) -> Self {
            Self(value)
        }
    }
    ///TransactionDetailsOptIns
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "affected_global_entities": {
    ///      "description": "if set to `true`, all affected global entities by given transaction are returned.",
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "balance_changes": {
    ///      "description": "if set to `true`, returns the fungible and non-fungible balance changes.\n\n**Warning!** This opt-in might be missing for recently committed transactions, in that case a `null` value will be returned. Retry the request until non-null value is returned.\n",
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "manifest_instructions": {
    ///      "description": "if set to `true`, manifest instructions for user transactions are returned.",
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "raw_hex": {
    ///      "description": "if set to `true`, raw transaction hex is returned.",
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "receipt_costing_parameters": {
    ///      "description": "if set to `true`, costing parameters inside receipt object is returned.",
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "receipt_events": {
    ///      "description": "if set to `true`, events inside receipt object is returned.",
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "receipt_fee_destination": {
    ///      "description": "if set to `true`, fee destination inside receipt object is returned.",
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "receipt_fee_source": {
    ///      "description": "if set to `true`, fee source inside receipt object is returned.",
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "receipt_fee_summary": {
    ///      "description": "if set to `true`, fee summary inside receipt object is returned.",
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "receipt_output": {
    ///      "description": "(true by default) if set to `true`, transaction receipt output is returned.",
    ///      "default": true,
    ///      "type": "boolean"
    ///    },
    ///    "receipt_state_changes": {
    ///      "description": "if set to `true`, state changes inside receipt object are returned.",
    ///      "default": false,
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct TransactionDetailsOptIns {
        ///if set to `true`, all affected global entities by given transaction are returned.
        #[serde(default)]
        pub affected_global_entities: bool,
        /**if set to `true`, returns the fungible and non-fungible balance changes.

**Warning!** This opt-in might be missing for recently committed transactions, in that case a `null` value will be returned. Retry the request until non-null value is returned.
*/
        #[serde(default)]
        pub balance_changes: bool,
        ///if set to `true`, manifest instructions for user transactions are returned.
        #[serde(default)]
        pub manifest_instructions: bool,
        ///if set to `true`, raw transaction hex is returned.
        #[serde(default)]
        pub raw_hex: bool,
        ///if set to `true`, costing parameters inside receipt object is returned.
        #[serde(default)]
        pub receipt_costing_parameters: bool,
        ///if set to `true`, events inside receipt object is returned.
        #[serde(default)]
        pub receipt_events: bool,
        ///if set to `true`, fee destination inside receipt object is returned.
        #[serde(default)]
        pub receipt_fee_destination: bool,
        ///if set to `true`, fee source inside receipt object is returned.
        #[serde(default)]
        pub receipt_fee_source: bool,
        ///if set to `true`, fee summary inside receipt object is returned.
        #[serde(default)]
        pub receipt_fee_summary: bool,
        ///(true by default) if set to `true`, transaction receipt output is returned.
        #[serde(default = "defaults::default_bool::<true>")]
        pub receipt_output: bool,
        ///if set to `true`, state changes inside receipt object are returned.
        #[serde(default)]
        pub receipt_state_changes: bool,
    }
    impl From<&TransactionDetailsOptIns> for TransactionDetailsOptIns {
        fn from(value: &TransactionDetailsOptIns) -> Self {
            value.clone()
        }
    }
    impl TransactionDetailsOptIns {
        pub fn builder() -> builder::TransactionDetailsOptIns {
            Default::default()
        }
    }
    ///TransactionFungibleBalanceChanges
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "balance_change",
    ///    "entity_address",
    ///    "resource_address"
    ///  ],
    ///  "properties": {
    ///    "balance_change": {
    ///      "description": "The string-encoded decimal representing the amount of change for the fungible resource.\n",
    ///      "type": "string"
    ///    },
    ///    "entity_address": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "resource_address": {
    ///      "$ref": "#/components/schemas/Address"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct TransactionFungibleBalanceChanges {
        /**The string-encoded decimal representing the amount of change for the fungible resource.
*/
        pub balance_change: String,
        pub entity_address: Address,
        pub resource_address: Address,
    }
    impl From<&TransactionFungibleBalanceChanges> for TransactionFungibleBalanceChanges {
        fn from(value: &TransactionFungibleBalanceChanges) -> Self {
            value.clone()
        }
    }
    impl TransactionFungibleBalanceChanges {
        pub fn builder() -> builder::TransactionFungibleBalanceChanges {
            Default::default()
        }
    }
    /**Indicates fee-related balance changes, for example:

- payment of the fee including tip and royalty,
- distribution of royalties,
- distribution of the fee and tip to the consensus-manager, for distributing to the relevant validator/s at end of epoch.

See https://www.radixdlt.com/blog/how-fees-work-in-babylon for further information on how fee payment works at Babylon.
*/
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates fee-related balance changes, for example:\n\n- payment of the fee including tip and royalty,\n- distribution of royalties,\n- distribution of the fee and tip to the consensus-manager, for distributing to the relevant validator/s at end of epoch.\n\nSee https://www.radixdlt.com/blog/how-fees-work-in-babylon for further information on how fee payment works at Babylon.\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "FeePayment",
    ///    "FeeDistributed",
    ///    "TipDistributed",
    ///    "RoyaltyDistributed"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum TransactionFungibleFeeBalanceChangeType {
        FeePayment,
        FeeDistributed,
        TipDistributed,
        RoyaltyDistributed,
    }
    impl From<&TransactionFungibleFeeBalanceChangeType>
    for TransactionFungibleFeeBalanceChangeType {
        fn from(value: &TransactionFungibleFeeBalanceChangeType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for TransactionFungibleFeeBalanceChangeType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::FeePayment => write!(f, "FeePayment"),
                Self::FeeDistributed => write!(f, "FeeDistributed"),
                Self::TipDistributed => write!(f, "TipDistributed"),
                Self::RoyaltyDistributed => write!(f, "RoyaltyDistributed"),
            }
        }
    }
    impl std::str::FromStr for TransactionFungibleFeeBalanceChangeType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "FeePayment" => Ok(Self::FeePayment),
                "FeeDistributed" => Ok(Self::FeeDistributed),
                "TipDistributed" => Ok(Self::TipDistributed),
                "RoyaltyDistributed" => Ok(Self::RoyaltyDistributed),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for TransactionFungibleFeeBalanceChangeType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for TransactionFungibleFeeBalanceChangeType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for TransactionFungibleFeeBalanceChangeType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///TransactionFungibleFeeBalanceChanges
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "balance_change",
    ///    "entity_address",
    ///    "resource_address",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "balance_change": {
    ///      "description": "The string-encoded decimal representing the amount of change for the fungible resource.\n",
    ///      "type": "string"
    ///    },
    ///    "entity_address": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "resource_address": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "type": {
    ///      "$ref": "#/components/schemas/TransactionFungibleFeeBalanceChangeType"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct TransactionFungibleFeeBalanceChanges {
        /**The string-encoded decimal representing the amount of change for the fungible resource.
*/
        pub balance_change: String,
        pub entity_address: Address,
        pub resource_address: Address,
        #[serde(rename = "type")]
        pub type_: TransactionFungibleFeeBalanceChangeType,
    }
    impl From<&TransactionFungibleFeeBalanceChanges>
    for TransactionFungibleFeeBalanceChanges {
        fn from(value: &TransactionFungibleFeeBalanceChanges) -> Self {
            value.clone()
        }
    }
    impl TransactionFungibleFeeBalanceChanges {
        pub fn builder() -> builder::TransactionFungibleFeeBalanceChanges {
            Default::default()
        }
    }
    /**A more specific intent status. See the description field for further information.
Note that `CommitPendingOutcomeUnknown` can either result in `CommittedSuccess` or `CommittedFailure`.
*/
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A more specific intent status. See the description field for further information.\nNote that `CommitPendingOutcomeUnknown` can either result in `CommittedSuccess` or `CommittedFailure`.\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "Unknown",
    ///    "CommittedSuccess",
    ///    "CommittedFailure",
    ///    "CommitPendingOutcomeUnknown",
    ///    "PermanentlyRejected",
    ///    "LikelyButNotCertainRejection",
    ///    "Pending"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum TransactionIntentStatus {
        Unknown,
        CommittedSuccess,
        CommittedFailure,
        CommitPendingOutcomeUnknown,
        PermanentlyRejected,
        LikelyButNotCertainRejection,
        Pending,
    }
    impl From<&TransactionIntentStatus> for TransactionIntentStatus {
        fn from(value: &TransactionIntentStatus) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for TransactionIntentStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Unknown => write!(f, "Unknown"),
                Self::CommittedSuccess => write!(f, "CommittedSuccess"),
                Self::CommittedFailure => write!(f, "CommittedFailure"),
                Self::CommitPendingOutcomeUnknown => {
                    write!(f, "CommitPendingOutcomeUnknown")
                }
                Self::PermanentlyRejected => write!(f, "PermanentlyRejected"),
                Self::LikelyButNotCertainRejection => {
                    write!(f, "LikelyButNotCertainRejection")
                }
                Self::Pending => write!(f, "Pending"),
            }
        }
    }
    impl std::str::FromStr for TransactionIntentStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "Unknown" => Ok(Self::Unknown),
                "CommittedSuccess" => Ok(Self::CommittedSuccess),
                "CommittedFailure" => Ok(Self::CommittedFailure),
                "CommitPendingOutcomeUnknown" => Ok(Self::CommitPendingOutcomeUnknown),
                "PermanentlyRejected" => Ok(Self::PermanentlyRejected),
                "LikelyButNotCertainRejection" => Ok(Self::LikelyButNotCertainRejection),
                "Pending" => Ok(Self::Pending),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for TransactionIntentStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for TransactionIntentStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for TransactionIntentStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///TransactionNonFungibleBalanceChanges
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "added",
    ///    "entity_address",
    ///    "removed",
    ///    "resource_address"
    ///  ],
    ///  "properties": {
    ///    "added": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/NonFungibleId"
    ///      }
    ///    },
    ///    "entity_address": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "removed": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/NonFungibleId"
    ///      }
    ///    },
    ///    "resource_address": {
    ///      "$ref": "#/components/schemas/Address"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct TransactionNonFungibleBalanceChanges {
        pub added: Vec<NonFungibleId>,
        pub entity_address: Address,
        pub removed: Vec<NonFungibleId>,
        pub resource_address: Address,
    }
    impl From<&TransactionNonFungibleBalanceChanges>
    for TransactionNonFungibleBalanceChanges {
        fn from(value: &TransactionNonFungibleBalanceChanges) -> Self {
            value.clone()
        }
    }
    impl TransactionNonFungibleBalanceChanges {
        pub fn builder() -> builder::TransactionNonFungibleBalanceChanges {
            Default::default()
        }
    }
    ///TransactionNotFoundError
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/GatewayErrorBase"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "intent_hash"
    ///      ],
    ///      "properties": {
    ///        "intent_hash": {
    ///          "$ref": "#/components/schemas/HashBech32mString"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "TransactionNotFoundError"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct TransactionNotFoundError {
        pub intent_hash: HashBech32mString,
        #[serde(rename = "type")]
        pub type_: TransactionNotFoundErrorType,
    }
    impl From<&TransactionNotFoundError> for TransactionNotFoundError {
        fn from(value: &TransactionNotFoundError) -> Self {
            value.clone()
        }
    }
    impl TransactionNotFoundError {
        pub fn builder() -> builder::TransactionNotFoundError {
            Default::default()
        }
    }
    ///TransactionNotFoundErrorType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "TransactionNotFoundError"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum TransactionNotFoundErrorType {
        TransactionNotFoundError,
    }
    impl From<&TransactionNotFoundErrorType> for TransactionNotFoundErrorType {
        fn from(value: &TransactionNotFoundErrorType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for TransactionNotFoundErrorType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TransactionNotFoundError => write!(f, "TransactionNotFoundError"),
            }
        }
    }
    impl std::str::FromStr for TransactionNotFoundErrorType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "TransactionNotFoundError" => Ok(Self::TransactionNotFoundError),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for TransactionNotFoundErrorType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for TransactionNotFoundErrorType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for TransactionNotFoundErrorType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    /**A status concerning the Gateway's handling status of this pending transaction.
*/
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A status concerning the Gateway's handling status of this pending transaction.\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "HandlingSubmission",
    ///    "Concluded"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum TransactionPayloadGatewayHandlingStatus {
        HandlingSubmission,
        Concluded,
    }
    impl From<&TransactionPayloadGatewayHandlingStatus>
    for TransactionPayloadGatewayHandlingStatus {
        fn from(value: &TransactionPayloadGatewayHandlingStatus) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for TransactionPayloadGatewayHandlingStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::HandlingSubmission => write!(f, "HandlingSubmission"),
                Self::Concluded => write!(f, "Concluded"),
            }
        }
    }
    impl std::str::FromStr for TransactionPayloadGatewayHandlingStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "HandlingSubmission" => Ok(Self::HandlingSubmission),
                "Concluded" => Ok(Self::Concluded),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for TransactionPayloadGatewayHandlingStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for TransactionPayloadGatewayHandlingStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for TransactionPayloadGatewayHandlingStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    /**A more specific payload status. See the description field for further information.
*/
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A more specific payload status. See the description field for further information.\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "Unknown",
    ///    "CommittedSuccess",
    ///    "CommittedFailure",
    ///    "CommitPendingOutcomeUnknown",
    ///    "PermanentlyRejected",
    ///    "TemporarilyRejected",
    ///    "Pending"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum TransactionPayloadStatus {
        Unknown,
        CommittedSuccess,
        CommittedFailure,
        CommitPendingOutcomeUnknown,
        PermanentlyRejected,
        TemporarilyRejected,
        Pending,
    }
    impl From<&TransactionPayloadStatus> for TransactionPayloadStatus {
        fn from(value: &TransactionPayloadStatus) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for TransactionPayloadStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Unknown => write!(f, "Unknown"),
                Self::CommittedSuccess => write!(f, "CommittedSuccess"),
                Self::CommittedFailure => write!(f, "CommittedFailure"),
                Self::CommitPendingOutcomeUnknown => {
                    write!(f, "CommitPendingOutcomeUnknown")
                }
                Self::PermanentlyRejected => write!(f, "PermanentlyRejected"),
                Self::TemporarilyRejected => write!(f, "TemporarilyRejected"),
                Self::Pending => write!(f, "Pending"),
            }
        }
    }
    impl std::str::FromStr for TransactionPayloadStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "Unknown" => Ok(Self::Unknown),
                "CommittedSuccess" => Ok(Self::CommittedSuccess),
                "CommittedFailure" => Ok(Self::CommittedFailure),
                "CommitPendingOutcomeUnknown" => Ok(Self::CommitPendingOutcomeUnknown),
                "PermanentlyRejected" => Ok(Self::PermanentlyRejected),
                "TemporarilyRejected" => Ok(Self::TemporarilyRejected),
                "Pending" => Ok(Self::Pending),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for TransactionPayloadStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for TransactionPayloadStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for TransactionPayloadStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///A set of flags to configure the response of the transaction preview.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A set of flags to configure the response of the transaction preview.",
    ///  "type": "object",
    ///  "properties": {
    ///    "radix_engine_toolkit_receipt": {
    ///      "description": "This flag controls whether the preview response will include a Radix Engine Toolkit serializable\nreceipt or not. If not provided, this defaults to `false` and no toolkit receipt is provided in\nthe response.\n",
    ///      "default": false,
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct TransactionPreviewOptIns {
        /**This flag controls whether the preview response will include a Radix Engine Toolkit serializable
receipt or not. If not provided, this defaults to `false` and no toolkit receipt is provided in
the response.
*/
        #[serde(default)]
        pub radix_engine_toolkit_receipt: bool,
    }
    impl From<&TransactionPreviewOptIns> for TransactionPreviewOptIns {
        fn from(value: &TransactionPreviewOptIns) -> Self {
            value.clone()
        }
    }
    impl TransactionPreviewOptIns {
        pub fn builder() -> builder::TransactionPreviewOptIns {
            Default::default()
        }
    }
    ///TransactionPreviewRequest
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "manifest"
    ///  ],
    ///  "properties": {
    ///    "blobs_hex": {
    ///      "description": "An array of hex-encoded blob data, if referenced by the manifest.",
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      }
    ///    },
    ///    "end_epoch_exclusive": {
    ///      "description": "An integer between `0` and `10^10`, marking the epoch at which the transaction is no\nlonger valid. If omitted, a maximum epoch (relative to the `start_epoch_inclusive`) will be used.\n",
    ///      "type": "integer",
    ///      "format": "int64",
    ///      "maximum": 10000000000.0,
    ///      "minimum": 0.0
    ///    },
    ///    "flags": {
    ///      "$ref": "#/components/schemas/PreviewFlags"
    ///    },
    ///    "manifest": {
    ///      "description": "A text-representation of a transaction manifest",
    ///      "type": "string"
    ///    },
    ///    "message": {
    ///      "description": "An optional transaction message. Only affects the costing.\nThis type is defined in the Core API as `TransactionMessage`. See the Core API documentation for more details.\n",
    ///      "type": "object"
    ///    },
    ///    "nonce": {
    ///      "description": "An integer between `0` and `2^32 - 1`, chosen to allow a unique intent to be created\n(to enable submitting an otherwise identical/duplicate intent).\nIf not provided, this defaults to 0.\n",
    ///      "type": "integer",
    ///      "format": "int64",
    ///      "minimum": 0.0
    ///    },
    ///    "notary_is_signatory": {
    ///      "description": "Whether the notary should be used as a signer (optional).\nIf not provided, this defaults to false.\n",
    ///      "type": "boolean"
    ///    },
    ///    "notary_public_key": {
    ///      "$ref": "#/components/schemas/PublicKey"
    ///    },
    ///    "opt_ins": {
    ///      "$ref": "#/components/schemas/TransactionPreviewOptIns"
    ///    },
    ///    "signer_public_keys": {
    ///      "description": "A list of public keys to be used as transaction signers.\nIf not provided, this defaults to an empty array.\n",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PublicKey"
    ///      }
    ///    },
    ///    "start_epoch_inclusive": {
    ///      "description": "An integer between `0` and `10^10`, marking the epoch at which the transaction startsbeing valid.\nIf omitted, the current epoch will be used.\n",
    ///      "type": "integer",
    ///      "format": "int64",
    ///      "maximum": 10000000000.0,
    ///      "minimum": 0.0
    ///    },
    ///    "tip_percentage": {
    ///      "description": "An integer between `0` and `65535`, giving the validator tip as a percentage amount.\nA value of `1` corresponds to a 1% fee.\nIf not provided, this defaults to 0.\n",
    ///      "type": "integer",
    ///      "format": "int32",
    ///      "maximum": 65535.0,
    ///      "minimum": 0.0
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct TransactionPreviewRequest {
        ///An array of hex-encoded blob data, if referenced by the manifest.
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub blobs_hex: Vec<String>,
        /**An integer between `0` and `10^10`, marking the epoch at which the transaction is no
longer valid. If omitted, a maximum epoch (relative to the `start_epoch_inclusive`) will be used.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub end_epoch_exclusive: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub flags: Option<PreviewFlags>,
        ///A text-representation of a transaction manifest
        pub manifest: String,
        /**An optional transaction message. Only affects the costing.
This type is defined in the Core API as `TransactionMessage`. See the Core API documentation for more details.
*/
        #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
        pub message: ::serde_json::Map<String, ::serde_json::Value>,
        /**An integer between `0` and `2^32 - 1`, chosen to allow a unique intent to be created
(to enable submitting an otherwise identical/duplicate intent).
If not provided, this defaults to 0.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub nonce: Option<i64>,
        /**Whether the notary should be used as a signer (optional).
If not provided, this defaults to false.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub notary_is_signatory: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub notary_public_key: Option<PublicKey>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub opt_ins: Option<TransactionPreviewOptIns>,
        /**A list of public keys to be used as transaction signers.
If not provided, this defaults to an empty array.
*/
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub signer_public_keys: Vec<PublicKey>,
        /**An integer between `0` and `10^10`, marking the epoch at which the transaction startsbeing valid.
If omitted, the current epoch will be used.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub start_epoch_inclusive: Option<i64>,
        /**An integer between `0` and `65535`, giving the validator tip as a percentage amount.
A value of `1` corresponds to a 1% fee.
If not provided, this defaults to 0.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub tip_percentage: Option<u16>,
    }
    impl From<&TransactionPreviewRequest> for TransactionPreviewRequest {
        fn from(value: &TransactionPreviewRequest) -> Self {
            value.clone()
        }
    }
    impl TransactionPreviewRequest {
        pub fn builder() -> builder::TransactionPreviewRequest {
            Default::default()
        }
    }
    ///TransactionPreviewResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "encoded_receipt",
    ///    "logs",
    ///    "receipt",
    ///    "resource_changes"
    ///  ],
    ///  "properties": {
    ///    "encoded_receipt": {
    ///      "$ref": "#/components/schemas/HexString"
    ///    },
    ///    "logs": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "level",
    ///          "message"
    ///        ],
    ///        "properties": {
    ///          "level": {
    ///            "type": "string"
    ///          },
    ///          "message": {
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "radix_engine_toolkit_receipt": {
    ///      "description": "An optional field which is only provided if the `radix_engine_toolkit_receipt`\nflag is set to true when requesting a transaction preview from the API.\n\nThis receipt is primarily intended for use with the toolkit and may contain information\nthat is already available in the receipt provided in the `receipt` field of this response.\n\nA typical client of this API is not expected to use this receipt. The primary clients\nthis receipt is intended for is the Radix wallet or any client that needs to perform\nexecution summaries on their transactions.\n",
    ///      "type": "object"
    ///    },
    ///    "receipt": {
    ///      "description": "This type is defined in the Core API as `TransactionReceipt`. See the Core API documentation for more details.\n",
    ///      "type": "object"
    ///    },
    ///    "resource_changes": {
    ///      "type": "array",
    ///      "items": {
    ///        "description": "This type is defined in the Core API as `InstructionResourceChanges`. See the Core API documentation for more details.\n",
    ///        "type": "object"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct TransactionPreviewResponse {
        pub encoded_receipt: HexString,
        pub logs: Vec<TransactionPreviewResponseLogsItem>,
        /**An optional field which is only provided if the `radix_engine_toolkit_receipt`
flag is set to true when requesting a transaction preview from the API.

This receipt is primarily intended for use with the toolkit and may contain information
that is already available in the receipt provided in the `receipt` field of this response.

A typical client of this API is not expected to use this receipt. The primary clients
this receipt is intended for is the Radix wallet or any client that needs to perform
execution summaries on their transactions.
*/
        #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
        pub radix_engine_toolkit_receipt: ::serde_json::Map<String, ::serde_json::Value>,
        /**This type is defined in the Core API as `TransactionReceipt`. See the Core API documentation for more details.
*/
        pub receipt: ::serde_json::Map<String, ::serde_json::Value>,
        pub resource_changes: Vec<::serde_json::Map<String, ::serde_json::Value>>,
    }
    impl From<&TransactionPreviewResponse> for TransactionPreviewResponse {
        fn from(value: &TransactionPreviewResponse) -> Self {
            value.clone()
        }
    }
    impl TransactionPreviewResponse {
        pub fn builder() -> builder::TransactionPreviewResponse {
            Default::default()
        }
    }
    ///TransactionPreviewResponseLogsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "level",
    ///    "message"
    ///  ],
    ///  "properties": {
    ///    "level": {
    ///      "type": "string"
    ///    },
    ///    "message": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct TransactionPreviewResponseLogsItem {
        pub level: String,
        pub message: String,
    }
    impl From<&TransactionPreviewResponseLogsItem>
    for TransactionPreviewResponseLogsItem {
        fn from(value: &TransactionPreviewResponseLogsItem) -> Self {
            value.clone()
        }
    }
    impl TransactionPreviewResponseLogsItem {
        pub fn builder() -> builder::TransactionPreviewResponseLogsItem {
            Default::default()
        }
    }
    ///A set of flags to configure the response of the transaction preview v2 endpoint.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A set of flags to configure the response of the transaction preview v2 endpoint.",
    ///  "type": "object",
    ///  "properties": {
    ///    "core_api_receipt": {
    ///      "description": "This flag controls whether the preview response will include a Core API receipt or not.\nIf not provided, this defaults to `false` and no core api receipt is provided in\nthe response.\n",
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "logs": {
    ///      "description": "This flag controls whether the preview response will include execution logs.\nIf not provided, this defaults to `false` and no logs will be provided in the response.\n",
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "radix_engine_toolkit_receipt": {
    ///      "description": "This flag controls whether the preview response will include a Radix Engine Toolkit serializable\nreceipt or not. If not provided, this defaults to `false` and no toolkit receipt is provided in\nthe response.\n",
    ///      "default": false,
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct TransactionPreviewV2OptIns {
        /**This flag controls whether the preview response will include a Core API receipt or not.
If not provided, this defaults to `false` and no core api receipt is provided in
the response.
*/
        #[serde(default)]
        pub core_api_receipt: bool,
        /**This flag controls whether the preview response will include execution logs.
If not provided, this defaults to `false` and no logs will be provided in the response.
*/
        #[serde(default)]
        pub logs: bool,
        /**This flag controls whether the preview response will include a Radix Engine Toolkit serializable
receipt or not. If not provided, this defaults to `false` and no toolkit receipt is provided in
the response.
*/
        #[serde(default)]
        pub radix_engine_toolkit_receipt: bool,
    }
    impl From<&TransactionPreviewV2OptIns> for TransactionPreviewV2OptIns {
        fn from(value: &TransactionPreviewV2OptIns) -> Self {
            value.clone()
        }
    }
    impl TransactionPreviewV2OptIns {
        pub fn builder() -> builder::TransactionPreviewV2OptIns {
            Default::default()
        }
    }
    ///TransactionPreviewV2Request
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "flags": {
    ///        "assume_all_signature_proofs": true,
    ///        "disable_auth_checks": true,
    ///        "skip_epoch_check": true,
    ///        "use_free_credit": true
    ///      },
    ///      "opt_ins": {
    ///        "core_api_receipt": true,
    ///        "logs": true,
    ///        "radix_engine_toolkit_receipt": true
    ///      },
    ///      "preview_transaction": {
    ///        "preview_transaction_hex": "<sample-preview-transaction-hex>",
    ///        "type": "Compiled"
    ///      }
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "preview_transaction"
    ///  ],
    ///  "properties": {
    ///    "flags": {
    ///      "$ref": "#/components/schemas/PreviewFlags"
    ///    },
    ///    "opt_ins": {
    ///      "$ref": "#/components/schemas/TransactionPreviewV2OptIns"
    ///    },
    ///    "preview_transaction": {
    ///      "$ref": "#/components/schemas/PreviewTransaction"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct TransactionPreviewV2Request {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub flags: Option<PreviewFlags>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub opt_ins: Option<TransactionPreviewV2OptIns>,
        pub preview_transaction: PreviewTransaction,
    }
    impl From<&TransactionPreviewV2Request> for TransactionPreviewV2Request {
        fn from(value: &TransactionPreviewV2Request) -> Self {
            value.clone()
        }
    }
    impl TransactionPreviewV2Request {
        pub fn builder() -> builder::TransactionPreviewV2Request {
            Default::default()
        }
    }
    ///TransactionPreviewV2Response
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "at_ledger_state_version"
    ///  ],
    ///  "properties": {
    ///    "at_ledger_state_version": {
    ///      "description": "A summarized state of the ledger on top of which the preview was performed.",
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "logs": {
    ///      "description": "An optional field which is only provided if the `logs` flag is set to true in the\n`opt_ins` property of the request.\n\nIf present, it gives the emitted logs from the transaction execution.\n",
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "level",
    ///          "message"
    ///        ],
    ///        "properties": {
    ///          "level": {
    ///            "type": "string"
    ///          },
    ///          "message": {
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "radix_engine_toolkit_receipt": {
    ///      "description": "An optional field which is only provided if the `radix_engine_toolkit_receipt`\nflag is set to true in the `opt_ins` property of the request.\n\nThis receipt is primarily intended for use with the toolkit and may contain information\nthat is already available in the receipt provided in the `receipt` field of this\nresponse.\n\nA typical client of this API is not expected to use this receipt. The primary clients\nthis receipt is intended for is the Radix wallet or any client that needs to perform\nexecution summaries on their transactions.\n",
    ///      "type": "object"
    ///    },
    ///    "receipt": {
    ///      "description": "This is provided unless the `core_api_receipt` flag is set to false in the `opt_ins `\nproperty of the request.\n\nThis type is defined in the Core API as `TransactionReceipt`. See the Core API documentation for more details.\n",
    ///      "type": "object"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct TransactionPreviewV2Response {
        ///A summarized state of the ledger on top of which the preview was performed.
        pub at_ledger_state_version: i64,
        /**An optional field which is only provided if the `logs` flag is set to true in the
`opt_ins` property of the request.

If present, it gives the emitted logs from the transaction execution.
*/
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub logs: Vec<TransactionPreviewV2ResponseLogsItem>,
        /**An optional field which is only provided if the `radix_engine_toolkit_receipt`
flag is set to true in the `opt_ins` property of the request.

This receipt is primarily intended for use with the toolkit and may contain information
that is already available in the receipt provided in the `receipt` field of this
response.

A typical client of this API is not expected to use this receipt. The primary clients
this receipt is intended for is the Radix wallet or any client that needs to perform
execution summaries on their transactions.
*/
        #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
        pub radix_engine_toolkit_receipt: ::serde_json::Map<String, ::serde_json::Value>,
        /**This is provided unless the `core_api_receipt` flag is set to false in the `opt_ins `
property of the request.

This type is defined in the Core API as `TransactionReceipt`. See the Core API documentation for more details.
*/
        #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
        pub receipt: ::serde_json::Map<String, ::serde_json::Value>,
    }
    impl From<&TransactionPreviewV2Response> for TransactionPreviewV2Response {
        fn from(value: &TransactionPreviewV2Response) -> Self {
            value.clone()
        }
    }
    impl TransactionPreviewV2Response {
        pub fn builder() -> builder::TransactionPreviewV2Response {
            Default::default()
        }
    }
    ///TransactionPreviewV2ResponseLogsItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "level",
    ///    "message"
    ///  ],
    ///  "properties": {
    ///    "level": {
    ///      "type": "string"
    ///    },
    ///    "message": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct TransactionPreviewV2ResponseLogsItem {
        pub level: String,
        pub message: String,
    }
    impl From<&TransactionPreviewV2ResponseLogsItem>
    for TransactionPreviewV2ResponseLogsItem {
        fn from(value: &TransactionPreviewV2ResponseLogsItem) -> Self {
            value.clone()
        }
    }
    impl TransactionPreviewV2ResponseLogsItem {
        pub fn builder() -> builder::TransactionPreviewV2ResponseLogsItem {
            Default::default()
        }
    }
    ///TransactionReceipt
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "costing_parameters": {
    ///      "type": "object"
    ///    },
    ///    "error_message": {
    ///      "description": "Error message (only present if status is `Failed` or `Rejected`)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "events": {
    ///      "description": "Events emitted by a transaction.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/EventsItem"
    ///      }
    ///    },
    ///    "fee_destination": {
    ///      "description": "This type is defined in the Core API as `FeeDestination`. See the Core API documentation for more details.\n",
    ///      "type": "object"
    ///    },
    ///    "fee_source": {
    ///      "description": "This type is defined in the Core API as `FeeSource`. See the Core API documentation for more details.\n",
    ///      "type": "object"
    ///    },
    ///    "fee_summary": {
    ///      "description": "This type is defined in the Core API as `FeeSummary`. See the Core API documentation for more details.\n",
    ///      "type": "object"
    ///    },
    ///    "next_epoch": {
    ///      "description": "Information (number and active validator list) about new epoch if occured.\nThis type is defined in the Core API as `NextEpoch`. See the Core API documentation for more details.\n",
    ///      "type": "object"
    ///    },
    ///    "output": {
    ///      "description": "The manifest line-by-line engine return data (only present if `status` is `CommittedSuccess`).\nThis type is defined in the Core API as `SborData`. See the Core API documentation for more details.\n",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/SborData"
    ///      }
    ///    },
    ///    "state_updates": {
    ///      "description": "This type is defined in the Core API as `StateUpdates`. See the Core API documentation for more details.\n",
    ///      "type": "object"
    ///    },
    ///    "status": {
    ///      "$ref": "#/components/schemas/TransactionStatus"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct TransactionReceipt {
        #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
        pub costing_parameters: ::serde_json::Map<String, ::serde_json::Value>,
        ///Error message (only present if status is `Failed` or `Rejected`)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub error_message: Option<String>,
        ///Events emitted by a transaction.
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub events: Vec<EventsItem>,
        /**This type is defined in the Core API as `FeeDestination`. See the Core API documentation for more details.
*/
        #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
        pub fee_destination: ::serde_json::Map<String, ::serde_json::Value>,
        /**This type is defined in the Core API as `FeeSource`. See the Core API documentation for more details.
*/
        #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
        pub fee_source: ::serde_json::Map<String, ::serde_json::Value>,
        /**This type is defined in the Core API as `FeeSummary`. See the Core API documentation for more details.
*/
        #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
        pub fee_summary: ::serde_json::Map<String, ::serde_json::Value>,
        /**Information (number and active validator list) about new epoch if occured.
This type is defined in the Core API as `NextEpoch`. See the Core API documentation for more details.
*/
        #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
        pub next_epoch: ::serde_json::Map<String, ::serde_json::Value>,
        /**The manifest line-by-line engine return data (only present if `status` is `CommittedSuccess`).
This type is defined in the Core API as `SborData`. See the Core API documentation for more details.
*/
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub output: Vec<SborData>,
        /**This type is defined in the Core API as `StateUpdates`. See the Core API documentation for more details.
*/
        #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
        pub state_updates: ::serde_json::Map<String, ::serde_json::Value>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub status: Option<TransactionStatus>,
    }
    impl From<&TransactionReceipt> for TransactionReceipt {
        fn from(value: &TransactionReceipt) -> Self {
            value.clone()
        }
    }
    impl TransactionReceipt {
        pub fn builder() -> builder::TransactionReceipt {
            Default::default()
        }
    }
    /**A top-level intent status, left in for backwards compatibility.
It doesn't give much information. Rejected means PermanentRejection.
*/
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A top-level intent status, left in for backwards compatibility.\nIt doesn't give much information. Rejected means PermanentRejection.\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "Unknown",
    ///    "CommittedSuccess",
    ///    "CommittedFailure",
    ///    "Pending",
    ///    "Rejected"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum TransactionStatus {
        Unknown,
        CommittedSuccess,
        CommittedFailure,
        Pending,
        Rejected,
    }
    impl From<&TransactionStatus> for TransactionStatus {
        fn from(value: &TransactionStatus) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for TransactionStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Unknown => write!(f, "Unknown"),
                Self::CommittedSuccess => write!(f, "CommittedSuccess"),
                Self::CommittedFailure => write!(f, "CommittedFailure"),
                Self::Pending => write!(f, "Pending"),
                Self::Rejected => write!(f, "Rejected"),
            }
        }
    }
    impl std::str::FromStr for TransactionStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "Unknown" => Ok(Self::Unknown),
                "CommittedSuccess" => Ok(Self::CommittedSuccess),
                "CommittedFailure" => Ok(Self::CommittedFailure),
                "Pending" => Ok(Self::Pending),
                "Rejected" => Ok(Self::Rejected),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for TransactionStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for TransactionStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for TransactionStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///TransactionStatusRequest
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "intent_hash"
    ///  ],
    ///  "properties": {
    ///    "intent_hash": {
    ///      "$ref": "#/components/schemas/HashBech32mString"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct TransactionStatusRequest {
        pub intent_hash: HashBech32mString,
    }
    impl From<&TransactionStatusRequest> for TransactionStatusRequest {
        fn from(value: &TransactionStatusRequest) -> Self {
            value.clone()
        }
    }
    impl TransactionStatusRequest {
        pub fn builder() -> builder::TransactionStatusRequest {
            Default::default()
        }
    }
    ///TransactionStatusResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/LedgerStateMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "intent_status",
    ///        "intent_status_description",
    ///        "known_payloads",
    ///        "status"
    ///      ],
    ///      "properties": {
    ///        "committed_state_version": {
    ///          "description": "If the intent was committed, this gives the state version when this intent was committed.\n",
    ///          "type": [
    ///            "integer",
    ///            "null"
    ///          ],
    ///          "format": "int64"
    ///        },
    ///        "error_message": {
    ///          "description": "The most relevant error message received, due to a rejection or commit as failure.\nPlease note that presence of an error message doesn't imply that the intent\nwill definitely reject or fail. This could represent a temporary error (such as out\nof fees), or an error with a payload which doesn't end up being committed.\n",
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ]
    ///        },
    ///        "intent_status": {
    ///          "$ref": "#/components/schemas/TransactionIntentStatus"
    ///        },
    ///        "intent_status_description": {
    ///          "description": "An additional description to clarify the intent status.\n",
    ///          "type": "string"
    ///        },
    ///        "known_payloads": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/TransactionStatusResponseKnownPayloadItem"
    ///          }
    ///        },
    ///        "permanently_rejects_at_epoch": {
    ///          "description": "The epoch number at which the transaction is guaranteed to get permanently rejected by the Network due to exceeded epoch range defined when submitting transaction.",
    ///          "type": [
    ///            "integer",
    ///            "null"
    ///          ],
    ///          "format": "int64",
    ///          "maximum": 10000000000.0,
    ///          "minimum": 0.0
    ///        },
    ///        "status": {
    ///          "$ref": "#/components/schemas/TransactionStatus"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct TransactionStatusResponse {
        /**If the intent was committed, this gives the state version when this intent was committed.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub committed_state_version: Option<i64>,
        /**The most relevant error message received, due to a rejection or commit as failure.
Please note that presence of an error message doesn't imply that the intent
will definitely reject or fail. This could represent a temporary error (such as out
of fees), or an error with a payload which doesn't end up being committed.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub error_message: Option<String>,
        pub intent_status: TransactionIntentStatus,
        /**An additional description to clarify the intent status.
*/
        pub intent_status_description: String,
        pub known_payloads: Vec<TransactionStatusResponseKnownPayloadItem>,
        pub ledger_state: LedgerState,
        ///The epoch number at which the transaction is guaranteed to get permanently rejected by the Network due to exceeded epoch range defined when submitting transaction.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub permanently_rejects_at_epoch: Option<i64>,
        pub status: TransactionStatus,
    }
    impl From<&TransactionStatusResponse> for TransactionStatusResponse {
        fn from(value: &TransactionStatusResponse) -> Self {
            value.clone()
        }
    }
    impl TransactionStatusResponse {
        pub fn builder() -> builder::TransactionStatusResponse {
            Default::default()
        }
    }
    ///TransactionStatusResponseKnownPayloadItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "payload_hash",
    ///    "status"
    ///  ],
    ///  "properties": {
    ///    "error_message": {
    ///      "description": "The initial error message received for a rejection or failure during transaction execution.\nThis will typically be the useful error message, explaining the root cause of the issue.\nPlease note that presence of an error message doesn't imply that this payload\nwill definitely reject or fail. This could represent an error during a temporary\nrejection (such as out of fees) which then gets resolved (e.g. by depositing money\nto pay the fee), allowing the transaction to be committed.\n",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "handling_status": {
    ///      "$ref": "#/components/schemas/TransactionPayloadGatewayHandlingStatus"
    ///    },
    ///    "handling_status_reason": {
    ///      "description": "Additional reason for why the Gateway has its current handling status.\n",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "latest_error_message": {
    ///      "description": "The latest error message received for a rejection or failure during transaction execution,\nthis is only returned if it is different from the initial error message.\nThis is more current than the initial error message, but may be less useful, as it could\nbe a message regarding the expiry of the transaction at the end of its epoch validity window.\nPlease note that presence of an error message doesn't imply that this payload\nwill definitely reject or fail. This could represent an error during a temporary\nrejection (such as out of fees) which then gets resolved (e.g. by depositing money\nto pay the fee), allowing the transaction to be committed.\n",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "payload_hash": {
    ///      "$ref": "#/components/schemas/HashBech32mString"
    ///    },
    ///    "payload_status": {
    ///      "$ref": "#/components/schemas/TransactionPayloadStatus"
    ///    },
    ///    "payload_status_description": {
    ///      "description": "An additional description to clarify the payload status.\n",
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "$ref": "#/components/schemas/TransactionStatus"
    ///    },
    ///    "submission_error": {
    ///      "description": "The most recent error message received when submitting this transaction to the network.\nPlease note that the presence of an error message doesn't imply that this transaction\npayload will definitely reject or fail. This could be a transient error.\n",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct TransactionStatusResponseKnownPayloadItem {
        /**The initial error message received for a rejection or failure during transaction execution.
This will typically be the useful error message, explaining the root cause of the issue.
Please note that presence of an error message doesn't imply that this payload
will definitely reject or fail. This could represent an error during a temporary
rejection (such as out of fees) which then gets resolved (e.g. by depositing money
to pay the fee), allowing the transaction to be committed.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub error_message: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub handling_status: Option<TransactionPayloadGatewayHandlingStatus>,
        /**Additional reason for why the Gateway has its current handling status.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub handling_status_reason: Option<String>,
        /**The latest error message received for a rejection or failure during transaction execution,
this is only returned if it is different from the initial error message.
This is more current than the initial error message, but may be less useful, as it could
be a message regarding the expiry of the transaction at the end of its epoch validity window.
Please note that presence of an error message doesn't imply that this payload
will definitely reject or fail. This could represent an error during a temporary
rejection (such as out of fees) which then gets resolved (e.g. by depositing money
to pay the fee), allowing the transaction to be committed.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub latest_error_message: Option<String>,
        pub payload_hash: HashBech32mString,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub payload_status: Option<TransactionPayloadStatus>,
        /**An additional description to clarify the payload status.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub payload_status_description: Option<String>,
        pub status: TransactionStatus,
        /**The most recent error message received when submitting this transaction to the network.
Please note that the presence of an error message doesn't imply that this transaction
payload will definitely reject or fail. This could be a transient error.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub submission_error: Option<String>,
    }
    impl From<&TransactionStatusResponseKnownPayloadItem>
    for TransactionStatusResponseKnownPayloadItem {
        fn from(value: &TransactionStatusResponseKnownPayloadItem) -> Self {
            value.clone()
        }
    }
    impl TransactionStatusResponseKnownPayloadItem {
        pub fn builder() -> builder::TransactionStatusResponseKnownPayloadItem {
            Default::default()
        }
    }
    ///TransactionSubintentDetails
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "subintent_hash"
    ///  ],
    ///  "properties": {
    ///    "child_subintent_hashes": {
    ///      "description": "The subintent hash of each child of the subintent.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/HashBech32mString"
    ///      }
    ///    },
    ///    "manifest_instructions": {
    ///      "description": "A text-representation of a subintent manifest.\nThis field will be present only for user transactions and when explicitly opted-in using the `manifest_instructions` flag.\n",
    ///      "type": "string"
    ///    },
    ///    "message": {
    ///      "description": "The optional subintent message.\nThis type is defined in the Core API as `TransactionMessage`. See the Core API documentation for more details.\n",
    ///      "type": "object"
    ///    },
    ///    "subintent_hash": {
    ///      "$ref": "#/components/schemas/HashBech32mString"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct TransactionSubintentDetails {
        ///The subintent hash of each child of the subintent.
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub child_subintent_hashes: Vec<HashBech32mString>,
        /**A text-representation of a subintent manifest.
This field will be present only for user transactions and when explicitly opted-in using the `manifest_instructions` flag.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub manifest_instructions: Option<String>,
        /**The optional subintent message.
This type is defined in the Core API as `TransactionMessage`. See the Core API documentation for more details.
*/
        #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
        pub message: ::serde_json::Map<String, ::serde_json::Value>,
        pub subintent_hash: HashBech32mString,
    }
    impl From<&TransactionSubintentDetails> for TransactionSubintentDetails {
        fn from(value: &TransactionSubintentDetails) -> Self {
            value.clone()
        }
    }
    impl TransactionSubintentDetails {
        pub fn builder() -> builder::TransactionSubintentDetails {
            Default::default()
        }
    }
    ///TransactionSubintentStatusRequest
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "subintent_hash": "<transaction-subintent-hash>"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "subintent_hash"
    ///  ],
    ///  "properties": {
    ///    "subintent_hash": {
    ///      "$ref": "#/components/schemas/HashBech32mString"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct TransactionSubintentStatusRequest {
        pub subintent_hash: HashBech32mString,
    }
    impl From<&TransactionSubintentStatusRequest> for TransactionSubintentStatusRequest {
        fn from(value: &TransactionSubintentStatusRequest) -> Self {
            value.clone()
        }
    }
    impl TransactionSubintentStatusRequest {
        pub fn builder() -> builder::TransactionSubintentStatusRequest {
            Default::default()
        }
    }
    ///TransactionSubintentStatusResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/LedgerStateMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "subintent_status",
    ///        "subintent_status_description"
    ///      ],
    ///      "properties": {
    ///        "finalized_at_state_version": {
    ///          "description": "The state version when the subintent was finalized (committed as a success). This field is only present if the status is `CommittedSuccess`.\n",
    ///          "type": [
    ///            "integer",
    ///            "null"
    ///          ],
    ///          "format": "int64"
    ///        },
    ///        "finalized_at_transaction_intent_hash": {
    ///          "$ref": "#/components/schemas/HashBech32mString"
    ///        },
    ///        "subintent_status": {
    ///          "$ref": "#/components/schemas/SubintentStatus"
    ///        },
    ///        "subintent_status_description": {
    ///          "description": "An additional description to clarify the `subintent_status`.\n",
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct TransactionSubintentStatusResponse {
        /**The state version when the subintent was finalized (committed as a success). This field is only present if the status is `CommittedSuccess`.
*/
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub finalized_at_state_version: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub finalized_at_transaction_intent_hash: Option<HashBech32mString>,
        pub ledger_state: LedgerState,
        pub subintent_status: SubintentStatus,
        /**An additional description to clarify the `subintent_status`.
*/
        pub subintent_status_description: String,
    }
    impl From<&TransactionSubintentStatusResponse>
    for TransactionSubintentStatusResponse {
        fn from(value: &TransactionSubintentStatusResponse) -> Self {
            value.clone()
        }
    }
    impl TransactionSubintentStatusResponse {
        pub fn builder() -> builder::TransactionSubintentStatusResponse {
            Default::default()
        }
    }
    ///TransactionSubmitRequest
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "notarized_transaction_hex"
    ///  ],
    ///  "properties": {
    ///    "notarized_transaction_hex": {
    ///      "$ref": "#/components/schemas/NotarizedTransactionHexString"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct TransactionSubmitRequest {
        pub notarized_transaction_hex: NotarizedTransactionHexString,
    }
    impl From<&TransactionSubmitRequest> for TransactionSubmitRequest {
        fn from(value: &TransactionSubmitRequest) -> Self {
            value.clone()
        }
    }
    impl TransactionSubmitRequest {
        pub fn builder() -> builder::TransactionSubmitRequest {
            Default::default()
        }
    }
    ///TransactionSubmitResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "duplicate"
    ///  ],
    ///  "properties": {
    ///    "duplicate": {
    ///      "description": "Is true if the transaction is a duplicate of an existing pending transaction.",
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct TransactionSubmitResponse {
        ///Is true if the transaction is a duplicate of an existing pending transaction.
        pub duplicate: bool,
    }
    impl From<&TransactionSubmitResponse> for TransactionSubmitResponse {
        fn from(value: &TransactionSubmitResponse) -> Self {
            value.clone()
        }
    }
    impl TransactionSubmitResponse {
        pub fn builder() -> builder::TransactionSubmitResponse {
            Default::default()
        }
    }
    ///TwoWayLinkedDappOnLedgerDetails
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "dapps": {
    ///      "$ref": "#/components/schemas/TwoWayLinkedDappsCollection"
    ///    },
    ///    "entities": {
    ///      "$ref": "#/components/schemas/TwoWayLinkedEntitiesCollection"
    ///    },
    ///    "primary_locker": {
    ///      "$ref": "#/components/schemas/Address"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct TwoWayLinkedDappOnLedgerDetails {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub dapps: Option<TwoWayLinkedDappsCollection>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub entities: Option<TwoWayLinkedEntitiesCollection>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub primary_locker: Option<Address>,
    }
    impl From<&TwoWayLinkedDappOnLedgerDetails> for TwoWayLinkedDappOnLedgerDetails {
        fn from(value: &TwoWayLinkedDappOnLedgerDetails) -> Self {
            value.clone()
        }
    }
    impl TwoWayLinkedDappOnLedgerDetails {
        pub fn builder() -> builder::TwoWayLinkedDappOnLedgerDetails {
            Default::default()
        }
    }
    ///A collection of two-way linked (resolved & verified) dApps linked to the entity defining this collection.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A collection of two-way linked (resolved & verified) dApps linked to the entity defining this collection.",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/TwoWayLinkedDappsCollectionItem"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct TwoWayLinkedDappsCollection {
        pub items: Vec<TwoWayLinkedDappsCollectionItem>,
    }
    impl From<&TwoWayLinkedDappsCollection> for TwoWayLinkedDappsCollection {
        fn from(value: &TwoWayLinkedDappsCollection) -> Self {
            value.clone()
        }
    }
    impl TwoWayLinkedDappsCollection {
        pub fn builder() -> builder::TwoWayLinkedDappsCollection {
            Default::default()
        }
    }
    ///TwoWayLinkedDappsCollectionItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "dapp_address"
    ///  ],
    ///  "properties": {
    ///    "dapp_address": {
    ///      "$ref": "#/components/schemas/Address"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct TwoWayLinkedDappsCollectionItem {
        pub dapp_address: Address,
    }
    impl From<&TwoWayLinkedDappsCollectionItem> for TwoWayLinkedDappsCollectionItem {
        fn from(value: &TwoWayLinkedDappsCollectionItem) -> Self {
            value.clone()
        }
    }
    impl TwoWayLinkedDappsCollectionItem {
        pub fn builder() -> builder::TwoWayLinkedDappsCollectionItem {
            Default::default()
        }
    }
    ///A collection of two-way linked (resolved & verified) entities linked to the entity defining this collection.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A collection of two-way linked (resolved & verified) entities linked to the entity defining this collection.",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/TwoWayLinkedEntitiesCollectionItem"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct TwoWayLinkedEntitiesCollection {
        pub items: Vec<TwoWayLinkedEntitiesCollectionItem>,
    }
    impl From<&TwoWayLinkedEntitiesCollection> for TwoWayLinkedEntitiesCollection {
        fn from(value: &TwoWayLinkedEntitiesCollection) -> Self {
            value.clone()
        }
    }
    impl TwoWayLinkedEntitiesCollection {
        pub fn builder() -> builder::TwoWayLinkedEntitiesCollection {
            Default::default()
        }
    }
    ///TwoWayLinkedEntitiesCollectionItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "entity_address"
    ///  ],
    ///  "properties": {
    ///    "entity_address": {
    ///      "$ref": "#/components/schemas/Address"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct TwoWayLinkedEntitiesCollectionItem {
        pub entity_address: Address,
    }
    impl From<&TwoWayLinkedEntitiesCollectionItem>
    for TwoWayLinkedEntitiesCollectionItem {
        fn from(value: &TwoWayLinkedEntitiesCollectionItem) -> Self {
            value.clone()
        }
    }
    impl TwoWayLinkedEntitiesCollectionItem {
        pub fn builder() -> builder::TwoWayLinkedEntitiesCollectionItem {
            Default::default()
        }
    }
    ///ValidationErrorsAtPath
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "errors",
    ///    "path"
    ///  ],
    ///  "properties": {
    ///    "errors": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      }
    ///    },
    ///    "path": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ValidationErrorsAtPath {
        pub errors: Vec<String>,
        pub path: String,
    }
    impl From<&ValidationErrorsAtPath> for ValidationErrorsAtPath {
        fn from(value: &ValidationErrorsAtPath) -> Self {
            value.clone()
        }
    }
    impl ValidationErrorsAtPath {
        pub fn builder() -> builder::ValidationErrorsAtPath {
            Default::default()
        }
    }
    ///ValidatorCollection
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ResultSetCursorMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "items"
    ///      ],
    ///      "properties": {
    ///        "items": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/ValidatorCollectionItem"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ValidatorCollection {
        pub items: Vec<ValidatorCollectionItem>,
        ///If specified, contains a cursor to query next page of the `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_cursor: Option<String>,
        ///Total number of items in underlying collection, fragment of which is available in `items` collection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_count: Option<i64>,
    }
    impl From<&ValidatorCollection> for ValidatorCollection {
        fn from(value: &ValidatorCollection) -> Self {
            value.clone()
        }
    }
    impl ValidatorCollection {
        pub fn builder() -> builder::ValidatorCollection {
            Default::default()
        }
    }
    ///ValidatorCollectionItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "address",
    ///    "effective_fee_factor",
    ///    "locked_owner_stake_unit_vault",
    ///    "metadata",
    ///    "pending_owner_stake_unit_unlock_vault",
    ///    "pending_xrd_withdraw_vault",
    ///    "stake_vault",
    ///    "state"
    ///  ],
    ///  "properties": {
    ///    "active_in_epoch": {
    ///      "$ref": "#/components/schemas/ValidatorCollectionItemActiveInEpoch"
    ///    },
    ///    "address": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "effective_fee_factor": {
    ///      "type": "object",
    ///      "required": [
    ///        "current"
    ///      ],
    ///      "properties": {
    ///        "current": {
    ///          "type": "object",
    ///          "required": [
    ///            "fee_factor"
    ///          ],
    ///          "properties": {
    ///            "fee_factor": {
    ///              "$ref": "#/components/schemas/BigDecimal"
    ///            }
    ///          }
    ///        },
    ///        "pending": {
    ///          "type": [
    ///            "object",
    ///            "null"
    ///          ],
    ///          "required": [
    ///            "effective_at_epoch",
    ///            "fee_factor"
    ///          ],
    ///          "properties": {
    ///            "effective_at_epoch": {
    ///              "type": "integer",
    ///              "format": "int64",
    ///              "maximum": 10000000000.0,
    ///              "minimum": 0.0
    ///            },
    ///            "fee_factor": {
    ///              "$ref": "#/components/schemas/BigDecimal"
    ///            }
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "locked_owner_stake_unit_vault": {
    ///      "$ref": "#/components/schemas/ValidatorVaultItem"
    ///    },
    ///    "metadata": {
    ///      "$ref": "#/components/schemas/EntityMetadataCollection"
    ///    },
    ///    "pending_owner_stake_unit_unlock_vault": {
    ///      "$ref": "#/components/schemas/ValidatorVaultItem"
    ///    },
    ///    "pending_xrd_withdraw_vault": {
    ///      "$ref": "#/components/schemas/ValidatorVaultItem"
    ///    },
    ///    "stake_vault": {
    ///      "$ref": "#/components/schemas/ValidatorVaultItem"
    ///    },
    ///    "state": {
    ///      "description": "Validator inner state representation.\nThis type is defined in the Core API as `ValidatorFieldStateValue`. See the Core API documentation for more details.\n",
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ValidatorCollectionItem {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub active_in_epoch: Option<ValidatorCollectionItemActiveInEpoch>,
        pub address: Address,
        pub effective_fee_factor: ValidatorCollectionItemEffectiveFeeFactor,
        pub locked_owner_stake_unit_vault: ValidatorVaultItem,
        pub metadata: EntityMetadataCollection,
        pub pending_owner_stake_unit_unlock_vault: ValidatorVaultItem,
        pub pending_xrd_withdraw_vault: ValidatorVaultItem,
        pub stake_vault: ValidatorVaultItem,
        /**Validator inner state representation.
This type is defined in the Core API as `ValidatorFieldStateValue`. See the Core API documentation for more details.
*/
        pub state: Option<::serde_json::Map<String, ::serde_json::Value>>,
    }
    impl From<&ValidatorCollectionItem> for ValidatorCollectionItem {
        fn from(value: &ValidatorCollectionItem) -> Self {
            value.clone()
        }
    }
    impl ValidatorCollectionItem {
        pub fn builder() -> builder::ValidatorCollectionItem {
            Default::default()
        }
    }
    ///ValidatorCollectionItemActiveInEpoch
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "key",
    ///    "stake",
    ///    "stake_percentage"
    ///  ],
    ///  "properties": {
    ///    "key": {
    ///      "$ref": "#/components/schemas/PublicKey"
    ///    },
    ///    "stake": {
    ///      "$ref": "#/components/schemas/BigDecimal"
    ///    },
    ///    "stake_percentage": {
    ///      "type": "number",
    ///      "format": "double"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ValidatorCollectionItemActiveInEpoch {
        pub key: PublicKey,
        pub stake: BigDecimal,
        pub stake_percentage: f64,
    }
    impl From<&ValidatorCollectionItemActiveInEpoch>
    for ValidatorCollectionItemActiveInEpoch {
        fn from(value: &ValidatorCollectionItemActiveInEpoch) -> Self {
            value.clone()
        }
    }
    impl ValidatorCollectionItemActiveInEpoch {
        pub fn builder() -> builder::ValidatorCollectionItemActiveInEpoch {
            Default::default()
        }
    }
    ///ValidatorCollectionItemEffectiveFeeFactor
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "current"
    ///  ],
    ///  "properties": {
    ///    "current": {
    ///      "type": "object",
    ///      "required": [
    ///        "fee_factor"
    ///      ],
    ///      "properties": {
    ///        "fee_factor": {
    ///          "$ref": "#/components/schemas/BigDecimal"
    ///        }
    ///      }
    ///    },
    ///    "pending": {
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "required": [
    ///        "effective_at_epoch",
    ///        "fee_factor"
    ///      ],
    ///      "properties": {
    ///        "effective_at_epoch": {
    ///          "type": "integer",
    ///          "format": "int64",
    ///          "maximum": 10000000000.0,
    ///          "minimum": 0.0
    ///        },
    ///        "fee_factor": {
    ///          "$ref": "#/components/schemas/BigDecimal"
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ValidatorCollectionItemEffectiveFeeFactor {
        pub current: ValidatorCollectionItemEffectiveFeeFactorCurrent,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pending: Option<ValidatorCollectionItemEffectiveFeeFactorPending>,
    }
    impl From<&ValidatorCollectionItemEffectiveFeeFactor>
    for ValidatorCollectionItemEffectiveFeeFactor {
        fn from(value: &ValidatorCollectionItemEffectiveFeeFactor) -> Self {
            value.clone()
        }
    }
    impl ValidatorCollectionItemEffectiveFeeFactor {
        pub fn builder() -> builder::ValidatorCollectionItemEffectiveFeeFactor {
            Default::default()
        }
    }
    ///ValidatorCollectionItemEffectiveFeeFactorCurrent
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "fee_factor"
    ///  ],
    ///  "properties": {
    ///    "fee_factor": {
    ///      "$ref": "#/components/schemas/BigDecimal"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ValidatorCollectionItemEffectiveFeeFactorCurrent {
        pub fee_factor: BigDecimal,
    }
    impl From<&ValidatorCollectionItemEffectiveFeeFactorCurrent>
    for ValidatorCollectionItemEffectiveFeeFactorCurrent {
        fn from(value: &ValidatorCollectionItemEffectiveFeeFactorCurrent) -> Self {
            value.clone()
        }
    }
    impl ValidatorCollectionItemEffectiveFeeFactorCurrent {
        pub fn builder() -> builder::ValidatorCollectionItemEffectiveFeeFactorCurrent {
            Default::default()
        }
    }
    ///ValidatorCollectionItemEffectiveFeeFactorPending
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "effective_at_epoch",
    ///    "fee_factor"
    ///  ],
    ///  "properties": {
    ///    "effective_at_epoch": {
    ///      "type": "integer",
    ///      "format": "int64",
    ///      "maximum": 10000000000.0,
    ///      "minimum": 0.0
    ///    },
    ///    "fee_factor": {
    ///      "$ref": "#/components/schemas/BigDecimal"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ValidatorCollectionItemEffectiveFeeFactorPending {
        pub effective_at_epoch: i64,
        pub fee_factor: BigDecimal,
    }
    impl From<&ValidatorCollectionItemEffectiveFeeFactorPending>
    for ValidatorCollectionItemEffectiveFeeFactorPending {
        fn from(value: &ValidatorCollectionItemEffectiveFeeFactorPending) -> Self {
            value.clone()
        }
    }
    impl ValidatorCollectionItemEffectiveFeeFactorPending {
        pub fn builder() -> builder::ValidatorCollectionItemEffectiveFeeFactorPending {
            Default::default()
        }
    }
    ///ValidatorUptimeCollection
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ValidatorUptimeCollectionItem"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ValidatorUptimeCollection {
        pub items: Vec<ValidatorUptimeCollectionItem>,
    }
    impl From<&ValidatorUptimeCollection> for ValidatorUptimeCollection {
        fn from(value: &ValidatorUptimeCollection) -> Self {
            value.clone()
        }
    }
    impl ValidatorUptimeCollection {
        pub fn builder() -> builder::ValidatorUptimeCollection {
            Default::default()
        }
    }
    ///ValidatorUptimeCollectionItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "address",
    ///    "epochs_active_in"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "epochs_active_in": {
    ///      "description": "number of epochs validator was active in.",
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "proposals_made": {
    ///      "description": "number of proposals made.",
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ],
    ///      "format": "int64"
    ///    },
    ///    "proposals_missed": {
    ///      "description": "number of proposals missed.",
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ],
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ValidatorUptimeCollectionItem {
        pub address: Address,
        ///number of epochs validator was active in.
        pub epochs_active_in: i64,
        ///number of proposals made.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub proposals_made: Option<i64>,
        ///number of proposals missed.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub proposals_missed: Option<i64>,
    }
    impl From<&ValidatorUptimeCollectionItem> for ValidatorUptimeCollectionItem {
        fn from(value: &ValidatorUptimeCollectionItem) -> Self {
            value.clone()
        }
    }
    impl ValidatorUptimeCollectionItem {
        pub fn builder() -> builder::ValidatorUptimeCollectionItem {
            Default::default()
        }
    }
    ///ValidatorVaultItem
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "address",
    ///    "balance",
    ///    "last_changed_at_state_version"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "$ref": "#/components/schemas/Address"
    ///    },
    ///    "balance": {
    ///      "$ref": "#/components/schemas/BigDecimal"
    ///    },
    ///    "last_changed_at_state_version": {
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ValidatorVaultItem {
        pub address: Address,
        pub balance: BigDecimal,
        pub last_changed_at_state_version: i64,
    }
    impl From<&ValidatorVaultItem> for ValidatorVaultItem {
        fn from(value: &ValidatorVaultItem) -> Self {
            value.clone()
        }
    }
    impl ValidatorVaultItem {
        pub fn builder() -> builder::ValidatorVaultItem {
            Default::default()
        }
    }
    /**For `at_ledger_state` and `from_ledger_state` you can use one of `state_version`, `epoch`, `epoch` and `round`, or `timestamp`, but then ongoing epoch will be selected and used for querying data.
i.e for request with `{ "from_state_version" = { "state_version" = 100 }, "at_state_version" = { "state_version" = 300} }` gateway api will check in which epoch transactions with state version 100 and 300 were and then use that as inclusive boundary for request.
*/
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "For `at_ledger_state` and `from_ledger_state` you can use one of `state_version`, `epoch`, `epoch` and `round`, or `timestamp`, but then ongoing epoch will be selected and used for querying data.\ni.e for request with `{ \"from_state_version\" = { \"state_version\" = 100 }, \"at_state_version\" = { \"state_version\" = 300} }` gateway api will check in which epoch transactions with state version 100 and 300 were and then use that as inclusive boundary for request.\n",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/AtLedgerStateMixin"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/FromLedgerStateMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "properties": {
    ///        "validator_addresses": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/Address"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ValidatorsUptimeRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub at_ledger_state: Option<LedgerStateSelector>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub from_ledger_state: Option<LedgerStateSelector>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub validator_addresses: Vec<Address>,
    }
    impl From<&ValidatorsUptimeRequest> for ValidatorsUptimeRequest {
        fn from(value: &ValidatorsUptimeRequest) -> Self {
            value.clone()
        }
    }
    impl ValidatorsUptimeRequest {
        pub fn builder() -> builder::ValidatorsUptimeRequest {
            Default::default()
        }
    }
    ///ValidatorsUptimeResponse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/LedgerStateMixin"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "validators"
    ///      ],
    ///      "properties": {
    ///        "validators": {
    ///          "$ref": "#/components/schemas/ValidatorUptimeCollection"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ValidatorsUptimeResponse {
        pub ledger_state: LedgerState,
        pub validators: ValidatorUptimeCollection,
    }
    impl From<&ValidatorsUptimeResponse> for ValidatorsUptimeResponse {
        fn from(value: &ValidatorsUptimeResponse) -> Self {
            value.clone()
        }
    }
    impl ValidatorsUptimeResponse {
        pub fn builder() -> builder::ValidatorsUptimeResponse {
            Default::default()
        }
    }
    /// Types for composing complex structures.
    pub mod builder {
        #[derive(Clone, Debug)]
        pub struct AccountAuthorizedDepositorsCollection {
            items: Result<Vec<super::AccountAuthorizedDepositorsResponseItem>, String>,
            next_cursor: Result<Option<String>, String>,
            total_count: Result<Option<i64>, String>,
        }
        impl Default for AccountAuthorizedDepositorsCollection {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_cursor: Ok(Default::default()),
                    total_count: Ok(Default::default()),
                }
            }
        }
        impl AccountAuthorizedDepositorsCollection {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    Vec<super::AccountAuthorizedDepositorsResponseItem>,
                >,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {}", e)
                    });
                self
            }
            pub fn next_cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for next_cursor: {}", e)
                    });
                self
            }
            pub fn total_count<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.total_count = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for total_count: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<AccountAuthorizedDepositorsCollection>
        for super::AccountAuthorizedDepositorsCollection {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AccountAuthorizedDepositorsCollection,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_cursor: value.next_cursor?,
                    total_count: value.total_count?,
                })
            }
        }
        impl From<super::AccountAuthorizedDepositorsCollection>
        for AccountAuthorizedDepositorsCollection {
            fn from(value: super::AccountAuthorizedDepositorsCollection) -> Self {
                Self {
                    items: Ok(value.items),
                    next_cursor: Ok(value.next_cursor),
                    total_count: Ok(value.total_count),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AccountAuthorizedDepositorsNonFungibleBadge {
            badge_type: Result<
                super::AccountAuthorizedDepositorsNonFungibleBadgeBadgeType,
                String,
            >,
            last_updated_at_state_version: Result<
                super::LastUpdatedAtStateVersion,
                String,
            >,
            non_fungible_id: Result<super::NonFungibleId, String>,
            resource_address: Result<super::Address, String>,
        }
        impl Default for AccountAuthorizedDepositorsNonFungibleBadge {
            fn default() -> Self {
                Self {
                    badge_type: Err("no value supplied for badge_type".to_string()),
                    last_updated_at_state_version: Err(
                        "no value supplied for last_updated_at_state_version".to_string(),
                    ),
                    non_fungible_id: Err(
                        "no value supplied for non_fungible_id".to_string(),
                    ),
                    resource_address: Err(
                        "no value supplied for resource_address".to_string(),
                    ),
                }
            }
        }
        impl AccountAuthorizedDepositorsNonFungibleBadge {
            pub fn badge_type<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::AccountAuthorizedDepositorsNonFungibleBadgeBadgeType,
                >,
                T::Error: std::fmt::Display,
            {
                self.badge_type = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for badge_type: {}", e)
                    });
                self
            }
            pub fn last_updated_at_state_version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::LastUpdatedAtStateVersion>,
                T::Error: std::fmt::Display,
            {
                self.last_updated_at_state_version = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for last_updated_at_state_version: {}",
                            e
                        )
                    });
                self
            }
            pub fn non_fungible_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::NonFungibleId>,
                T::Error: std::fmt::Display,
            {
                self.non_fungible_id = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for non_fungible_id: {}", e
                        )
                    });
                self
            }
            pub fn resource_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.resource_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_address: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<AccountAuthorizedDepositorsNonFungibleBadge>
        for super::AccountAuthorizedDepositorsNonFungibleBadge {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AccountAuthorizedDepositorsNonFungibleBadge,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    badge_type: value.badge_type?,
                    last_updated_at_state_version: value.last_updated_at_state_version?,
                    non_fungible_id: value.non_fungible_id?,
                    resource_address: value.resource_address?,
                })
            }
        }
        impl From<super::AccountAuthorizedDepositorsNonFungibleBadge>
        for AccountAuthorizedDepositorsNonFungibleBadge {
            fn from(value: super::AccountAuthorizedDepositorsNonFungibleBadge) -> Self {
                Self {
                    badge_type: Ok(value.badge_type),
                    last_updated_at_state_version: Ok(
                        value.last_updated_at_state_version,
                    ),
                    non_fungible_id: Ok(value.non_fungible_id),
                    resource_address: Ok(value.resource_address),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AccountAuthorizedDepositorsResourceBadge {
            badge_type: Result<
                super::AccountAuthorizedDepositorsResourceBadgeBadgeType,
                String,
            >,
            last_updated_at_state_version: Result<
                super::LastUpdatedAtStateVersion,
                String,
            >,
            resource_address: Result<super::Address, String>,
        }
        impl Default for AccountAuthorizedDepositorsResourceBadge {
            fn default() -> Self {
                Self {
                    badge_type: Err("no value supplied for badge_type".to_string()),
                    last_updated_at_state_version: Err(
                        "no value supplied for last_updated_at_state_version".to_string(),
                    ),
                    resource_address: Err(
                        "no value supplied for resource_address".to_string(),
                    ),
                }
            }
        }
        impl AccountAuthorizedDepositorsResourceBadge {
            pub fn badge_type<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::AccountAuthorizedDepositorsResourceBadgeBadgeType,
                >,
                T::Error: std::fmt::Display,
            {
                self.badge_type = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for badge_type: {}", e)
                    });
                self
            }
            pub fn last_updated_at_state_version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::LastUpdatedAtStateVersion>,
                T::Error: std::fmt::Display,
            {
                self.last_updated_at_state_version = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for last_updated_at_state_version: {}",
                            e
                        )
                    });
                self
            }
            pub fn resource_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.resource_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_address: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<AccountAuthorizedDepositorsResourceBadge>
        for super::AccountAuthorizedDepositorsResourceBadge {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AccountAuthorizedDepositorsResourceBadge,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    badge_type: value.badge_type?,
                    last_updated_at_state_version: value.last_updated_at_state_version?,
                    resource_address: value.resource_address?,
                })
            }
        }
        impl From<super::AccountAuthorizedDepositorsResourceBadge>
        for AccountAuthorizedDepositorsResourceBadge {
            fn from(value: super::AccountAuthorizedDepositorsResourceBadge) -> Self {
                Self {
                    badge_type: Ok(value.badge_type),
                    last_updated_at_state_version: Ok(
                        value.last_updated_at_state_version,
                    ),
                    resource_address: Ok(value.resource_address),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AccountAuthorizedDepositorsResponseItemBase {
            badge_type: Result<super::AccountAuthorizedDepositorBadgeType, String>,
        }
        impl Default for AccountAuthorizedDepositorsResponseItemBase {
            fn default() -> Self {
                Self {
                    badge_type: Err("no value supplied for badge_type".to_string()),
                }
            }
        }
        impl AccountAuthorizedDepositorsResponseItemBase {
            pub fn badge_type<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::AccountAuthorizedDepositorBadgeType>,
                T::Error: std::fmt::Display,
            {
                self.badge_type = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for badge_type: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<AccountAuthorizedDepositorsResponseItemBase>
        for super::AccountAuthorizedDepositorsResponseItemBase {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AccountAuthorizedDepositorsResponseItemBase,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    badge_type: value.badge_type?,
                })
            }
        }
        impl From<super::AccountAuthorizedDepositorsResponseItemBase>
        for AccountAuthorizedDepositorsResponseItemBase {
            fn from(value: super::AccountAuthorizedDepositorsResponseItemBase) -> Self {
                Self {
                    badge_type: Ok(value.badge_type),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AccountDepositPreValidationDecidingFactors {
            default_deposit_rule: Result<super::AccountDefaultDepositRule, String>,
            is_badge_authorized_depositor: Result<Option<bool>, String>,
            resource_specific_details: Result<
                Vec<
                    super::AccountDepositPreValidationDecidingFactorsResourceSpecificDetailsItem,
                >,
                String,
            >,
        }
        impl Default for AccountDepositPreValidationDecidingFactors {
            fn default() -> Self {
                Self {
                    default_deposit_rule: Err(
                        "no value supplied for default_deposit_rule".to_string(),
                    ),
                    is_badge_authorized_depositor: Ok(Default::default()),
                    resource_specific_details: Ok(Default::default()),
                }
            }
        }
        impl AccountDepositPreValidationDecidingFactors {
            pub fn default_deposit_rule<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::AccountDefaultDepositRule>,
                T::Error: std::fmt::Display,
            {
                self.default_deposit_rule = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for default_deposit_rule: {}",
                            e
                        )
                    });
                self
            }
            pub fn is_badge_authorized_depositor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<bool>>,
                T::Error: std::fmt::Display,
            {
                self.is_badge_authorized_depositor = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for is_badge_authorized_depositor: {}",
                            e
                        )
                    });
                self
            }
            pub fn resource_specific_details<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    Vec<
                        super::AccountDepositPreValidationDecidingFactorsResourceSpecificDetailsItem,
                    >,
                >,
                T::Error: std::fmt::Display,
            {
                self.resource_specific_details = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_specific_details: {}",
                            e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<AccountDepositPreValidationDecidingFactors>
        for super::AccountDepositPreValidationDecidingFactors {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AccountDepositPreValidationDecidingFactors,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    default_deposit_rule: value.default_deposit_rule?,
                    is_badge_authorized_depositor: value.is_badge_authorized_depositor?,
                    resource_specific_details: value.resource_specific_details?,
                })
            }
        }
        impl From<super::AccountDepositPreValidationDecidingFactors>
        for AccountDepositPreValidationDecidingFactors {
            fn from(value: super::AccountDepositPreValidationDecidingFactors) -> Self {
                Self {
                    default_deposit_rule: Ok(value.default_deposit_rule),
                    is_badge_authorized_depositor: Ok(
                        value.is_badge_authorized_depositor,
                    ),
                    resource_specific_details: Ok(value.resource_specific_details),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AccountDepositPreValidationDecidingFactorsResourceSpecificDetailsItem {
            is_xrd: Result<bool, String>,
            resource_address: Result<super::Address, String>,
            resource_preference_rule: Result<
                Option<super::AccountResourcePreferenceRule>,
                String,
            >,
            vault_exists: Result<bool, String>,
        }
        impl Default
        for AccountDepositPreValidationDecidingFactorsResourceSpecificDetailsItem {
            fn default() -> Self {
                Self {
                    is_xrd: Err("no value supplied for is_xrd".to_string()),
                    resource_address: Err(
                        "no value supplied for resource_address".to_string(),
                    ),
                    resource_preference_rule: Ok(Default::default()),
                    vault_exists: Err("no value supplied for vault_exists".to_string()),
                }
            }
        }
        impl AccountDepositPreValidationDecidingFactorsResourceSpecificDetailsItem {
            pub fn is_xrd<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.is_xrd = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for is_xrd: {}", e)
                    });
                self
            }
            pub fn resource_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.resource_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_address: {}", e
                        )
                    });
                self
            }
            pub fn resource_preference_rule<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::AccountResourcePreferenceRule>>,
                T::Error: std::fmt::Display,
            {
                self.resource_preference_rule = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_preference_rule: {}",
                            e
                        )
                    });
                self
            }
            pub fn vault_exists<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.vault_exists = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for vault_exists: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<
            AccountDepositPreValidationDecidingFactorsResourceSpecificDetailsItem,
        >
        for super::AccountDepositPreValidationDecidingFactorsResourceSpecificDetailsItem {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AccountDepositPreValidationDecidingFactorsResourceSpecificDetailsItem,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    is_xrd: value.is_xrd?,
                    resource_address: value.resource_address?,
                    resource_preference_rule: value.resource_preference_rule?,
                    vault_exists: value.vault_exists?,
                })
            }
        }
        impl From<
            super::AccountDepositPreValidationDecidingFactorsResourceSpecificDetailsItem,
        > for AccountDepositPreValidationDecidingFactorsResourceSpecificDetailsItem {
            fn from(
                value: super::AccountDepositPreValidationDecidingFactorsResourceSpecificDetailsItem,
            ) -> Self {
                Self {
                    is_xrd: Ok(value.is_xrd),
                    resource_address: Ok(value.resource_address),
                    resource_preference_rule: Ok(value.resource_preference_rule),
                    vault_exists: Ok(value.vault_exists),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AccountDepositPreValidationNonFungibleBadge {
            badge_type: Result<
                super::AccountDepositPreValidationNonFungibleBadgeBadgeType,
                String,
            >,
            non_fungible_id: Result<super::NonFungibleId, String>,
            resource_address: Result<super::Address, String>,
        }
        impl Default for AccountDepositPreValidationNonFungibleBadge {
            fn default() -> Self {
                Self {
                    badge_type: Err("no value supplied for badge_type".to_string()),
                    non_fungible_id: Err(
                        "no value supplied for non_fungible_id".to_string(),
                    ),
                    resource_address: Err(
                        "no value supplied for resource_address".to_string(),
                    ),
                }
            }
        }
        impl AccountDepositPreValidationNonFungibleBadge {
            pub fn badge_type<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::AccountDepositPreValidationNonFungibleBadgeBadgeType,
                >,
                T::Error: std::fmt::Display,
            {
                self.badge_type = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for badge_type: {}", e)
                    });
                self
            }
            pub fn non_fungible_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::NonFungibleId>,
                T::Error: std::fmt::Display,
            {
                self.non_fungible_id = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for non_fungible_id: {}", e
                        )
                    });
                self
            }
            pub fn resource_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.resource_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_address: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<AccountDepositPreValidationNonFungibleBadge>
        for super::AccountDepositPreValidationNonFungibleBadge {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AccountDepositPreValidationNonFungibleBadge,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    badge_type: value.badge_type?,
                    non_fungible_id: value.non_fungible_id?,
                    resource_address: value.resource_address?,
                })
            }
        }
        impl From<super::AccountDepositPreValidationNonFungibleBadge>
        for AccountDepositPreValidationNonFungibleBadge {
            fn from(value: super::AccountDepositPreValidationNonFungibleBadge) -> Self {
                Self {
                    badge_type: Ok(value.badge_type),
                    non_fungible_id: Ok(value.non_fungible_id),
                    resource_address: Ok(value.resource_address),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AccountDepositPreValidationRequest {
            account_address: Result<super::Address, String>,
            badge: Result<
                Option<
                    super::TransactionAccountDepositPreValidationAuthorizedDepositorBadge,
                >,
                String,
            >,
            resource_addresses: Result<Vec<super::Address>, String>,
        }
        impl Default for AccountDepositPreValidationRequest {
            fn default() -> Self {
                Self {
                    account_address: Err(
                        "no value supplied for account_address".to_string(),
                    ),
                    badge: Ok(Default::default()),
                    resource_addresses: Err(
                        "no value supplied for resource_addresses".to_string(),
                    ),
                }
            }
        }
        impl AccountDepositPreValidationRequest {
            pub fn account_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.account_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for account_address: {}", e
                        )
                    });
                self
            }
            pub fn badge<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    Option<
                        super::TransactionAccountDepositPreValidationAuthorizedDepositorBadge,
                    >,
                >,
                T::Error: std::fmt::Display,
            {
                self.badge = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for badge: {}", e)
                    });
                self
            }
            pub fn resource_addresses<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Address>>,
                T::Error: std::fmt::Display,
            {
                self.resource_addresses = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_addresses: {}",
                            e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<AccountDepositPreValidationRequest>
        for super::AccountDepositPreValidationRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AccountDepositPreValidationRequest,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    account_address: value.account_address?,
                    badge: value.badge?,
                    resource_addresses: value.resource_addresses?,
                })
            }
        }
        impl From<super::AccountDepositPreValidationRequest>
        for AccountDepositPreValidationRequest {
            fn from(value: super::AccountDepositPreValidationRequest) -> Self {
                Self {
                    account_address: Ok(value.account_address),
                    badge: Ok(value.badge),
                    resource_addresses: Ok(value.resource_addresses),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AccountDepositPreValidationResourceBadge {
            badge_type: Result<
                super::AccountDepositPreValidationResourceBadgeBadgeType,
                String,
            >,
            resource_address: Result<super::Address, String>,
        }
        impl Default for AccountDepositPreValidationResourceBadge {
            fn default() -> Self {
                Self {
                    badge_type: Err("no value supplied for badge_type".to_string()),
                    resource_address: Err(
                        "no value supplied for resource_address".to_string(),
                    ),
                }
            }
        }
        impl AccountDepositPreValidationResourceBadge {
            pub fn badge_type<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::AccountDepositPreValidationResourceBadgeBadgeType,
                >,
                T::Error: std::fmt::Display,
            {
                self.badge_type = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for badge_type: {}", e)
                    });
                self
            }
            pub fn resource_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.resource_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_address: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<AccountDepositPreValidationResourceBadge>
        for super::AccountDepositPreValidationResourceBadge {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AccountDepositPreValidationResourceBadge,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    badge_type: value.badge_type?,
                    resource_address: value.resource_address?,
                })
            }
        }
        impl From<super::AccountDepositPreValidationResourceBadge>
        for AccountDepositPreValidationResourceBadge {
            fn from(value: super::AccountDepositPreValidationResourceBadge) -> Self {
                Self {
                    badge_type: Ok(value.badge_type),
                    resource_address: Ok(value.resource_address),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AccountDepositPreValidationResourceSpecificBehaviourItem {
            allows_try_deposit: Result<bool, String>,
            resource_address: Result<super::Address, String>,
        }
        impl Default for AccountDepositPreValidationResourceSpecificBehaviourItem {
            fn default() -> Self {
                Self {
                    allows_try_deposit: Err(
                        "no value supplied for allows_try_deposit".to_string(),
                    ),
                    resource_address: Err(
                        "no value supplied for resource_address".to_string(),
                    ),
                }
            }
        }
        impl AccountDepositPreValidationResourceSpecificBehaviourItem {
            pub fn allows_try_deposit<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.allows_try_deposit = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for allows_try_deposit: {}",
                            e
                        )
                    });
                self
            }
            pub fn resource_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.resource_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_address: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<
            AccountDepositPreValidationResourceSpecificBehaviourItem,
        > for super::AccountDepositPreValidationResourceSpecificBehaviourItem {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AccountDepositPreValidationResourceSpecificBehaviourItem,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    allows_try_deposit: value.allows_try_deposit?,
                    resource_address: value.resource_address?,
                })
            }
        }
        impl From<super::AccountDepositPreValidationResourceSpecificBehaviourItem>
        for AccountDepositPreValidationResourceSpecificBehaviourItem {
            fn from(
                value: super::AccountDepositPreValidationResourceSpecificBehaviourItem,
            ) -> Self {
                Self {
                    allows_try_deposit: Ok(value.allows_try_deposit),
                    resource_address: Ok(value.resource_address),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AccountDepositPreValidationResponse {
            allows_try_deposit_batch: Result<bool, String>,
            deciding_factors: Result<
                super::AccountDepositPreValidationDecidingFactors,
                String,
            >,
            ledger_state: Result<super::LedgerState, String>,
            resource_specific: Result<::serde_json::Value, String>,
            resource_specific_behaviour: Result<
                Vec<super::AccountDepositPreValidationResourceSpecificBehaviourItem>,
                String,
            >,
        }
        impl Default for AccountDepositPreValidationResponse {
            fn default() -> Self {
                Self {
                    allows_try_deposit_batch: Err(
                        "no value supplied for allows_try_deposit_batch".to_string(),
                    ),
                    deciding_factors: Err(
                        "no value supplied for deciding_factors".to_string(),
                    ),
                    ledger_state: Err("no value supplied for ledger_state".to_string()),
                    resource_specific: Err(
                        "no value supplied for resource_specific".to_string(),
                    ),
                    resource_specific_behaviour: Ok(Default::default()),
                }
            }
        }
        impl AccountDepositPreValidationResponse {
            pub fn allows_try_deposit_batch<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.allows_try_deposit_batch = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for allows_try_deposit_batch: {}",
                            e
                        )
                    });
                self
            }
            pub fn deciding_factors<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::AccountDepositPreValidationDecidingFactors,
                >,
                T::Error: std::fmt::Display,
            {
                self.deciding_factors = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for deciding_factors: {}", e
                        )
                    });
                self
            }
            pub fn ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::LedgerState>,
                T::Error: std::fmt::Display,
            {
                self.ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn resource_specific<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<::serde_json::Value>,
                T::Error: std::fmt::Display,
            {
                self.resource_specific = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_specific: {}",
                            e
                        )
                    });
                self
            }
            pub fn resource_specific_behaviour<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    Vec<super::AccountDepositPreValidationResourceSpecificBehaviourItem>,
                >,
                T::Error: std::fmt::Display,
            {
                self.resource_specific_behaviour = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_specific_behaviour: {}",
                            e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<AccountDepositPreValidationResponse>
        for super::AccountDepositPreValidationResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AccountDepositPreValidationResponse,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    allows_try_deposit_batch: value.allows_try_deposit_batch?,
                    deciding_factors: value.deciding_factors?,
                    ledger_state: value.ledger_state?,
                    resource_specific: value.resource_specific?,
                    resource_specific_behaviour: value.resource_specific_behaviour?,
                })
            }
        }
        impl From<super::AccountDepositPreValidationResponse>
        for AccountDepositPreValidationResponse {
            fn from(value: super::AccountDepositPreValidationResponse) -> Self {
                Self {
                    allows_try_deposit_batch: Ok(value.allows_try_deposit_batch),
                    deciding_factors: Ok(value.deciding_factors),
                    ledger_state: Ok(value.ledger_state),
                    resource_specific: Ok(value.resource_specific),
                    resource_specific_behaviour: Ok(value.resource_specific_behaviour),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AccountLockerAddress {
            account_address: Result<super::Address, String>,
            locker_address: Result<super::Address, String>,
        }
        impl Default for AccountLockerAddress {
            fn default() -> Self {
                Self {
                    account_address: Err(
                        "no value supplied for account_address".to_string(),
                    ),
                    locker_address: Err(
                        "no value supplied for locker_address".to_string(),
                    ),
                }
            }
        }
        impl AccountLockerAddress {
            pub fn account_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.account_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for account_address: {}", e
                        )
                    });
                self
            }
            pub fn locker_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.locker_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for locker_address: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<AccountLockerAddress>
        for super::AccountLockerAddress {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AccountLockerAddress,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    account_address: value.account_address?,
                    locker_address: value.locker_address?,
                })
            }
        }
        impl From<super::AccountLockerAddress> for AccountLockerAddress {
            fn from(value: super::AccountLockerAddress) -> Self {
                Self {
                    account_address: Ok(value.account_address),
                    locker_address: Ok(value.locker_address),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AccountLockerNotFoundError {
            account_address: Result<super::Address, String>,
            locker_address: Result<super::Address, String>,
            type_: Result<super::AccountLockerNotFoundErrorType, String>,
        }
        impl Default for AccountLockerNotFoundError {
            fn default() -> Self {
                Self {
                    account_address: Err(
                        "no value supplied for account_address".to_string(),
                    ),
                    locker_address: Err(
                        "no value supplied for locker_address".to_string(),
                    ),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl AccountLockerNotFoundError {
            pub fn account_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.account_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for account_address: {}", e
                        )
                    });
                self
            }
            pub fn locker_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.locker_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for locker_address: {}", e
                        )
                    });
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::AccountLockerNotFoundErrorType>,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<AccountLockerNotFoundError>
        for super::AccountLockerNotFoundError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AccountLockerNotFoundError,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    account_address: value.account_address?,
                    locker_address: value.locker_address?,
                    type_: value.type_?,
                })
            }
        }
        impl From<super::AccountLockerNotFoundError> for AccountLockerNotFoundError {
            fn from(value: super::AccountLockerNotFoundError) -> Self {
                Self {
                    account_address: Ok(value.account_address),
                    locker_address: Ok(value.locker_address),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AccountLockerVaultCollection {
            items: Result<Vec<super::AccountLockerVaultCollectionItem>, String>,
            next_cursor: Result<Option<String>, String>,
            total_count: Result<Option<i64>, String>,
        }
        impl Default for AccountLockerVaultCollection {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_cursor: Ok(Default::default()),
                    total_count: Ok(Default::default()),
                }
            }
        }
        impl AccountLockerVaultCollection {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::AccountLockerVaultCollectionItem>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {}", e)
                    });
                self
            }
            pub fn next_cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for next_cursor: {}", e)
                    });
                self
            }
            pub fn total_count<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.total_count = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for total_count: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<AccountLockerVaultCollection>
        for super::AccountLockerVaultCollection {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AccountLockerVaultCollection,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_cursor: value.next_cursor?,
                    total_count: value.total_count?,
                })
            }
        }
        impl From<super::AccountLockerVaultCollection> for AccountLockerVaultCollection {
            fn from(value: super::AccountLockerVaultCollection) -> Self {
                Self {
                    items: Ok(value.items),
                    next_cursor: Ok(value.next_cursor),
                    total_count: Ok(value.total_count),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AccountLockerVaultCollectionItemBase {
            last_updated_at_state_version: Result<
                super::LastUpdatedAtStateVersion,
                String,
            >,
            resource_address: Result<super::Address, String>,
            type_: Result<super::AccountLockerVaultCollectionItemType, String>,
            vault_address: Result<super::Address, String>,
        }
        impl Default for AccountLockerVaultCollectionItemBase {
            fn default() -> Self {
                Self {
                    last_updated_at_state_version: Err(
                        "no value supplied for last_updated_at_state_version".to_string(),
                    ),
                    resource_address: Err(
                        "no value supplied for resource_address".to_string(),
                    ),
                    type_: Err("no value supplied for type_".to_string()),
                    vault_address: Err("no value supplied for vault_address".to_string()),
                }
            }
        }
        impl AccountLockerVaultCollectionItemBase {
            pub fn last_updated_at_state_version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::LastUpdatedAtStateVersion>,
                T::Error: std::fmt::Display,
            {
                self.last_updated_at_state_version = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for last_updated_at_state_version: {}",
                            e
                        )
                    });
                self
            }
            pub fn resource_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.resource_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_address: {}", e
                        )
                    });
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::AccountLockerVaultCollectionItemType>,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
            pub fn vault_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.vault_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for vault_address: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<AccountLockerVaultCollectionItemBase>
        for super::AccountLockerVaultCollectionItemBase {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AccountLockerVaultCollectionItemBase,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    last_updated_at_state_version: value.last_updated_at_state_version?,
                    resource_address: value.resource_address?,
                    type_: value.type_?,
                    vault_address: value.vault_address?,
                })
            }
        }
        impl From<super::AccountLockerVaultCollectionItemBase>
        for AccountLockerVaultCollectionItemBase {
            fn from(value: super::AccountLockerVaultCollectionItemBase) -> Self {
                Self {
                    last_updated_at_state_version: Ok(
                        value.last_updated_at_state_version,
                    ),
                    resource_address: Ok(value.resource_address),
                    type_: Ok(value.type_),
                    vault_address: Ok(value.vault_address),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AccountLockerVaultCollectionItemFungible {
            amount: Result<super::BigDecimal, String>,
            last_updated_at_state_version: Result<
                super::LastUpdatedAtStateVersion,
                String,
            >,
            resource_address: Result<super::Address, String>,
            type_: Result<super::AccountLockerVaultCollectionItemFungibleType, String>,
            vault_address: Result<super::Address, String>,
        }
        impl Default for AccountLockerVaultCollectionItemFungible {
            fn default() -> Self {
                Self {
                    amount: Err("no value supplied for amount".to_string()),
                    last_updated_at_state_version: Err(
                        "no value supplied for last_updated_at_state_version".to_string(),
                    ),
                    resource_address: Err(
                        "no value supplied for resource_address".to_string(),
                    ),
                    type_: Err("no value supplied for type_".to_string()),
                    vault_address: Err("no value supplied for vault_address".to_string()),
                }
            }
        }
        impl AccountLockerVaultCollectionItemFungible {
            pub fn amount<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::BigDecimal>,
                T::Error: std::fmt::Display,
            {
                self.amount = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for amount: {}", e)
                    });
                self
            }
            pub fn last_updated_at_state_version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::LastUpdatedAtStateVersion>,
                T::Error: std::fmt::Display,
            {
                self.last_updated_at_state_version = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for last_updated_at_state_version: {}",
                            e
                        )
                    });
                self
            }
            pub fn resource_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.resource_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_address: {}", e
                        )
                    });
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::AccountLockerVaultCollectionItemFungibleType,
                >,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
            pub fn vault_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.vault_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for vault_address: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<AccountLockerVaultCollectionItemFungible>
        for super::AccountLockerVaultCollectionItemFungible {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AccountLockerVaultCollectionItemFungible,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    amount: value.amount?,
                    last_updated_at_state_version: value.last_updated_at_state_version?,
                    resource_address: value.resource_address?,
                    type_: value.type_?,
                    vault_address: value.vault_address?,
                })
            }
        }
        impl From<super::AccountLockerVaultCollectionItemFungible>
        for AccountLockerVaultCollectionItemFungible {
            fn from(value: super::AccountLockerVaultCollectionItemFungible) -> Self {
                Self {
                    amount: Ok(value.amount),
                    last_updated_at_state_version: Ok(
                        value.last_updated_at_state_version,
                    ),
                    resource_address: Ok(value.resource_address),
                    type_: Ok(value.type_),
                    vault_address: Ok(value.vault_address),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AccountLockerVaultCollectionItemNonFungible {
            last_updated_at_state_version: Result<
                super::LastUpdatedAtStateVersion,
                String,
            >,
            resource_address: Result<super::Address, String>,
            total_count: Result<i64, String>,
            type_: Result<
                super::AccountLockerVaultCollectionItemNonFungibleType,
                String,
            >,
            vault_address: Result<super::Address, String>,
        }
        impl Default for AccountLockerVaultCollectionItemNonFungible {
            fn default() -> Self {
                Self {
                    last_updated_at_state_version: Err(
                        "no value supplied for last_updated_at_state_version".to_string(),
                    ),
                    resource_address: Err(
                        "no value supplied for resource_address".to_string(),
                    ),
                    total_count: Err("no value supplied for total_count".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                    vault_address: Err("no value supplied for vault_address".to_string()),
                }
            }
        }
        impl AccountLockerVaultCollectionItemNonFungible {
            pub fn last_updated_at_state_version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::LastUpdatedAtStateVersion>,
                T::Error: std::fmt::Display,
            {
                self.last_updated_at_state_version = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for last_updated_at_state_version: {}",
                            e
                        )
                    });
                self
            }
            pub fn resource_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.resource_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_address: {}", e
                        )
                    });
                self
            }
            pub fn total_count<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<i64>,
                T::Error: std::fmt::Display,
            {
                self.total_count = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for total_count: {}", e)
                    });
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::AccountLockerVaultCollectionItemNonFungibleType,
                >,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
            pub fn vault_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.vault_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for vault_address: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<AccountLockerVaultCollectionItemNonFungible>
        for super::AccountLockerVaultCollectionItemNonFungible {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AccountLockerVaultCollectionItemNonFungible,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    last_updated_at_state_version: value.last_updated_at_state_version?,
                    resource_address: value.resource_address?,
                    total_count: value.total_count?,
                    type_: value.type_?,
                    vault_address: value.vault_address?,
                })
            }
        }
        impl From<super::AccountLockerVaultCollectionItemNonFungible>
        for AccountLockerVaultCollectionItemNonFungible {
            fn from(value: super::AccountLockerVaultCollectionItemNonFungible) -> Self {
                Self {
                    last_updated_at_state_version: Ok(
                        value.last_updated_at_state_version,
                    ),
                    resource_address: Ok(value.resource_address),
                    total_count: Ok(value.total_count),
                    type_: Ok(value.type_),
                    vault_address: Ok(value.vault_address),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AccountResourcePreferencesCollection {
            items: Result<Vec<super::AccountResourcePreferencesResponseItem>, String>,
            next_cursor: Result<Option<String>, String>,
            total_count: Result<Option<i64>, String>,
        }
        impl Default for AccountResourcePreferencesCollection {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_cursor: Ok(Default::default()),
                    total_count: Ok(Default::default()),
                }
            }
        }
        impl AccountResourcePreferencesCollection {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    Vec<super::AccountResourcePreferencesResponseItem>,
                >,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {}", e)
                    });
                self
            }
            pub fn next_cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for next_cursor: {}", e)
                    });
                self
            }
            pub fn total_count<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.total_count = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for total_count: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<AccountResourcePreferencesCollection>
        for super::AccountResourcePreferencesCollection {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AccountResourcePreferencesCollection,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_cursor: value.next_cursor?,
                    total_count: value.total_count?,
                })
            }
        }
        impl From<super::AccountResourcePreferencesCollection>
        for AccountResourcePreferencesCollection {
            fn from(value: super::AccountResourcePreferencesCollection) -> Self {
                Self {
                    items: Ok(value.items),
                    next_cursor: Ok(value.next_cursor),
                    total_count: Ok(value.total_count),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AccountResourcePreferencesResponseItem {
            last_updated_at_state_version: Result<
                super::LastUpdatedAtStateVersion,
                String,
            >,
            resource_address: Result<super::Address, String>,
            resource_preference_rule: Result<
                super::AccountResourcePreferenceRule,
                String,
            >,
        }
        impl Default for AccountResourcePreferencesResponseItem {
            fn default() -> Self {
                Self {
                    last_updated_at_state_version: Err(
                        "no value supplied for last_updated_at_state_version".to_string(),
                    ),
                    resource_address: Err(
                        "no value supplied for resource_address".to_string(),
                    ),
                    resource_preference_rule: Err(
                        "no value supplied for resource_preference_rule".to_string(),
                    ),
                }
            }
        }
        impl AccountResourcePreferencesResponseItem {
            pub fn last_updated_at_state_version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::LastUpdatedAtStateVersion>,
                T::Error: std::fmt::Display,
            {
                self.last_updated_at_state_version = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for last_updated_at_state_version: {}",
                            e
                        )
                    });
                self
            }
            pub fn resource_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.resource_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_address: {}", e
                        )
                    });
                self
            }
            pub fn resource_preference_rule<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::AccountResourcePreferenceRule>,
                T::Error: std::fmt::Display,
            {
                self.resource_preference_rule = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_preference_rule: {}",
                            e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<AccountResourcePreferencesResponseItem>
        for super::AccountResourcePreferencesResponseItem {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AccountResourcePreferencesResponseItem,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    last_updated_at_state_version: value.last_updated_at_state_version?,
                    resource_address: value.resource_address?,
                    resource_preference_rule: value.resource_preference_rule?,
                })
            }
        }
        impl From<super::AccountResourcePreferencesResponseItem>
        for AccountResourcePreferencesResponseItem {
            fn from(value: super::AccountResourcePreferencesResponseItem) -> Self {
                Self {
                    last_updated_at_state_version: Ok(
                        value.last_updated_at_state_version,
                    ),
                    resource_address: Ok(value.resource_address),
                    resource_preference_rule: Ok(value.resource_preference_rule),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AtLedgerStateMixin {
            at_ledger_state: Result<Option<super::LedgerStateSelector>, String>,
        }
        impl Default for AtLedgerStateMixin {
            fn default() -> Self {
                Self {
                    at_ledger_state: Ok(Default::default()),
                }
            }
        }
        impl AtLedgerStateMixin {
            pub fn at_ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::LedgerStateSelector>>,
                T::Error: std::fmt::Display,
            {
                self.at_ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for at_ledger_state: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<AtLedgerStateMixin> for super::AtLedgerStateMixin {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AtLedgerStateMixin,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    at_ledger_state: value.at_ledger_state?,
                })
            }
        }
        impl From<super::AtLedgerStateMixin> for AtLedgerStateMixin {
            fn from(value: super::AtLedgerStateMixin) -> Self {
                Self {
                    at_ledger_state: Ok(value.at_ledger_state),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct BlueprintMethodRoyalty {
            method_name: Result<String, String>,
            royalty_amount: Result<Option<super::RoyaltyAmount>, String>,
        }
        impl Default for BlueprintMethodRoyalty {
            fn default() -> Self {
                Self {
                    method_name: Err("no value supplied for method_name".to_string()),
                    royalty_amount: Ok(Default::default()),
                }
            }
        }
        impl BlueprintMethodRoyalty {
            pub fn method_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.method_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for method_name: {}", e)
                    });
                self
            }
            pub fn royalty_amount<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::RoyaltyAmount>>,
                T::Error: std::fmt::Display,
            {
                self.royalty_amount = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for royalty_amount: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<BlueprintMethodRoyalty>
        for super::BlueprintMethodRoyalty {
            type Error = super::error::ConversionError;
            fn try_from(
                value: BlueprintMethodRoyalty,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    method_name: value.method_name?,
                    royalty_amount: value.royalty_amount?,
                })
            }
        }
        impl From<super::BlueprintMethodRoyalty> for BlueprintMethodRoyalty {
            fn from(value: super::BlueprintMethodRoyalty) -> Self {
                Self {
                    method_name: Ok(value.method_name),
                    royalty_amount: Ok(value.royalty_amount),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct BlueprintRoyaltyConfig {
            is_enabled: Result<bool, String>,
            method_rules: Result<Vec<super::BlueprintMethodRoyalty>, String>,
        }
        impl Default for BlueprintRoyaltyConfig {
            fn default() -> Self {
                Self {
                    is_enabled: Err("no value supplied for is_enabled".to_string()),
                    method_rules: Ok(Default::default()),
                }
            }
        }
        impl BlueprintRoyaltyConfig {
            pub fn is_enabled<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.is_enabled = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for is_enabled: {}", e)
                    });
                self
            }
            pub fn method_rules<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::BlueprintMethodRoyalty>>,
                T::Error: std::fmt::Display,
            {
                self.method_rules = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for method_rules: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<BlueprintRoyaltyConfig>
        for super::BlueprintRoyaltyConfig {
            type Error = super::error::ConversionError;
            fn try_from(
                value: BlueprintRoyaltyConfig,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    is_enabled: value.is_enabled?,
                    method_rules: value.method_rules?,
                })
            }
        }
        impl From<super::BlueprintRoyaltyConfig> for BlueprintRoyaltyConfig {
            fn from(value: super::BlueprintRoyaltyConfig) -> Self {
                Self {
                    is_enabled: Ok(value.is_enabled),
                    method_rules: Ok(value.method_rules),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CommittedTransactionInfo {
            affected_global_entities: Result<Vec<super::Address>, String>,
            balance_changes: Result<Option<super::TransactionBalanceChanges>, String>,
            child_subintent_hashes: Result<Vec<super::HashBech32mString>, String>,
            confirmed_at: Result<Option<chrono::DateTime<chrono::offset::Utc>>, String>,
            epoch: Result<i64, String>,
            error_message: Result<Option<String>, String>,
            fee_paid: Result<Option<super::BigDecimal>, String>,
            intent_hash: Result<Option<super::HashBech32mString>, String>,
            manifest_classes: Result<Vec<super::ManifestClass>, String>,
            manifest_instructions: Result<Option<String>, String>,
            message: Result<::serde_json::Map<String, ::serde_json::Value>, String>,
            payload_hash: Result<Option<super::HashBech32mString>, String>,
            raw_hex: Result<Option<super::HexString>, String>,
            receipt: Result<Option<super::TransactionReceipt>, String>,
            round: Result<i64, String>,
            round_timestamp: Result<String, String>,
            state_version: Result<i64, String>,
            subintent_details: Result<Vec<super::TransactionSubintentDetails>, String>,
            transaction_status: Result<super::TransactionStatus, String>,
        }
        impl Default for CommittedTransactionInfo {
            fn default() -> Self {
                Self {
                    affected_global_entities: Ok(Default::default()),
                    balance_changes: Ok(Default::default()),
                    child_subintent_hashes: Ok(Default::default()),
                    confirmed_at: Ok(Default::default()),
                    epoch: Err("no value supplied for epoch".to_string()),
                    error_message: Ok(Default::default()),
                    fee_paid: Ok(Default::default()),
                    intent_hash: Ok(Default::default()),
                    manifest_classes: Ok(Default::default()),
                    manifest_instructions: Ok(Default::default()),
                    message: Ok(Default::default()),
                    payload_hash: Ok(Default::default()),
                    raw_hex: Ok(Default::default()),
                    receipt: Ok(Default::default()),
                    round: Err("no value supplied for round".to_string()),
                    round_timestamp: Err(
                        "no value supplied for round_timestamp".to_string(),
                    ),
                    state_version: Err(
                        "no value supplied for state_version".to_string(),
                    ),
                    subintent_details: Ok(Default::default()),
                    transaction_status: Err(
                        "no value supplied for transaction_status".to_string(),
                    ),
                }
            }
        }
        impl CommittedTransactionInfo {
            pub fn affected_global_entities<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Address>>,
                T::Error: std::fmt::Display,
            {
                self.affected_global_entities = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for affected_global_entities: {}",
                            e
                        )
                    });
                self
            }
            pub fn balance_changes<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::TransactionBalanceChanges>>,
                T::Error: std::fmt::Display,
            {
                self.balance_changes = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for balance_changes: {}", e
                        )
                    });
                self
            }
            pub fn child_subintent_hashes<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::HashBech32mString>>,
                T::Error: std::fmt::Display,
            {
                self.child_subintent_hashes = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for child_subintent_hashes: {}",
                            e
                        )
                    });
                self
            }
            pub fn confirmed_at<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<chrono::DateTime<chrono::offset::Utc>>>,
                T::Error: std::fmt::Display,
            {
                self.confirmed_at = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for confirmed_at: {}", e
                        )
                    });
                self
            }
            pub fn epoch<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<i64>,
                T::Error: std::fmt::Display,
            {
                self.epoch = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for epoch: {}", e)
                    });
                self
            }
            pub fn error_message<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.error_message = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for error_message: {}", e
                        )
                    });
                self
            }
            pub fn fee_paid<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::BigDecimal>>,
                T::Error: std::fmt::Display,
            {
                self.fee_paid = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for fee_paid: {}", e)
                    });
                self
            }
            pub fn intent_hash<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::HashBech32mString>>,
                T::Error: std::fmt::Display,
            {
                self.intent_hash = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for intent_hash: {}", e)
                    });
                self
            }
            pub fn manifest_classes<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::ManifestClass>>,
                T::Error: std::fmt::Display,
            {
                self.manifest_classes = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for manifest_classes: {}", e
                        )
                    });
                self
            }
            pub fn manifest_instructions<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.manifest_instructions = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for manifest_instructions: {}",
                            e
                        )
                    });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<::serde_json::Map<String, ::serde_json::Value>>,
                T::Error: std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for message: {}", e)
                    });
                self
            }
            pub fn payload_hash<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::HashBech32mString>>,
                T::Error: std::fmt::Display,
            {
                self.payload_hash = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for payload_hash: {}", e
                        )
                    });
                self
            }
            pub fn raw_hex<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::HexString>>,
                T::Error: std::fmt::Display,
            {
                self.raw_hex = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for raw_hex: {}", e)
                    });
                self
            }
            pub fn receipt<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::TransactionReceipt>>,
                T::Error: std::fmt::Display,
            {
                self.receipt = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for receipt: {}", e)
                    });
                self
            }
            pub fn round<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<i64>,
                T::Error: std::fmt::Display,
            {
                self.round = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for round: {}", e)
                    });
                self
            }
            pub fn round_timestamp<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.round_timestamp = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for round_timestamp: {}", e
                        )
                    });
                self
            }
            pub fn state_version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<i64>,
                T::Error: std::fmt::Display,
            {
                self.state_version = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for state_version: {}", e
                        )
                    });
                self
            }
            pub fn subintent_details<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::TransactionSubintentDetails>>,
                T::Error: std::fmt::Display,
            {
                self.subintent_details = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for subintent_details: {}",
                            e
                        )
                    });
                self
            }
            pub fn transaction_status<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::TransactionStatus>,
                T::Error: std::fmt::Display,
            {
                self.transaction_status = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for transaction_status: {}",
                            e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<CommittedTransactionInfo>
        for super::CommittedTransactionInfo {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CommittedTransactionInfo,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    affected_global_entities: value.affected_global_entities?,
                    balance_changes: value.balance_changes?,
                    child_subintent_hashes: value.child_subintent_hashes?,
                    confirmed_at: value.confirmed_at?,
                    epoch: value.epoch?,
                    error_message: value.error_message?,
                    fee_paid: value.fee_paid?,
                    intent_hash: value.intent_hash?,
                    manifest_classes: value.manifest_classes?,
                    manifest_instructions: value.manifest_instructions?,
                    message: value.message?,
                    payload_hash: value.payload_hash?,
                    raw_hex: value.raw_hex?,
                    receipt: value.receipt?,
                    round: value.round?,
                    round_timestamp: value.round_timestamp?,
                    state_version: value.state_version?,
                    subintent_details: value.subintent_details?,
                    transaction_status: value.transaction_status?,
                })
            }
        }
        impl From<super::CommittedTransactionInfo> for CommittedTransactionInfo {
            fn from(value: super::CommittedTransactionInfo) -> Self {
                Self {
                    affected_global_entities: Ok(value.affected_global_entities),
                    balance_changes: Ok(value.balance_changes),
                    child_subintent_hashes: Ok(value.child_subintent_hashes),
                    confirmed_at: Ok(value.confirmed_at),
                    epoch: Ok(value.epoch),
                    error_message: Ok(value.error_message),
                    fee_paid: Ok(value.fee_paid),
                    intent_hash: Ok(value.intent_hash),
                    manifest_classes: Ok(value.manifest_classes),
                    manifest_instructions: Ok(value.manifest_instructions),
                    message: Ok(value.message),
                    payload_hash: Ok(value.payload_hash),
                    raw_hex: Ok(value.raw_hex),
                    receipt: Ok(value.receipt),
                    round: Ok(value.round),
                    round_timestamp: Ok(value.round_timestamp),
                    state_version: Ok(value.state_version),
                    subintent_details: Ok(value.subintent_details),
                    transaction_status: Ok(value.transaction_status),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CompiledPreviewTransaction {
            preview_transaction_hex: Result<String, String>,
            type_: Result<super::PreviewTransactionType, String>,
        }
        impl Default for CompiledPreviewTransaction {
            fn default() -> Self {
                Self {
                    preview_transaction_hex: Err(
                        "no value supplied for preview_transaction_hex".to_string(),
                    ),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl CompiledPreviewTransaction {
            pub fn preview_transaction_hex<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.preview_transaction_hex = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for preview_transaction_hex: {}",
                            e
                        )
                    });
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::PreviewTransactionType>,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<CompiledPreviewTransaction>
        for super::CompiledPreviewTransaction {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CompiledPreviewTransaction,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    preview_transaction_hex: value.preview_transaction_hex?,
                    type_: value.type_?,
                })
            }
        }
        impl From<super::CompiledPreviewTransaction> for CompiledPreviewTransaction {
            fn from(value: super::CompiledPreviewTransaction) -> Self {
                Self {
                    preview_transaction_hex: Ok(value.preview_transaction_hex),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ComponentEntityRoleAssignmentEntry {
            assignment: Result<
                super::ComponentEntityRoleAssignmentEntryAssignment,
                String,
            >,
            role_key: Result<super::RoleKey, String>,
            updater_roles: Result<Vec<super::RoleKey>, String>,
        }
        impl Default for ComponentEntityRoleAssignmentEntry {
            fn default() -> Self {
                Self {
                    assignment: Err("no value supplied for assignment".to_string()),
                    role_key: Err("no value supplied for role_key".to_string()),
                    updater_roles: Ok(Default::default()),
                }
            }
        }
        impl ComponentEntityRoleAssignmentEntry {
            pub fn assignment<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::ComponentEntityRoleAssignmentEntryAssignment,
                >,
                T::Error: std::fmt::Display,
            {
                self.assignment = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for assignment: {}", e)
                    });
                self
            }
            pub fn role_key<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::RoleKey>,
                T::Error: std::fmt::Display,
            {
                self.role_key = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for role_key: {}", e)
                    });
                self
            }
            pub fn updater_roles<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::RoleKey>>,
                T::Error: std::fmt::Display,
            {
                self.updater_roles = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for updater_roles: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<ComponentEntityRoleAssignmentEntry>
        for super::ComponentEntityRoleAssignmentEntry {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ComponentEntityRoleAssignmentEntry,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    assignment: value.assignment?,
                    role_key: value.role_key?,
                    updater_roles: value.updater_roles?,
                })
            }
        }
        impl From<super::ComponentEntityRoleAssignmentEntry>
        for ComponentEntityRoleAssignmentEntry {
            fn from(value: super::ComponentEntityRoleAssignmentEntry) -> Self {
                Self {
                    assignment: Ok(value.assignment),
                    role_key: Ok(value.role_key),
                    updater_roles: Ok(value.updater_roles),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ComponentEntityRoleAssignmentEntryAssignment {
            explicit_rule: Result<
                ::serde_json::Map<String, ::serde_json::Value>,
                String,
            >,
            resolution: Result<super::RoleAssignmentResolution, String>,
        }
        impl Default for ComponentEntityRoleAssignmentEntryAssignment {
            fn default() -> Self {
                Self {
                    explicit_rule: Ok(Default::default()),
                    resolution: Err("no value supplied for resolution".to_string()),
                }
            }
        }
        impl ComponentEntityRoleAssignmentEntryAssignment {
            pub fn explicit_rule<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<::serde_json::Map<String, ::serde_json::Value>>,
                T::Error: std::fmt::Display,
            {
                self.explicit_rule = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for explicit_rule: {}", e
                        )
                    });
                self
            }
            pub fn resolution<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::RoleAssignmentResolution>,
                T::Error: std::fmt::Display,
            {
                self.resolution = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for resolution: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<ComponentEntityRoleAssignmentEntryAssignment>
        for super::ComponentEntityRoleAssignmentEntryAssignment {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ComponentEntityRoleAssignmentEntryAssignment,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    explicit_rule: value.explicit_rule?,
                    resolution: value.resolution?,
                })
            }
        }
        impl From<super::ComponentEntityRoleAssignmentEntryAssignment>
        for ComponentEntityRoleAssignmentEntryAssignment {
            fn from(value: super::ComponentEntityRoleAssignmentEntryAssignment) -> Self {
                Self {
                    explicit_rule: Ok(value.explicit_rule),
                    resolution: Ok(value.resolution),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ComponentEntityRoleAssignments {
            entries: Result<Vec<super::ComponentEntityRoleAssignmentEntry>, String>,
            owner: Result<::serde_json::Map<String, ::serde_json::Value>, String>,
        }
        impl Default for ComponentEntityRoleAssignments {
            fn default() -> Self {
                Self {
                    entries: Err("no value supplied for entries".to_string()),
                    owner: Err("no value supplied for owner".to_string()),
                }
            }
        }
        impl ComponentEntityRoleAssignments {
            pub fn entries<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::ComponentEntityRoleAssignmentEntry>>,
                T::Error: std::fmt::Display,
            {
                self.entries = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for entries: {}", e)
                    });
                self
            }
            pub fn owner<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<::serde_json::Map<String, ::serde_json::Value>>,
                T::Error: std::fmt::Display,
            {
                self.owner = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for owner: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<ComponentEntityRoleAssignments>
        for super::ComponentEntityRoleAssignments {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ComponentEntityRoleAssignments,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    entries: value.entries?,
                    owner: value.owner?,
                })
            }
        }
        impl From<super::ComponentEntityRoleAssignments>
        for ComponentEntityRoleAssignments {
            fn from(value: super::ComponentEntityRoleAssignments) -> Self {
                Self {
                    entries: Ok(value.entries),
                    owner: Ok(value.owner),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ComponentMethodRoyalty {
            method_name: Result<String, String>,
            royalty_amount: Result<Option<super::RoyaltyAmount>, String>,
        }
        impl Default for ComponentMethodRoyalty {
            fn default() -> Self {
                Self {
                    method_name: Err("no value supplied for method_name".to_string()),
                    royalty_amount: Ok(Default::default()),
                }
            }
        }
        impl ComponentMethodRoyalty {
            pub fn method_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.method_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for method_name: {}", e)
                    });
                self
            }
            pub fn royalty_amount<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::RoyaltyAmount>>,
                T::Error: std::fmt::Display,
            {
                self.royalty_amount = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for royalty_amount: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<ComponentMethodRoyalty>
        for super::ComponentMethodRoyalty {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ComponentMethodRoyalty,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    method_name: value.method_name?,
                    royalty_amount: value.royalty_amount?,
                })
            }
        }
        impl From<super::ComponentMethodRoyalty> for ComponentMethodRoyalty {
            fn from(value: super::ComponentMethodRoyalty) -> Self {
                Self {
                    method_name: Ok(value.method_name),
                    royalty_amount: Ok(value.royalty_amount),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ComponentRoyaltyConfig {
            is_enabled: Result<bool, String>,
            method_rules: Result<Vec<super::ComponentMethodRoyalty>, String>,
        }
        impl Default for ComponentRoyaltyConfig {
            fn default() -> Self {
                Self {
                    is_enabled: Err("no value supplied for is_enabled".to_string()),
                    method_rules: Ok(Default::default()),
                }
            }
        }
        impl ComponentRoyaltyConfig {
            pub fn is_enabled<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.is_enabled = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for is_enabled: {}", e)
                    });
                self
            }
            pub fn method_rules<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::ComponentMethodRoyalty>>,
                T::Error: std::fmt::Display,
            {
                self.method_rules = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for method_rules: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<ComponentRoyaltyConfig>
        for super::ComponentRoyaltyConfig {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ComponentRoyaltyConfig,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    is_enabled: value.is_enabled?,
                    method_rules: value.method_rules?,
                })
            }
        }
        impl From<super::ComponentRoyaltyConfig> for ComponentRoyaltyConfig {
            fn from(value: super::ComponentRoyaltyConfig) -> Self {
                Self {
                    is_enabled: Ok(value.is_enabled),
                    method_rules: Ok(value.method_rules),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CursorLimitMixin {
            cursor: Result<Option<String>, String>,
            limit_per_page: Result<Option<i64>, String>,
        }
        impl Default for CursorLimitMixin {
            fn default() -> Self {
                Self {
                    cursor: Ok(Default::default()),
                    limit_per_page: Ok(Default::default()),
                }
            }
        }
        impl CursorLimitMixin {
            pub fn cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for cursor: {}", e)
                    });
                self
            }
            pub fn limit_per_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.limit_per_page = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for limit_per_page: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<CursorLimitMixin> for super::CursorLimitMixin {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CursorLimitMixin,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    cursor: value.cursor?,
                    limit_per_page: value.limit_per_page?,
                })
            }
        }
        impl From<super::CursorLimitMixin> for CursorLimitMixin {
            fn from(value: super::CursorLimitMixin) -> Self {
                Self {
                    cursor: Ok(value.cursor),
                    limit_per_page: Ok(value.limit_per_page),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EntityMetadataCollection {
            items: Result<Vec<super::EntityMetadataItem>, String>,
            next_cursor: Result<Option<String>, String>,
            total_count: Result<Option<i64>, String>,
        }
        impl Default for EntityMetadataCollection {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_cursor: Ok(Default::default()),
                    total_count: Ok(Default::default()),
                }
            }
        }
        impl EntityMetadataCollection {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::EntityMetadataItem>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {}", e)
                    });
                self
            }
            pub fn next_cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for next_cursor: {}", e)
                    });
                self
            }
            pub fn total_count<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.total_count = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for total_count: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<EntityMetadataCollection>
        for super::EntityMetadataCollection {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EntityMetadataCollection,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_cursor: value.next_cursor?,
                    total_count: value.total_count?,
                })
            }
        }
        impl From<super::EntityMetadataCollection> for EntityMetadataCollection {
            fn from(value: super::EntityMetadataCollection) -> Self {
                Self {
                    items: Ok(value.items),
                    next_cursor: Ok(value.next_cursor),
                    total_count: Ok(value.total_count),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EntityMetadataItem {
            is_locked: Result<bool, String>,
            key: Result<String, String>,
            last_updated_at_state_version: Result<
                super::LastUpdatedAtStateVersion,
                String,
            >,
            value: Result<super::EntityMetadataItemValue, String>,
        }
        impl Default for EntityMetadataItem {
            fn default() -> Self {
                Self {
                    is_locked: Err("no value supplied for is_locked".to_string()),
                    key: Err("no value supplied for key".to_string()),
                    last_updated_at_state_version: Err(
                        "no value supplied for last_updated_at_state_version".to_string(),
                    ),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl EntityMetadataItem {
            pub fn is_locked<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.is_locked = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for is_locked: {}", e)
                    });
                self
            }
            pub fn key<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.key = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for key: {}", e)
                    });
                self
            }
            pub fn last_updated_at_state_version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::LastUpdatedAtStateVersion>,
                T::Error: std::fmt::Display,
            {
                self.last_updated_at_state_version = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for last_updated_at_state_version: {}",
                            e
                        )
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::EntityMetadataItemValue>,
                T::Error: std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<EntityMetadataItem> for super::EntityMetadataItem {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EntityMetadataItem,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    is_locked: value.is_locked?,
                    key: value.key?,
                    last_updated_at_state_version: value.last_updated_at_state_version?,
                    value: value.value?,
                })
            }
        }
        impl From<super::EntityMetadataItem> for EntityMetadataItem {
            fn from(value: super::EntityMetadataItem) -> Self {
                Self {
                    is_locked: Ok(value.is_locked),
                    key: Ok(value.key),
                    last_updated_at_state_version: Ok(
                        value.last_updated_at_state_version,
                    ),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EntityMetadataItemValue {
            programmatic_json: Result<super::ProgrammaticScryptoSborValue, String>,
            raw_hex: Result<super::HexString, String>,
            typed: Result<super::MetadataTypedValue, String>,
        }
        impl Default for EntityMetadataItemValue {
            fn default() -> Self {
                Self {
                    programmatic_json: Err(
                        "no value supplied for programmatic_json".to_string(),
                    ),
                    raw_hex: Err("no value supplied for raw_hex".to_string()),
                    typed: Err("no value supplied for typed".to_string()),
                }
            }
        }
        impl EntityMetadataItemValue {
            pub fn programmatic_json<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ProgrammaticScryptoSborValue>,
                T::Error: std::fmt::Display,
            {
                self.programmatic_json = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for programmatic_json: {}",
                            e
                        )
                    });
                self
            }
            pub fn raw_hex<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::HexString>,
                T::Error: std::fmt::Display,
            {
                self.raw_hex = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for raw_hex: {}", e)
                    });
                self
            }
            pub fn typed<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::MetadataTypedValue>,
                T::Error: std::fmt::Display,
            {
                self.typed = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for typed: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<EntityMetadataItemValue>
        for super::EntityMetadataItemValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EntityMetadataItemValue,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    programmatic_json: value.programmatic_json?,
                    raw_hex: value.raw_hex?,
                    typed: value.typed?,
                })
            }
        }
        impl From<super::EntityMetadataItemValue> for EntityMetadataItemValue {
            fn from(value: super::EntityMetadataItemValue) -> Self {
                Self {
                    programmatic_json: Ok(value.programmatic_json),
                    raw_hex: Ok(value.raw_hex),
                    typed: Ok(value.typed),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EntityNotFoundError {
            address: Result<super::Address, String>,
            type_: Result<super::EntityNotFoundErrorType, String>,
        }
        impl Default for EntityNotFoundError {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl EntityNotFoundError {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for address: {}", e)
                    });
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::EntityNotFoundErrorType>,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<EntityNotFoundError> for super::EntityNotFoundError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EntityNotFoundError,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    type_: value.type_?,
                })
            }
        }
        impl From<super::EntityNotFoundError> for EntityNotFoundError {
            fn from(value: super::EntityNotFoundError) -> Self {
                Self {
                    address: Ok(value.address),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EntitySchemaCollection {
            items: Result<Vec<super::EntitySchemaCollectionItem>, String>,
            next_cursor: Result<Option<String>, String>,
            total_count: Result<Option<i64>, String>,
        }
        impl Default for EntitySchemaCollection {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_cursor: Ok(Default::default()),
                    total_count: Ok(Default::default()),
                }
            }
        }
        impl EntitySchemaCollection {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::EntitySchemaCollectionItem>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {}", e)
                    });
                self
            }
            pub fn next_cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for next_cursor: {}", e)
                    });
                self
            }
            pub fn total_count<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.total_count = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for total_count: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<EntitySchemaCollection>
        for super::EntitySchemaCollection {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EntitySchemaCollection,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_cursor: value.next_cursor?,
                    total_count: value.total_count?,
                })
            }
        }
        impl From<super::EntitySchemaCollection> for EntitySchemaCollection {
            fn from(value: super::EntitySchemaCollection) -> Self {
                Self {
                    items: Ok(value.items),
                    next_cursor: Ok(value.next_cursor),
                    total_count: Ok(value.total_count),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EntitySchemaCollectionItem {
            schema_hash_hex: Result<super::HexString, String>,
            schema_hex: Result<super::HexString, String>,
        }
        impl Default for EntitySchemaCollectionItem {
            fn default() -> Self {
                Self {
                    schema_hash_hex: Err(
                        "no value supplied for schema_hash_hex".to_string(),
                    ),
                    schema_hex: Err("no value supplied for schema_hex".to_string()),
                }
            }
        }
        impl EntitySchemaCollectionItem {
            pub fn schema_hash_hex<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::HexString>,
                T::Error: std::fmt::Display,
            {
                self.schema_hash_hex = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for schema_hash_hex: {}", e
                        )
                    });
                self
            }
            pub fn schema_hex<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::HexString>,
                T::Error: std::fmt::Display,
            {
                self.schema_hex = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for schema_hex: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<EntitySchemaCollectionItem>
        for super::EntitySchemaCollectionItem {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EntitySchemaCollectionItem,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    schema_hash_hex: value.schema_hash_hex?,
                    schema_hex: value.schema_hex?,
                })
            }
        }
        impl From<super::EntitySchemaCollectionItem> for EntitySchemaCollectionItem {
            fn from(value: super::EntitySchemaCollectionItem) -> Self {
                Self {
                    schema_hash_hex: Ok(value.schema_hash_hex),
                    schema_hex: Ok(value.schema_hex),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ErrorResponse {
            code: Result<Option<i64>, String>,
            details: Result<Option<super::GatewayError>, String>,
            message: Result<String, String>,
            trace_id: Result<Option<String>, String>,
        }
        impl Default for ErrorResponse {
            fn default() -> Self {
                Self {
                    code: Ok(Default::default()),
                    details: Ok(Default::default()),
                    message: Err("no value supplied for message".to_string()),
                    trace_id: Ok(Default::default()),
                }
            }
        }
        impl ErrorResponse {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for code: {}", e)
                    });
                self
            }
            pub fn details<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::GatewayError>>,
                T::Error: std::fmt::Display,
            {
                self.details = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for details: {}", e)
                    });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for message: {}", e)
                    });
                self
            }
            pub fn trace_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.trace_id = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for trace_id: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<ErrorResponse> for super::ErrorResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ErrorResponse,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code: value.code?,
                    details: value.details?,
                    message: value.message?,
                    trace_id: value.trace_id?,
                })
            }
        }
        impl From<super::ErrorResponse> for ErrorResponse {
            fn from(value: super::ErrorResponse) -> Self {
                Self {
                    code: Ok(value.code),
                    details: Ok(value.details),
                    message: Ok(value.message),
                    trace_id: Ok(value.trace_id),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EventsItem {
            data: Result<super::ProgrammaticScryptoSborValue, String>,
            emitter: Result<::serde_json::Map<String, ::serde_json::Value>, String>,
            name: Result<String, String>,
        }
        impl Default for EventsItem {
            fn default() -> Self {
                Self {
                    data: Err("no value supplied for data".to_string()),
                    emitter: Err("no value supplied for emitter".to_string()),
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }
        impl EventsItem {
            pub fn data<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ProgrammaticScryptoSborValue>,
                T::Error: std::fmt::Display,
            {
                self.data = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for data: {}", e)
                    });
                self
            }
            pub fn emitter<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<::serde_json::Map<String, ::serde_json::Value>>,
                T::Error: std::fmt::Display,
            {
                self.emitter = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for emitter: {}", e)
                    });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for name: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<EventsItem> for super::EventsItem {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EventsItem,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    data: value.data?,
                    emitter: value.emitter?,
                    name: value.name?,
                })
            }
        }
        impl From<super::EventsItem> for EventsItem {
            fn from(value: super::EventsItem) -> Self {
                Self {
                    data: Ok(value.data),
                    emitter: Ok(value.emitter),
                    name: Ok(value.name),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct FromLedgerStateMixin {
            from_ledger_state: Result<Option<super::LedgerStateSelector>, String>,
        }
        impl Default for FromLedgerStateMixin {
            fn default() -> Self {
                Self {
                    from_ledger_state: Ok(Default::default()),
                }
            }
        }
        impl FromLedgerStateMixin {
            pub fn from_ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::LedgerStateSelector>>,
                T::Error: std::fmt::Display,
            {
                self.from_ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for from_ledger_state: {}",
                            e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<FromLedgerStateMixin>
        for super::FromLedgerStateMixin {
            type Error = super::error::ConversionError;
            fn try_from(
                value: FromLedgerStateMixin,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    from_ledger_state: value.from_ledger_state?,
                })
            }
        }
        impl From<super::FromLedgerStateMixin> for FromLedgerStateMixin {
            fn from(value: super::FromLedgerStateMixin) -> Self {
                Self {
                    from_ledger_state: Ok(value.from_ledger_state),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct FungibleResourcesCollection {
            items: Result<Vec<super::FungibleResourcesCollectionItem>, String>,
            next_cursor: Result<Option<String>, String>,
            total_count: Result<Option<i64>, String>,
        }
        impl Default for FungibleResourcesCollection {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_cursor: Ok(Default::default()),
                    total_count: Ok(Default::default()),
                }
            }
        }
        impl FungibleResourcesCollection {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::FungibleResourcesCollectionItem>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {}", e)
                    });
                self
            }
            pub fn next_cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for next_cursor: {}", e)
                    });
                self
            }
            pub fn total_count<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.total_count = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for total_count: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<FungibleResourcesCollection>
        for super::FungibleResourcesCollection {
            type Error = super::error::ConversionError;
            fn try_from(
                value: FungibleResourcesCollection,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_cursor: value.next_cursor?,
                    total_count: value.total_count?,
                })
            }
        }
        impl From<super::FungibleResourcesCollection> for FungibleResourcesCollection {
            fn from(value: super::FungibleResourcesCollection) -> Self {
                Self {
                    items: Ok(value.items),
                    next_cursor: Ok(value.next_cursor),
                    total_count: Ok(value.total_count),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct FungibleResourcesCollectionItemBase {
            aggregation_level: Result<super::ResourceAggregationLevel, String>,
            explicit_metadata: Result<Option<super::EntityMetadataCollection>, String>,
            resource_address: Result<super::Address, String>,
        }
        impl Default for FungibleResourcesCollectionItemBase {
            fn default() -> Self {
                Self {
                    aggregation_level: Err(
                        "no value supplied for aggregation_level".to_string(),
                    ),
                    explicit_metadata: Ok(Default::default()),
                    resource_address: Err(
                        "no value supplied for resource_address".to_string(),
                    ),
                }
            }
        }
        impl FungibleResourcesCollectionItemBase {
            pub fn aggregation_level<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ResourceAggregationLevel>,
                T::Error: std::fmt::Display,
            {
                self.aggregation_level = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for aggregation_level: {}",
                            e
                        )
                    });
                self
            }
            pub fn explicit_metadata<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::EntityMetadataCollection>>,
                T::Error: std::fmt::Display,
            {
                self.explicit_metadata = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for explicit_metadata: {}",
                            e
                        )
                    });
                self
            }
            pub fn resource_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.resource_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_address: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<FungibleResourcesCollectionItemBase>
        for super::FungibleResourcesCollectionItemBase {
            type Error = super::error::ConversionError;
            fn try_from(
                value: FungibleResourcesCollectionItemBase,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    aggregation_level: value.aggregation_level?,
                    explicit_metadata: value.explicit_metadata?,
                    resource_address: value.resource_address?,
                })
            }
        }
        impl From<super::FungibleResourcesCollectionItemBase>
        for FungibleResourcesCollectionItemBase {
            fn from(value: super::FungibleResourcesCollectionItemBase) -> Self {
                Self {
                    aggregation_level: Ok(value.aggregation_level),
                    explicit_metadata: Ok(value.explicit_metadata),
                    resource_address: Ok(value.resource_address),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct FungibleResourcesCollectionItemGloballyAggregated {
            aggregation_level: Result<
                super::FungibleResourcesCollectionItemGloballyAggregatedAggregationLevel,
                String,
            >,
            amount: Result<super::BigDecimal, String>,
            explicit_metadata: Result<Option<super::EntityMetadataCollection>, String>,
            last_updated_at_state_version: Result<
                super::LastUpdatedAtStateVersion,
                String,
            >,
            resource_address: Result<super::Address, String>,
        }
        impl Default for FungibleResourcesCollectionItemGloballyAggregated {
            fn default() -> Self {
                Self {
                    aggregation_level: Err(
                        "no value supplied for aggregation_level".to_string(),
                    ),
                    amount: Err("no value supplied for amount".to_string()),
                    explicit_metadata: Ok(Default::default()),
                    last_updated_at_state_version: Err(
                        "no value supplied for last_updated_at_state_version".to_string(),
                    ),
                    resource_address: Err(
                        "no value supplied for resource_address".to_string(),
                    ),
                }
            }
        }
        impl FungibleResourcesCollectionItemGloballyAggregated {
            pub fn aggregation_level<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::FungibleResourcesCollectionItemGloballyAggregatedAggregationLevel,
                >,
                T::Error: std::fmt::Display,
            {
                self.aggregation_level = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for aggregation_level: {}",
                            e
                        )
                    });
                self
            }
            pub fn amount<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::BigDecimal>,
                T::Error: std::fmt::Display,
            {
                self.amount = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for amount: {}", e)
                    });
                self
            }
            pub fn explicit_metadata<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::EntityMetadataCollection>>,
                T::Error: std::fmt::Display,
            {
                self.explicit_metadata = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for explicit_metadata: {}",
                            e
                        )
                    });
                self
            }
            pub fn last_updated_at_state_version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::LastUpdatedAtStateVersion>,
                T::Error: std::fmt::Display,
            {
                self.last_updated_at_state_version = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for last_updated_at_state_version: {}",
                            e
                        )
                    });
                self
            }
            pub fn resource_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.resource_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_address: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<FungibleResourcesCollectionItemGloballyAggregated>
        for super::FungibleResourcesCollectionItemGloballyAggregated {
            type Error = super::error::ConversionError;
            fn try_from(
                value: FungibleResourcesCollectionItemGloballyAggregated,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    aggregation_level: value.aggregation_level?,
                    amount: value.amount?,
                    explicit_metadata: value.explicit_metadata?,
                    last_updated_at_state_version: value.last_updated_at_state_version?,
                    resource_address: value.resource_address?,
                })
            }
        }
        impl From<super::FungibleResourcesCollectionItemGloballyAggregated>
        for FungibleResourcesCollectionItemGloballyAggregated {
            fn from(
                value: super::FungibleResourcesCollectionItemGloballyAggregated,
            ) -> Self {
                Self {
                    aggregation_level: Ok(value.aggregation_level),
                    amount: Ok(value.amount),
                    explicit_metadata: Ok(value.explicit_metadata),
                    last_updated_at_state_version: Ok(
                        value.last_updated_at_state_version,
                    ),
                    resource_address: Ok(value.resource_address),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct FungibleResourcesCollectionItemVaultAggregated {
            aggregation_level: Result<
                super::FungibleResourcesCollectionItemVaultAggregatedAggregationLevel,
                String,
            >,
            explicit_metadata: Result<Option<super::EntityMetadataCollection>, String>,
            resource_address: Result<super::Address, String>,
            vaults: Result<
                super::FungibleResourcesCollectionItemVaultAggregatedVault,
                String,
            >,
        }
        impl Default for FungibleResourcesCollectionItemVaultAggregated {
            fn default() -> Self {
                Self {
                    aggregation_level: Err(
                        "no value supplied for aggregation_level".to_string(),
                    ),
                    explicit_metadata: Ok(Default::default()),
                    resource_address: Err(
                        "no value supplied for resource_address".to_string(),
                    ),
                    vaults: Err("no value supplied for vaults".to_string()),
                }
            }
        }
        impl FungibleResourcesCollectionItemVaultAggregated {
            pub fn aggregation_level<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::FungibleResourcesCollectionItemVaultAggregatedAggregationLevel,
                >,
                T::Error: std::fmt::Display,
            {
                self.aggregation_level = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for aggregation_level: {}",
                            e
                        )
                    });
                self
            }
            pub fn explicit_metadata<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::EntityMetadataCollection>>,
                T::Error: std::fmt::Display,
            {
                self.explicit_metadata = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for explicit_metadata: {}",
                            e
                        )
                    });
                self
            }
            pub fn resource_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.resource_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_address: {}", e
                        )
                    });
                self
            }
            pub fn vaults<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::FungibleResourcesCollectionItemVaultAggregatedVault,
                >,
                T::Error: std::fmt::Display,
            {
                self.vaults = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for vaults: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<FungibleResourcesCollectionItemVaultAggregated>
        for super::FungibleResourcesCollectionItemVaultAggregated {
            type Error = super::error::ConversionError;
            fn try_from(
                value: FungibleResourcesCollectionItemVaultAggregated,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    aggregation_level: value.aggregation_level?,
                    explicit_metadata: value.explicit_metadata?,
                    resource_address: value.resource_address?,
                    vaults: value.vaults?,
                })
            }
        }
        impl From<super::FungibleResourcesCollectionItemVaultAggregated>
        for FungibleResourcesCollectionItemVaultAggregated {
            fn from(
                value: super::FungibleResourcesCollectionItemVaultAggregated,
            ) -> Self {
                Self {
                    aggregation_level: Ok(value.aggregation_level),
                    explicit_metadata: Ok(value.explicit_metadata),
                    resource_address: Ok(value.resource_address),
                    vaults: Ok(value.vaults),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct FungibleResourcesCollectionItemVaultAggregatedVault {
            items: Result<
                Vec<super::FungibleResourcesCollectionItemVaultAggregatedVaultItem>,
                String,
            >,
            next_cursor: Result<Option<String>, String>,
            total_count: Result<Option<i64>, String>,
        }
        impl Default for FungibleResourcesCollectionItemVaultAggregatedVault {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_cursor: Ok(Default::default()),
                    total_count: Ok(Default::default()),
                }
            }
        }
        impl FungibleResourcesCollectionItemVaultAggregatedVault {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    Vec<super::FungibleResourcesCollectionItemVaultAggregatedVaultItem>,
                >,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {}", e)
                    });
                self
            }
            pub fn next_cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for next_cursor: {}", e)
                    });
                self
            }
            pub fn total_count<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.total_count = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for total_count: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<FungibleResourcesCollectionItemVaultAggregatedVault>
        for super::FungibleResourcesCollectionItemVaultAggregatedVault {
            type Error = super::error::ConversionError;
            fn try_from(
                value: FungibleResourcesCollectionItemVaultAggregatedVault,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_cursor: value.next_cursor?,
                    total_count: value.total_count?,
                })
            }
        }
        impl From<super::FungibleResourcesCollectionItemVaultAggregatedVault>
        for FungibleResourcesCollectionItemVaultAggregatedVault {
            fn from(
                value: super::FungibleResourcesCollectionItemVaultAggregatedVault,
            ) -> Self {
                Self {
                    items: Ok(value.items),
                    next_cursor: Ok(value.next_cursor),
                    total_count: Ok(value.total_count),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct FungibleResourcesCollectionItemVaultAggregatedVaultItem {
            amount: Result<super::BigDecimal, String>,
            last_updated_at_state_version: Result<
                super::LastUpdatedAtStateVersion,
                String,
            >,
            vault_address: Result<super::Address, String>,
        }
        impl Default for FungibleResourcesCollectionItemVaultAggregatedVaultItem {
            fn default() -> Self {
                Self {
                    amount: Err("no value supplied for amount".to_string()),
                    last_updated_at_state_version: Err(
                        "no value supplied for last_updated_at_state_version".to_string(),
                    ),
                    vault_address: Err("no value supplied for vault_address".to_string()),
                }
            }
        }
        impl FungibleResourcesCollectionItemVaultAggregatedVaultItem {
            pub fn amount<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::BigDecimal>,
                T::Error: std::fmt::Display,
            {
                self.amount = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for amount: {}", e)
                    });
                self
            }
            pub fn last_updated_at_state_version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::LastUpdatedAtStateVersion>,
                T::Error: std::fmt::Display,
            {
                self.last_updated_at_state_version = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for last_updated_at_state_version: {}",
                            e
                        )
                    });
                self
            }
            pub fn vault_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.vault_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for vault_address: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<
            FungibleResourcesCollectionItemVaultAggregatedVaultItem,
        > for super::FungibleResourcesCollectionItemVaultAggregatedVaultItem {
            type Error = super::error::ConversionError;
            fn try_from(
                value: FungibleResourcesCollectionItemVaultAggregatedVaultItem,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    amount: value.amount?,
                    last_updated_at_state_version: value.last_updated_at_state_version?,
                    vault_address: value.vault_address?,
                })
            }
        }
        impl From<super::FungibleResourcesCollectionItemVaultAggregatedVaultItem>
        for FungibleResourcesCollectionItemVaultAggregatedVaultItem {
            fn from(
                value: super::FungibleResourcesCollectionItemVaultAggregatedVaultItem,
            ) -> Self {
                Self {
                    amount: Ok(value.amount),
                    last_updated_at_state_version: Ok(
                        value.last_updated_at_state_version,
                    ),
                    vault_address: Ok(value.vault_address),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct GatewayErrorBase {
            type_: Result<String, String>,
        }
        impl Default for GatewayErrorBase {
            fn default() -> Self {
                Self {
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl GatewayErrorBase {
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<GatewayErrorBase> for super::GatewayErrorBase {
            type Error = super::error::ConversionError;
            fn try_from(
                value: GatewayErrorBase,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self { type_: value.type_? })
            }
        }
        impl From<super::GatewayErrorBase> for GatewayErrorBase {
            fn from(value: super::GatewayErrorBase) -> Self {
                Self { type_: Ok(value.type_) }
            }
        }
        #[derive(Clone, Debug)]
        pub struct GatewayInfoResponseKnownTarget {
            state_version: Result<i64, String>,
        }
        impl Default for GatewayInfoResponseKnownTarget {
            fn default() -> Self {
                Self {
                    state_version: Err("no value supplied for state_version".to_string()),
                }
            }
        }
        impl GatewayInfoResponseKnownTarget {
            pub fn state_version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<i64>,
                T::Error: std::fmt::Display,
            {
                self.state_version = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for state_version: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<GatewayInfoResponseKnownTarget>
        for super::GatewayInfoResponseKnownTarget {
            type Error = super::error::ConversionError;
            fn try_from(
                value: GatewayInfoResponseKnownTarget,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    state_version: value.state_version?,
                })
            }
        }
        impl From<super::GatewayInfoResponseKnownTarget>
        for GatewayInfoResponseKnownTarget {
            fn from(value: super::GatewayInfoResponseKnownTarget) -> Self {
                Self {
                    state_version: Ok(value.state_version),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct GatewayInfoResponseReleaseInfo {
            image_tag: Result<String, String>,
            open_api_schema_version: Result<String, String>,
            release_version: Result<String, String>,
        }
        impl Default for GatewayInfoResponseReleaseInfo {
            fn default() -> Self {
                Self {
                    image_tag: Err("no value supplied for image_tag".to_string()),
                    open_api_schema_version: Err(
                        "no value supplied for open_api_schema_version".to_string(),
                    ),
                    release_version: Err(
                        "no value supplied for release_version".to_string(),
                    ),
                }
            }
        }
        impl GatewayInfoResponseReleaseInfo {
            pub fn image_tag<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.image_tag = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for image_tag: {}", e)
                    });
                self
            }
            pub fn open_api_schema_version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.open_api_schema_version = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for open_api_schema_version: {}",
                            e
                        )
                    });
                self
            }
            pub fn release_version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.release_version = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for release_version: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<GatewayInfoResponseReleaseInfo>
        for super::GatewayInfoResponseReleaseInfo {
            type Error = super::error::ConversionError;
            fn try_from(
                value: GatewayInfoResponseReleaseInfo,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    image_tag: value.image_tag?,
                    open_api_schema_version: value.open_api_schema_version?,
                    release_version: value.release_version?,
                })
            }
        }
        impl From<super::GatewayInfoResponseReleaseInfo>
        for GatewayInfoResponseReleaseInfo {
            fn from(value: super::GatewayInfoResponseReleaseInfo) -> Self {
                Self {
                    image_tag: Ok(value.image_tag),
                    open_api_schema_version: Ok(value.open_api_schema_version),
                    release_version: Ok(value.release_version),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct GatewayStatusResponse {
            ledger_state: Result<super::LedgerState, String>,
            release_info: Result<super::GatewayInfoResponseReleaseInfo, String>,
        }
        impl Default for GatewayStatusResponse {
            fn default() -> Self {
                Self {
                    ledger_state: Err("no value supplied for ledger_state".to_string()),
                    release_info: Err("no value supplied for release_info".to_string()),
                }
            }
        }
        impl GatewayStatusResponse {
            pub fn ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::LedgerState>,
                T::Error: std::fmt::Display,
            {
                self.ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn release_info<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::GatewayInfoResponseReleaseInfo>,
                T::Error: std::fmt::Display,
            {
                self.release_info = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for release_info: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<GatewayStatusResponse>
        for super::GatewayStatusResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: GatewayStatusResponse,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    ledger_state: value.ledger_state?,
                    release_info: value.release_info?,
                })
            }
        }
        impl From<super::GatewayStatusResponse> for GatewayStatusResponse {
            fn from(value: super::GatewayStatusResponse) -> Self {
                Self {
                    ledger_state: Ok(value.ledger_state),
                    release_info: Ok(value.release_info),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct InternalServerError {
            cause: Result<String, String>,
            exception: Result<String, String>,
            type_: Result<super::InternalServerErrorType, String>,
        }
        impl Default for InternalServerError {
            fn default() -> Self {
                Self {
                    cause: Err("no value supplied for cause".to_string()),
                    exception: Err("no value supplied for exception".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl InternalServerError {
            pub fn cause<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.cause = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for cause: {}", e)
                    });
                self
            }
            pub fn exception<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.exception = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for exception: {}", e)
                    });
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::InternalServerErrorType>,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<InternalServerError> for super::InternalServerError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: InternalServerError,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    cause: value.cause?,
                    exception: value.exception?,
                    type_: value.type_?,
                })
            }
        }
        impl From<super::InternalServerError> for InternalServerError {
            fn from(value: super::InternalServerError) -> Self {
                Self {
                    cause: Ok(value.cause),
                    exception: Ok(value.exception),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct InvalidEntityError {
            address: Result<super::Address, String>,
            type_: Result<super::InvalidEntityErrorType, String>,
        }
        impl Default for InvalidEntityError {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl InvalidEntityError {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for address: {}", e)
                    });
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::InvalidEntityErrorType>,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<InvalidEntityError> for super::InvalidEntityError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: InvalidEntityError,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    type_: value.type_?,
                })
            }
        }
        impl From<super::InvalidEntityError> for InvalidEntityError {
            fn from(value: super::InvalidEntityError) -> Self {
                Self {
                    address: Ok(value.address),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct InvalidRequestError {
            type_: Result<super::InvalidRequestErrorType, String>,
            validation_errors: Result<Vec<super::ValidationErrorsAtPath>, String>,
        }
        impl Default for InvalidRequestError {
            fn default() -> Self {
                Self {
                    type_: Err("no value supplied for type_".to_string()),
                    validation_errors: Err(
                        "no value supplied for validation_errors".to_string(),
                    ),
                }
            }
        }
        impl InvalidRequestError {
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::InvalidRequestErrorType>,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
            pub fn validation_errors<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::ValidationErrorsAtPath>>,
                T::Error: std::fmt::Display,
            {
                self.validation_errors = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for validation_errors: {}",
                            e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<InvalidRequestError> for super::InvalidRequestError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: InvalidRequestError,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    type_: value.type_?,
                    validation_errors: value.validation_errors?,
                })
            }
        }
        impl From<super::InvalidRequestError> for InvalidRequestError {
            fn from(value: super::InvalidRequestError) -> Self {
                Self {
                    type_: Ok(value.type_),
                    validation_errors: Ok(value.validation_errors),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct InvalidTransactionError {
            type_: Result<super::InvalidTransactionErrorType, String>,
        }
        impl Default for InvalidTransactionError {
            fn default() -> Self {
                Self {
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl InvalidTransactionError {
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::InvalidTransactionErrorType>,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<InvalidTransactionError>
        for super::InvalidTransactionError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: InvalidTransactionError,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self { type_: value.type_? })
            }
        }
        impl From<super::InvalidTransactionError> for InvalidTransactionError {
            fn from(value: super::InvalidTransactionError) -> Self {
                Self { type_: Ok(value.type_) }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LedgerState {
            epoch: Result<i64, String>,
            network: Result<super::NetworkName, String>,
            proposer_round_timestamp: Result<String, String>,
            round: Result<i64, String>,
            state_version: Result<i64, String>,
        }
        impl Default for LedgerState {
            fn default() -> Self {
                Self {
                    epoch: Err("no value supplied for epoch".to_string()),
                    network: Err("no value supplied for network".to_string()),
                    proposer_round_timestamp: Err(
                        "no value supplied for proposer_round_timestamp".to_string(),
                    ),
                    round: Err("no value supplied for round".to_string()),
                    state_version: Err("no value supplied for state_version".to_string()),
                }
            }
        }
        impl LedgerState {
            pub fn epoch<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<i64>,
                T::Error: std::fmt::Display,
            {
                self.epoch = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for epoch: {}", e)
                    });
                self
            }
            pub fn network<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::NetworkName>,
                T::Error: std::fmt::Display,
            {
                self.network = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for network: {}", e)
                    });
                self
            }
            pub fn proposer_round_timestamp<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.proposer_round_timestamp = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for proposer_round_timestamp: {}",
                            e
                        )
                    });
                self
            }
            pub fn round<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<i64>,
                T::Error: std::fmt::Display,
            {
                self.round = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for round: {}", e)
                    });
                self
            }
            pub fn state_version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<i64>,
                T::Error: std::fmt::Display,
            {
                self.state_version = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for state_version: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<LedgerState> for super::LedgerState {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LedgerState,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    epoch: value.epoch?,
                    network: value.network?,
                    proposer_round_timestamp: value.proposer_round_timestamp?,
                    round: value.round?,
                    state_version: value.state_version?,
                })
            }
        }
        impl From<super::LedgerState> for LedgerState {
            fn from(value: super::LedgerState) -> Self {
                Self {
                    epoch: Ok(value.epoch),
                    network: Ok(value.network),
                    proposer_round_timestamp: Ok(value.proposer_round_timestamp),
                    round: Ok(value.round),
                    state_version: Ok(value.state_version),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LedgerStateMixin {
            ledger_state: Result<super::LedgerState, String>,
        }
        impl Default for LedgerStateMixin {
            fn default() -> Self {
                Self {
                    ledger_state: Err("no value supplied for ledger_state".to_string()),
                }
            }
        }
        impl LedgerStateMixin {
            pub fn ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::LedgerState>,
                T::Error: std::fmt::Display,
            {
                self.ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for ledger_state: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<LedgerStateMixin> for super::LedgerStateMixin {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LedgerStateMixin,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    ledger_state: value.ledger_state?,
                })
            }
        }
        impl From<super::LedgerStateMixin> for LedgerStateMixin {
            fn from(value: super::LedgerStateMixin) -> Self {
                Self {
                    ledger_state: Ok(value.ledger_state),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LedgerStateSelectorInner {
            epoch: Result<Option<i64>, String>,
            round: Result<Option<i64>, String>,
            state_version: Result<Option<i64>, String>,
            timestamp: Result<Option<chrono::DateTime<chrono::offset::Utc>>, String>,
        }
        impl Default for LedgerStateSelectorInner {
            fn default() -> Self {
                Self {
                    epoch: Ok(Default::default()),
                    round: Ok(Default::default()),
                    state_version: Ok(Default::default()),
                    timestamp: Ok(Default::default()),
                }
            }
        }
        impl LedgerStateSelectorInner {
            pub fn epoch<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.epoch = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for epoch: {}", e)
                    });
                self
            }
            pub fn round<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.round = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for round: {}", e)
                    });
                self
            }
            pub fn state_version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.state_version = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for state_version: {}", e
                        )
                    });
                self
            }
            pub fn timestamp<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<chrono::DateTime<chrono::offset::Utc>>>,
                T::Error: std::fmt::Display,
            {
                self.timestamp = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for timestamp: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<LedgerStateSelectorInner>
        for super::LedgerStateSelectorInner {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LedgerStateSelectorInner,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    epoch: value.epoch?,
                    round: value.round?,
                    state_version: value.state_version?,
                    timestamp: value.timestamp?,
                })
            }
        }
        impl From<super::LedgerStateSelectorInner> for LedgerStateSelectorInner {
            fn from(value: super::LedgerStateSelectorInner) -> Self {
                Self {
                    epoch: Ok(value.epoch),
                    round: Ok(value.round),
                    state_version: Ok(value.state_version),
                    timestamp: Ok(value.timestamp),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MetadataBoolArrayValue {
            type_: Result<super::MetadataBoolArrayValueType, String>,
            values: Result<Vec<bool>, String>,
        }
        impl Default for MetadataBoolArrayValue {
            fn default() -> Self {
                Self {
                    type_: Err("no value supplied for type_".to_string()),
                    values: Err("no value supplied for values".to_string()),
                }
            }
        }
        impl MetadataBoolArrayValue {
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::MetadataBoolArrayValueType>,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
            pub fn values<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<bool>>,
                T::Error: std::fmt::Display,
            {
                self.values = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for values: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<MetadataBoolArrayValue>
        for super::MetadataBoolArrayValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MetadataBoolArrayValue,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    type_: value.type_?,
                    values: value.values?,
                })
            }
        }
        impl From<super::MetadataBoolArrayValue> for MetadataBoolArrayValue {
            fn from(value: super::MetadataBoolArrayValue) -> Self {
                Self {
                    type_: Ok(value.type_),
                    values: Ok(value.values),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MetadataBoolValue {
            type_: Result<super::MetadataBoolValueType, String>,
            value: Result<bool, String>,
        }
        impl Default for MetadataBoolValue {
            fn default() -> Self {
                Self {
                    type_: Err("no value supplied for type_".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl MetadataBoolValue {
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::MetadataBoolValueType>,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<MetadataBoolValue> for super::MetadataBoolValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MetadataBoolValue,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    type_: value.type_?,
                    value: value.value?,
                })
            }
        }
        impl From<super::MetadataBoolValue> for MetadataBoolValue {
            fn from(value: super::MetadataBoolValue) -> Self {
                Self {
                    type_: Ok(value.type_),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MetadataDecimalArrayValue {
            type_: Result<super::MetadataDecimalArrayValueType, String>,
            values: Result<Vec<String>, String>,
        }
        impl Default for MetadataDecimalArrayValue {
            fn default() -> Self {
                Self {
                    type_: Err("no value supplied for type_".to_string()),
                    values: Err("no value supplied for values".to_string()),
                }
            }
        }
        impl MetadataDecimalArrayValue {
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::MetadataDecimalArrayValueType>,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
            pub fn values<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<String>>,
                T::Error: std::fmt::Display,
            {
                self.values = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for values: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<MetadataDecimalArrayValue>
        for super::MetadataDecimalArrayValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MetadataDecimalArrayValue,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    type_: value.type_?,
                    values: value.values?,
                })
            }
        }
        impl From<super::MetadataDecimalArrayValue> for MetadataDecimalArrayValue {
            fn from(value: super::MetadataDecimalArrayValue) -> Self {
                Self {
                    type_: Ok(value.type_),
                    values: Ok(value.values),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MetadataDecimalValue {
            type_: Result<super::MetadataDecimalValueType, String>,
            value: Result<String, String>,
        }
        impl Default for MetadataDecimalValue {
            fn default() -> Self {
                Self {
                    type_: Err("no value supplied for type_".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl MetadataDecimalValue {
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::MetadataDecimalValueType>,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<MetadataDecimalValue>
        for super::MetadataDecimalValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MetadataDecimalValue,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    type_: value.type_?,
                    value: value.value?,
                })
            }
        }
        impl From<super::MetadataDecimalValue> for MetadataDecimalValue {
            fn from(value: super::MetadataDecimalValue) -> Self {
                Self {
                    type_: Ok(value.type_),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MetadataGlobalAddressArrayValue {
            type_: Result<super::MetadataGlobalAddressArrayValueType, String>,
            values: Result<Vec<String>, String>,
        }
        impl Default for MetadataGlobalAddressArrayValue {
            fn default() -> Self {
                Self {
                    type_: Err("no value supplied for type_".to_string()),
                    values: Err("no value supplied for values".to_string()),
                }
            }
        }
        impl MetadataGlobalAddressArrayValue {
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::MetadataGlobalAddressArrayValueType>,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
            pub fn values<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<String>>,
                T::Error: std::fmt::Display,
            {
                self.values = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for values: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<MetadataGlobalAddressArrayValue>
        for super::MetadataGlobalAddressArrayValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MetadataGlobalAddressArrayValue,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    type_: value.type_?,
                    values: value.values?,
                })
            }
        }
        impl From<super::MetadataGlobalAddressArrayValue>
        for MetadataGlobalAddressArrayValue {
            fn from(value: super::MetadataGlobalAddressArrayValue) -> Self {
                Self {
                    type_: Ok(value.type_),
                    values: Ok(value.values),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MetadataGlobalAddressValue {
            type_: Result<super::MetadataGlobalAddressValueType, String>,
            value: Result<String, String>,
        }
        impl Default for MetadataGlobalAddressValue {
            fn default() -> Self {
                Self {
                    type_: Err("no value supplied for type_".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl MetadataGlobalAddressValue {
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::MetadataGlobalAddressValueType>,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<MetadataGlobalAddressValue>
        for super::MetadataGlobalAddressValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MetadataGlobalAddressValue,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    type_: value.type_?,
                    value: value.value?,
                })
            }
        }
        impl From<super::MetadataGlobalAddressValue> for MetadataGlobalAddressValue {
            fn from(value: super::MetadataGlobalAddressValue) -> Self {
                Self {
                    type_: Ok(value.type_),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MetadataI32ArrayValue {
            type_: Result<super::MetadataI32ArrayValueType, String>,
            values: Result<Vec<String>, String>,
        }
        impl Default for MetadataI32ArrayValue {
            fn default() -> Self {
                Self {
                    type_: Err("no value supplied for type_".to_string()),
                    values: Err("no value supplied for values".to_string()),
                }
            }
        }
        impl MetadataI32ArrayValue {
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::MetadataI32ArrayValueType>,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
            pub fn values<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<String>>,
                T::Error: std::fmt::Display,
            {
                self.values = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for values: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<MetadataI32ArrayValue>
        for super::MetadataI32ArrayValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MetadataI32ArrayValue,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    type_: value.type_?,
                    values: value.values?,
                })
            }
        }
        impl From<super::MetadataI32ArrayValue> for MetadataI32ArrayValue {
            fn from(value: super::MetadataI32ArrayValue) -> Self {
                Self {
                    type_: Ok(value.type_),
                    values: Ok(value.values),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MetadataI32Value {
            type_: Result<super::MetadataI32ValueType, String>,
            value: Result<String, String>,
        }
        impl Default for MetadataI32Value {
            fn default() -> Self {
                Self {
                    type_: Err("no value supplied for type_".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl MetadataI32Value {
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::MetadataI32ValueType>,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<MetadataI32Value> for super::MetadataI32Value {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MetadataI32Value,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    type_: value.type_?,
                    value: value.value?,
                })
            }
        }
        impl From<super::MetadataI32Value> for MetadataI32Value {
            fn from(value: super::MetadataI32Value) -> Self {
                Self {
                    type_: Ok(value.type_),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MetadataI64ArrayValue {
            type_: Result<super::MetadataI64ArrayValueType, String>,
            values: Result<Vec<String>, String>,
        }
        impl Default for MetadataI64ArrayValue {
            fn default() -> Self {
                Self {
                    type_: Err("no value supplied for type_".to_string()),
                    values: Err("no value supplied for values".to_string()),
                }
            }
        }
        impl MetadataI64ArrayValue {
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::MetadataI64ArrayValueType>,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
            pub fn values<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<String>>,
                T::Error: std::fmt::Display,
            {
                self.values = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for values: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<MetadataI64ArrayValue>
        for super::MetadataI64ArrayValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MetadataI64ArrayValue,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    type_: value.type_?,
                    values: value.values?,
                })
            }
        }
        impl From<super::MetadataI64ArrayValue> for MetadataI64ArrayValue {
            fn from(value: super::MetadataI64ArrayValue) -> Self {
                Self {
                    type_: Ok(value.type_),
                    values: Ok(value.values),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MetadataI64Value {
            type_: Result<super::MetadataI64ValueType, String>,
            value: Result<String, String>,
        }
        impl Default for MetadataI64Value {
            fn default() -> Self {
                Self {
                    type_: Err("no value supplied for type_".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl MetadataI64Value {
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::MetadataI64ValueType>,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<MetadataI64Value> for super::MetadataI64Value {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MetadataI64Value,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    type_: value.type_?,
                    value: value.value?,
                })
            }
        }
        impl From<super::MetadataI64Value> for MetadataI64Value {
            fn from(value: super::MetadataI64Value) -> Self {
                Self {
                    type_: Ok(value.type_),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MetadataInstantArrayValue {
            type_: Result<super::MetadataInstantArrayValueType, String>,
            values: Result<Vec<String>, String>,
            values_unix_timestamp_seconds: Result<Vec<String>, String>,
        }
        impl Default for MetadataInstantArrayValue {
            fn default() -> Self {
                Self {
                    type_: Err("no value supplied for type_".to_string()),
                    values: Err("no value supplied for values".to_string()),
                    values_unix_timestamp_seconds: Err(
                        "no value supplied for values_unix_timestamp_seconds".to_string(),
                    ),
                }
            }
        }
        impl MetadataInstantArrayValue {
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::MetadataInstantArrayValueType>,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
            pub fn values<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<String>>,
                T::Error: std::fmt::Display,
            {
                self.values = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for values: {}", e)
                    });
                self
            }
            pub fn values_unix_timestamp_seconds<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<String>>,
                T::Error: std::fmt::Display,
            {
                self.values_unix_timestamp_seconds = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for values_unix_timestamp_seconds: {}",
                            e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<MetadataInstantArrayValue>
        for super::MetadataInstantArrayValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MetadataInstantArrayValue,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    type_: value.type_?,
                    values: value.values?,
                    values_unix_timestamp_seconds: value.values_unix_timestamp_seconds?,
                })
            }
        }
        impl From<super::MetadataInstantArrayValue> for MetadataInstantArrayValue {
            fn from(value: super::MetadataInstantArrayValue) -> Self {
                Self {
                    type_: Ok(value.type_),
                    values: Ok(value.values),
                    values_unix_timestamp_seconds: Ok(
                        value.values_unix_timestamp_seconds,
                    ),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MetadataInstantValue {
            type_: Result<super::MetadataInstantValueType, String>,
            unix_timestamp_seconds: Result<String, String>,
            value: Result<String, String>,
        }
        impl Default for MetadataInstantValue {
            fn default() -> Self {
                Self {
                    type_: Err("no value supplied for type_".to_string()),
                    unix_timestamp_seconds: Err(
                        "no value supplied for unix_timestamp_seconds".to_string(),
                    ),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl MetadataInstantValue {
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::MetadataInstantValueType>,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
            pub fn unix_timestamp_seconds<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.unix_timestamp_seconds = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for unix_timestamp_seconds: {}",
                            e
                        )
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<MetadataInstantValue>
        for super::MetadataInstantValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MetadataInstantValue,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    type_: value.type_?,
                    unix_timestamp_seconds: value.unix_timestamp_seconds?,
                    value: value.value?,
                })
            }
        }
        impl From<super::MetadataInstantValue> for MetadataInstantValue {
            fn from(value: super::MetadataInstantValue) -> Self {
                Self {
                    type_: Ok(value.type_),
                    unix_timestamp_seconds: Ok(value.unix_timestamp_seconds),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MetadataNonFungibleGlobalIdArrayValue {
            type_: Result<super::MetadataNonFungibleGlobalIdArrayValueType, String>,
            values: Result<
                Vec<super::MetadataNonFungibleGlobalIdArrayValueValuesItem>,
                String,
            >,
        }
        impl Default for MetadataNonFungibleGlobalIdArrayValue {
            fn default() -> Self {
                Self {
                    type_: Err("no value supplied for type_".to_string()),
                    values: Err("no value supplied for values".to_string()),
                }
            }
        }
        impl MetadataNonFungibleGlobalIdArrayValue {
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::MetadataNonFungibleGlobalIdArrayValueType,
                >,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
            pub fn values<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    Vec<super::MetadataNonFungibleGlobalIdArrayValueValuesItem>,
                >,
                T::Error: std::fmt::Display,
            {
                self.values = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for values: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<MetadataNonFungibleGlobalIdArrayValue>
        for super::MetadataNonFungibleGlobalIdArrayValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MetadataNonFungibleGlobalIdArrayValue,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    type_: value.type_?,
                    values: value.values?,
                })
            }
        }
        impl From<super::MetadataNonFungibleGlobalIdArrayValue>
        for MetadataNonFungibleGlobalIdArrayValue {
            fn from(value: super::MetadataNonFungibleGlobalIdArrayValue) -> Self {
                Self {
                    type_: Ok(value.type_),
                    values: Ok(value.values),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MetadataNonFungibleGlobalIdArrayValueValuesItem {
            non_fungible_id: Result<super::NonFungibleId, String>,
            resource_address: Result<super::Address, String>,
        }
        impl Default for MetadataNonFungibleGlobalIdArrayValueValuesItem {
            fn default() -> Self {
                Self {
                    non_fungible_id: Err(
                        "no value supplied for non_fungible_id".to_string(),
                    ),
                    resource_address: Err(
                        "no value supplied for resource_address".to_string(),
                    ),
                }
            }
        }
        impl MetadataNonFungibleGlobalIdArrayValueValuesItem {
            pub fn non_fungible_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::NonFungibleId>,
                T::Error: std::fmt::Display,
            {
                self.non_fungible_id = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for non_fungible_id: {}", e
                        )
                    });
                self
            }
            pub fn resource_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.resource_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_address: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<MetadataNonFungibleGlobalIdArrayValueValuesItem>
        for super::MetadataNonFungibleGlobalIdArrayValueValuesItem {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MetadataNonFungibleGlobalIdArrayValueValuesItem,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    non_fungible_id: value.non_fungible_id?,
                    resource_address: value.resource_address?,
                })
            }
        }
        impl From<super::MetadataNonFungibleGlobalIdArrayValueValuesItem>
        for MetadataNonFungibleGlobalIdArrayValueValuesItem {
            fn from(
                value: super::MetadataNonFungibleGlobalIdArrayValueValuesItem,
            ) -> Self {
                Self {
                    non_fungible_id: Ok(value.non_fungible_id),
                    resource_address: Ok(value.resource_address),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MetadataNonFungibleGlobalIdValue {
            non_fungible_id: Result<super::NonFungibleId, String>,
            resource_address: Result<super::Address, String>,
            type_: Result<super::MetadataNonFungibleGlobalIdValueType, String>,
        }
        impl Default for MetadataNonFungibleGlobalIdValue {
            fn default() -> Self {
                Self {
                    non_fungible_id: Err(
                        "no value supplied for non_fungible_id".to_string(),
                    ),
                    resource_address: Err(
                        "no value supplied for resource_address".to_string(),
                    ),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl MetadataNonFungibleGlobalIdValue {
            pub fn non_fungible_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::NonFungibleId>,
                T::Error: std::fmt::Display,
            {
                self.non_fungible_id = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for non_fungible_id: {}", e
                        )
                    });
                self
            }
            pub fn resource_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.resource_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_address: {}", e
                        )
                    });
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::MetadataNonFungibleGlobalIdValueType>,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<MetadataNonFungibleGlobalIdValue>
        for super::MetadataNonFungibleGlobalIdValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MetadataNonFungibleGlobalIdValue,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    non_fungible_id: value.non_fungible_id?,
                    resource_address: value.resource_address?,
                    type_: value.type_?,
                })
            }
        }
        impl From<super::MetadataNonFungibleGlobalIdValue>
        for MetadataNonFungibleGlobalIdValue {
            fn from(value: super::MetadataNonFungibleGlobalIdValue) -> Self {
                Self {
                    non_fungible_id: Ok(value.non_fungible_id),
                    resource_address: Ok(value.resource_address),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MetadataNonFungibleLocalIdArrayValue {
            type_: Result<super::MetadataNonFungibleLocalIdArrayValueType, String>,
            values: Result<Vec<String>, String>,
        }
        impl Default for MetadataNonFungibleLocalIdArrayValue {
            fn default() -> Self {
                Self {
                    type_: Err("no value supplied for type_".to_string()),
                    values: Err("no value supplied for values".to_string()),
                }
            }
        }
        impl MetadataNonFungibleLocalIdArrayValue {
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::MetadataNonFungibleLocalIdArrayValueType,
                >,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
            pub fn values<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<String>>,
                T::Error: std::fmt::Display,
            {
                self.values = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for values: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<MetadataNonFungibleLocalIdArrayValue>
        for super::MetadataNonFungibleLocalIdArrayValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MetadataNonFungibleLocalIdArrayValue,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    type_: value.type_?,
                    values: value.values?,
                })
            }
        }
        impl From<super::MetadataNonFungibleLocalIdArrayValue>
        for MetadataNonFungibleLocalIdArrayValue {
            fn from(value: super::MetadataNonFungibleLocalIdArrayValue) -> Self {
                Self {
                    type_: Ok(value.type_),
                    values: Ok(value.values),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MetadataNonFungibleLocalIdValue {
            type_: Result<super::MetadataNonFungibleLocalIdValueType, String>,
            value: Result<String, String>,
        }
        impl Default for MetadataNonFungibleLocalIdValue {
            fn default() -> Self {
                Self {
                    type_: Err("no value supplied for type_".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl MetadataNonFungibleLocalIdValue {
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::MetadataNonFungibleLocalIdValueType>,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<MetadataNonFungibleLocalIdValue>
        for super::MetadataNonFungibleLocalIdValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MetadataNonFungibleLocalIdValue,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    type_: value.type_?,
                    value: value.value?,
                })
            }
        }
        impl From<super::MetadataNonFungibleLocalIdValue>
        for MetadataNonFungibleLocalIdValue {
            fn from(value: super::MetadataNonFungibleLocalIdValue) -> Self {
                Self {
                    type_: Ok(value.type_),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MetadataOriginArrayValue {
            type_: Result<super::MetadataOriginArrayValueType, String>,
            values: Result<Vec<String>, String>,
        }
        impl Default for MetadataOriginArrayValue {
            fn default() -> Self {
                Self {
                    type_: Err("no value supplied for type_".to_string()),
                    values: Err("no value supplied for values".to_string()),
                }
            }
        }
        impl MetadataOriginArrayValue {
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::MetadataOriginArrayValueType>,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
            pub fn values<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<String>>,
                T::Error: std::fmt::Display,
            {
                self.values = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for values: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<MetadataOriginArrayValue>
        for super::MetadataOriginArrayValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MetadataOriginArrayValue,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    type_: value.type_?,
                    values: value.values?,
                })
            }
        }
        impl From<super::MetadataOriginArrayValue> for MetadataOriginArrayValue {
            fn from(value: super::MetadataOriginArrayValue) -> Self {
                Self {
                    type_: Ok(value.type_),
                    values: Ok(value.values),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MetadataOriginValue {
            type_: Result<super::MetadataOriginValueType, String>,
            value: Result<String, String>,
        }
        impl Default for MetadataOriginValue {
            fn default() -> Self {
                Self {
                    type_: Err("no value supplied for type_".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl MetadataOriginValue {
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::MetadataOriginValueType>,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<MetadataOriginValue> for super::MetadataOriginValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MetadataOriginValue,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    type_: value.type_?,
                    value: value.value?,
                })
            }
        }
        impl From<super::MetadataOriginValue> for MetadataOriginValue {
            fn from(value: super::MetadataOriginValue) -> Self {
                Self {
                    type_: Ok(value.type_),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MetadataPublicKeyArrayValue {
            type_: Result<super::MetadataPublicKeyArrayValueType, String>,
            values: Result<Vec<super::PublicKey>, String>,
        }
        impl Default for MetadataPublicKeyArrayValue {
            fn default() -> Self {
                Self {
                    type_: Err("no value supplied for type_".to_string()),
                    values: Err("no value supplied for values".to_string()),
                }
            }
        }
        impl MetadataPublicKeyArrayValue {
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::MetadataPublicKeyArrayValueType>,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
            pub fn values<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::PublicKey>>,
                T::Error: std::fmt::Display,
            {
                self.values = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for values: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<MetadataPublicKeyArrayValue>
        for super::MetadataPublicKeyArrayValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MetadataPublicKeyArrayValue,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    type_: value.type_?,
                    values: value.values?,
                })
            }
        }
        impl From<super::MetadataPublicKeyArrayValue> for MetadataPublicKeyArrayValue {
            fn from(value: super::MetadataPublicKeyArrayValue) -> Self {
                Self {
                    type_: Ok(value.type_),
                    values: Ok(value.values),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MetadataPublicKeyHashArrayValue {
            type_: Result<super::MetadataPublicKeyHashArrayValueType, String>,
            values: Result<Vec<super::PublicKeyHash>, String>,
        }
        impl Default for MetadataPublicKeyHashArrayValue {
            fn default() -> Self {
                Self {
                    type_: Err("no value supplied for type_".to_string()),
                    values: Err("no value supplied for values".to_string()),
                }
            }
        }
        impl MetadataPublicKeyHashArrayValue {
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::MetadataPublicKeyHashArrayValueType>,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
            pub fn values<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::PublicKeyHash>>,
                T::Error: std::fmt::Display,
            {
                self.values = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for values: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<MetadataPublicKeyHashArrayValue>
        for super::MetadataPublicKeyHashArrayValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MetadataPublicKeyHashArrayValue,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    type_: value.type_?,
                    values: value.values?,
                })
            }
        }
        impl From<super::MetadataPublicKeyHashArrayValue>
        for MetadataPublicKeyHashArrayValue {
            fn from(value: super::MetadataPublicKeyHashArrayValue) -> Self {
                Self {
                    type_: Ok(value.type_),
                    values: Ok(value.values),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MetadataPublicKeyHashValue {
            type_: Result<super::MetadataPublicKeyHashValueType, String>,
            value: Result<super::PublicKeyHash, String>,
        }
        impl Default for MetadataPublicKeyHashValue {
            fn default() -> Self {
                Self {
                    type_: Err("no value supplied for type_".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl MetadataPublicKeyHashValue {
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::MetadataPublicKeyHashValueType>,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::PublicKeyHash>,
                T::Error: std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<MetadataPublicKeyHashValue>
        for super::MetadataPublicKeyHashValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MetadataPublicKeyHashValue,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    type_: value.type_?,
                    value: value.value?,
                })
            }
        }
        impl From<super::MetadataPublicKeyHashValue> for MetadataPublicKeyHashValue {
            fn from(value: super::MetadataPublicKeyHashValue) -> Self {
                Self {
                    type_: Ok(value.type_),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MetadataPublicKeyValue {
            type_: Result<super::MetadataPublicKeyValueType, String>,
            value: Result<super::PublicKey, String>,
        }
        impl Default for MetadataPublicKeyValue {
            fn default() -> Self {
                Self {
                    type_: Err("no value supplied for type_".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl MetadataPublicKeyValue {
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::MetadataPublicKeyValueType>,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::PublicKey>,
                T::Error: std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<MetadataPublicKeyValue>
        for super::MetadataPublicKeyValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MetadataPublicKeyValue,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    type_: value.type_?,
                    value: value.value?,
                })
            }
        }
        impl From<super::MetadataPublicKeyValue> for MetadataPublicKeyValue {
            fn from(value: super::MetadataPublicKeyValue) -> Self {
                Self {
                    type_: Ok(value.type_),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MetadataStringArrayValue {
            type_: Result<super::MetadataStringArrayValueType, String>,
            values: Result<Vec<String>, String>,
        }
        impl Default for MetadataStringArrayValue {
            fn default() -> Self {
                Self {
                    type_: Err("no value supplied for type_".to_string()),
                    values: Err("no value supplied for values".to_string()),
                }
            }
        }
        impl MetadataStringArrayValue {
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::MetadataStringArrayValueType>,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
            pub fn values<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<String>>,
                T::Error: std::fmt::Display,
            {
                self.values = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for values: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<MetadataStringArrayValue>
        for super::MetadataStringArrayValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MetadataStringArrayValue,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    type_: value.type_?,
                    values: value.values?,
                })
            }
        }
        impl From<super::MetadataStringArrayValue> for MetadataStringArrayValue {
            fn from(value: super::MetadataStringArrayValue) -> Self {
                Self {
                    type_: Ok(value.type_),
                    values: Ok(value.values),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MetadataStringValue {
            type_: Result<super::MetadataStringValueType, String>,
            value: Result<String, String>,
        }
        impl Default for MetadataStringValue {
            fn default() -> Self {
                Self {
                    type_: Err("no value supplied for type_".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl MetadataStringValue {
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::MetadataStringValueType>,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<MetadataStringValue> for super::MetadataStringValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MetadataStringValue,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    type_: value.type_?,
                    value: value.value?,
                })
            }
        }
        impl From<super::MetadataStringValue> for MetadataStringValue {
            fn from(value: super::MetadataStringValue) -> Self {
                Self {
                    type_: Ok(value.type_),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MetadataTypedValueBase {
            type_: Result<super::MetadataValueType, String>,
        }
        impl Default for MetadataTypedValueBase {
            fn default() -> Self {
                Self {
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl MetadataTypedValueBase {
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::MetadataValueType>,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<MetadataTypedValueBase>
        for super::MetadataTypedValueBase {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MetadataTypedValueBase,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self { type_: value.type_? })
            }
        }
        impl From<super::MetadataTypedValueBase> for MetadataTypedValueBase {
            fn from(value: super::MetadataTypedValueBase) -> Self {
                Self { type_: Ok(value.type_) }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MetadataU32ArrayValue {
            type_: Result<super::MetadataU32ArrayValueType, String>,
            values: Result<Vec<String>, String>,
        }
        impl Default for MetadataU32ArrayValue {
            fn default() -> Self {
                Self {
                    type_: Err("no value supplied for type_".to_string()),
                    values: Err("no value supplied for values".to_string()),
                }
            }
        }
        impl MetadataU32ArrayValue {
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::MetadataU32ArrayValueType>,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
            pub fn values<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<String>>,
                T::Error: std::fmt::Display,
            {
                self.values = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for values: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<MetadataU32ArrayValue>
        for super::MetadataU32ArrayValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MetadataU32ArrayValue,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    type_: value.type_?,
                    values: value.values?,
                })
            }
        }
        impl From<super::MetadataU32ArrayValue> for MetadataU32ArrayValue {
            fn from(value: super::MetadataU32ArrayValue) -> Self {
                Self {
                    type_: Ok(value.type_),
                    values: Ok(value.values),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MetadataU32Value {
            type_: Result<super::MetadataU32ValueType, String>,
            value: Result<String, String>,
        }
        impl Default for MetadataU32Value {
            fn default() -> Self {
                Self {
                    type_: Err("no value supplied for type_".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl MetadataU32Value {
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::MetadataU32ValueType>,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<MetadataU32Value> for super::MetadataU32Value {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MetadataU32Value,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    type_: value.type_?,
                    value: value.value?,
                })
            }
        }
        impl From<super::MetadataU32Value> for MetadataU32Value {
            fn from(value: super::MetadataU32Value) -> Self {
                Self {
                    type_: Ok(value.type_),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MetadataU64ArrayValue {
            type_: Result<super::MetadataU64ArrayValueType, String>,
            values: Result<Vec<String>, String>,
        }
        impl Default for MetadataU64ArrayValue {
            fn default() -> Self {
                Self {
                    type_: Err("no value supplied for type_".to_string()),
                    values: Err("no value supplied for values".to_string()),
                }
            }
        }
        impl MetadataU64ArrayValue {
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::MetadataU64ArrayValueType>,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
            pub fn values<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<String>>,
                T::Error: std::fmt::Display,
            {
                self.values = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for values: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<MetadataU64ArrayValue>
        for super::MetadataU64ArrayValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MetadataU64ArrayValue,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    type_: value.type_?,
                    values: value.values?,
                })
            }
        }
        impl From<super::MetadataU64ArrayValue> for MetadataU64ArrayValue {
            fn from(value: super::MetadataU64ArrayValue) -> Self {
                Self {
                    type_: Ok(value.type_),
                    values: Ok(value.values),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MetadataU64Value {
            type_: Result<super::MetadataU64ValueType, String>,
            value: Result<String, String>,
        }
        impl Default for MetadataU64Value {
            fn default() -> Self {
                Self {
                    type_: Err("no value supplied for type_".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl MetadataU64Value {
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::MetadataU64ValueType>,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<MetadataU64Value> for super::MetadataU64Value {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MetadataU64Value,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    type_: value.type_?,
                    value: value.value?,
                })
            }
        }
        impl From<super::MetadataU64Value> for MetadataU64Value {
            fn from(value: super::MetadataU64Value) -> Self {
                Self {
                    type_: Ok(value.type_),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MetadataU8ArrayValue {
            type_: Result<super::MetadataU8ArrayValueType, String>,
            value_hex: Result<String, String>,
        }
        impl Default for MetadataU8ArrayValue {
            fn default() -> Self {
                Self {
                    type_: Err("no value supplied for type_".to_string()),
                    value_hex: Err("no value supplied for value_hex".to_string()),
                }
            }
        }
        impl MetadataU8ArrayValue {
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::MetadataU8ArrayValueType>,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
            pub fn value_hex<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.value_hex = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value_hex: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<MetadataU8ArrayValue>
        for super::MetadataU8ArrayValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MetadataU8ArrayValue,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    type_: value.type_?,
                    value_hex: value.value_hex?,
                })
            }
        }
        impl From<super::MetadataU8ArrayValue> for MetadataU8ArrayValue {
            fn from(value: super::MetadataU8ArrayValue) -> Self {
                Self {
                    type_: Ok(value.type_),
                    value_hex: Ok(value.value_hex),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MetadataU8Value {
            type_: Result<super::MetadataU8ValueType, String>,
            value: Result<String, String>,
        }
        impl Default for MetadataU8Value {
            fn default() -> Self {
                Self {
                    type_: Err("no value supplied for type_".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl MetadataU8Value {
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::MetadataU8ValueType>,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<MetadataU8Value> for super::MetadataU8Value {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MetadataU8Value,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    type_: value.type_?,
                    value: value.value?,
                })
            }
        }
        impl From<super::MetadataU8Value> for MetadataU8Value {
            fn from(value: super::MetadataU8Value) -> Self {
                Self {
                    type_: Ok(value.type_),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MetadataUrlArrayValue {
            type_: Result<super::MetadataUrlArrayValueType, String>,
            values: Result<Vec<String>, String>,
        }
        impl Default for MetadataUrlArrayValue {
            fn default() -> Self {
                Self {
                    type_: Err("no value supplied for type_".to_string()),
                    values: Err("no value supplied for values".to_string()),
                }
            }
        }
        impl MetadataUrlArrayValue {
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::MetadataUrlArrayValueType>,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
            pub fn values<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<String>>,
                T::Error: std::fmt::Display,
            {
                self.values = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for values: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<MetadataUrlArrayValue>
        for super::MetadataUrlArrayValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MetadataUrlArrayValue,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    type_: value.type_?,
                    values: value.values?,
                })
            }
        }
        impl From<super::MetadataUrlArrayValue> for MetadataUrlArrayValue {
            fn from(value: super::MetadataUrlArrayValue) -> Self {
                Self {
                    type_: Ok(value.type_),
                    values: Ok(value.values),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MetadataUrlValue {
            type_: Result<super::MetadataUrlValueType, String>,
            value: Result<String, String>,
        }
        impl Default for MetadataUrlValue {
            fn default() -> Self {
                Self {
                    type_: Err("no value supplied for type_".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl MetadataUrlValue {
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::MetadataUrlValueType>,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<MetadataUrlValue> for super::MetadataUrlValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MetadataUrlValue,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    type_: value.type_?,
                    value: value.value?,
                })
            }
        }
        impl From<super::MetadataUrlValue> for MetadataUrlValue {
            fn from(value: super::MetadataUrlValue) -> Self {
                Self {
                    type_: Ok(value.type_),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct NativeResourceAccessControllerRecoveryBadgeValue {
            access_controller_address: Result<super::Address, String>,
            kind: Result<
                super::NativeResourceAccessControllerRecoveryBadgeValueKind,
                String,
            >,
        }
        impl Default for NativeResourceAccessControllerRecoveryBadgeValue {
            fn default() -> Self {
                Self {
                    access_controller_address: Err(
                        "no value supplied for access_controller_address".to_string(),
                    ),
                    kind: Err("no value supplied for kind".to_string()),
                }
            }
        }
        impl NativeResourceAccessControllerRecoveryBadgeValue {
            pub fn access_controller_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.access_controller_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for access_controller_address: {}",
                            e
                        )
                    });
                self
            }
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::NativeResourceAccessControllerRecoveryBadgeValueKind,
                >,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for kind: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<NativeResourceAccessControllerRecoveryBadgeValue>
        for super::NativeResourceAccessControllerRecoveryBadgeValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: NativeResourceAccessControllerRecoveryBadgeValue,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    access_controller_address: value.access_controller_address?,
                    kind: value.kind?,
                })
            }
        }
        impl From<super::NativeResourceAccessControllerRecoveryBadgeValue>
        for NativeResourceAccessControllerRecoveryBadgeValue {
            fn from(
                value: super::NativeResourceAccessControllerRecoveryBadgeValue,
            ) -> Self {
                Self {
                    access_controller_address: Ok(value.access_controller_address),
                    kind: Ok(value.kind),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct NativeResourceAccountOwnerBadgeValue {
            kind: Result<super::NativeResourceAccountOwnerBadgeValueKind, String>,
        }
        impl Default for NativeResourceAccountOwnerBadgeValue {
            fn default() -> Self {
                Self {
                    kind: Err("no value supplied for kind".to_string()),
                }
            }
        }
        impl NativeResourceAccountOwnerBadgeValue {
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::NativeResourceAccountOwnerBadgeValueKind,
                >,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for kind: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<NativeResourceAccountOwnerBadgeValue>
        for super::NativeResourceAccountOwnerBadgeValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: NativeResourceAccountOwnerBadgeValue,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self { kind: value.kind? })
            }
        }
        impl From<super::NativeResourceAccountOwnerBadgeValue>
        for NativeResourceAccountOwnerBadgeValue {
            fn from(value: super::NativeResourceAccountOwnerBadgeValue) -> Self {
                Self { kind: Ok(value.kind) }
            }
        }
        #[derive(Clone, Debug)]
        pub struct NativeResourceDetailsBase {
            kind: Result<super::NativeResourceKind, String>,
        }
        impl Default for NativeResourceDetailsBase {
            fn default() -> Self {
                Self {
                    kind: Err("no value supplied for kind".to_string()),
                }
            }
        }
        impl NativeResourceDetailsBase {
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::NativeResourceKind>,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for kind: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<NativeResourceDetailsBase>
        for super::NativeResourceDetailsBase {
            type Error = super::error::ConversionError;
            fn try_from(
                value: NativeResourceDetailsBase,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self { kind: value.kind? })
            }
        }
        impl From<super::NativeResourceDetailsBase> for NativeResourceDetailsBase {
            fn from(value: super::NativeResourceDetailsBase) -> Self {
                Self { kind: Ok(value.kind) }
            }
        }
        #[derive(Clone, Debug)]
        pub struct NativeResourceEd25519SignatureResourceValue {
            kind: Result<super::NativeResourceEd25519SignatureResourceValueKind, String>,
        }
        impl Default for NativeResourceEd25519SignatureResourceValue {
            fn default() -> Self {
                Self {
                    kind: Err("no value supplied for kind".to_string()),
                }
            }
        }
        impl NativeResourceEd25519SignatureResourceValue {
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::NativeResourceEd25519SignatureResourceValueKind,
                >,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for kind: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<NativeResourceEd25519SignatureResourceValue>
        for super::NativeResourceEd25519SignatureResourceValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: NativeResourceEd25519SignatureResourceValue,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self { kind: value.kind? })
            }
        }
        impl From<super::NativeResourceEd25519SignatureResourceValue>
        for NativeResourceEd25519SignatureResourceValue {
            fn from(value: super::NativeResourceEd25519SignatureResourceValue) -> Self {
                Self { kind: Ok(value.kind) }
            }
        }
        #[derive(Clone, Debug)]
        pub struct NativeResourceGlobalCallerResourceValue {
            kind: Result<super::NativeResourceGlobalCallerResourceValueKind, String>,
        }
        impl Default for NativeResourceGlobalCallerResourceValue {
            fn default() -> Self {
                Self {
                    kind: Err("no value supplied for kind".to_string()),
                }
            }
        }
        impl NativeResourceGlobalCallerResourceValue {
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::NativeResourceGlobalCallerResourceValueKind,
                >,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for kind: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<NativeResourceGlobalCallerResourceValue>
        for super::NativeResourceGlobalCallerResourceValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: NativeResourceGlobalCallerResourceValue,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self { kind: value.kind? })
            }
        }
        impl From<super::NativeResourceGlobalCallerResourceValue>
        for NativeResourceGlobalCallerResourceValue {
            fn from(value: super::NativeResourceGlobalCallerResourceValue) -> Self {
                Self { kind: Ok(value.kind) }
            }
        }
        #[derive(Clone, Debug)]
        pub struct NativeResourceIdentityOwnerBadgeValue {
            kind: Result<super::NativeResourceIdentityOwnerBadgeValueKind, String>,
        }
        impl Default for NativeResourceIdentityOwnerBadgeValue {
            fn default() -> Self {
                Self {
                    kind: Err("no value supplied for kind".to_string()),
                }
            }
        }
        impl NativeResourceIdentityOwnerBadgeValue {
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::NativeResourceIdentityOwnerBadgeValueKind,
                >,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for kind: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<NativeResourceIdentityOwnerBadgeValue>
        for super::NativeResourceIdentityOwnerBadgeValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: NativeResourceIdentityOwnerBadgeValue,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self { kind: value.kind? })
            }
        }
        impl From<super::NativeResourceIdentityOwnerBadgeValue>
        for NativeResourceIdentityOwnerBadgeValue {
            fn from(value: super::NativeResourceIdentityOwnerBadgeValue) -> Self {
                Self { kind: Ok(value.kind) }
            }
        }
        #[derive(Clone, Debug)]
        pub struct NativeResourceMultiResourcePoolUnitValue {
            kind: Result<super::NativeResourceMultiResourcePoolUnitValueKind, String>,
            pool_address: Result<super::Address, String>,
            redemption_resource_count: Result<i64, String>,
            unit_redemption_value: Result<
                super::NativeResourceUnitRedemptionValue,
                String,
            >,
        }
        impl Default for NativeResourceMultiResourcePoolUnitValue {
            fn default() -> Self {
                Self {
                    kind: Err("no value supplied for kind".to_string()),
                    pool_address: Err("no value supplied for pool_address".to_string()),
                    redemption_resource_count: Err(
                        "no value supplied for redemption_resource_count".to_string(),
                    ),
                    unit_redemption_value: Err(
                        "no value supplied for unit_redemption_value".to_string(),
                    ),
                }
            }
        }
        impl NativeResourceMultiResourcePoolUnitValue {
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::NativeResourceMultiResourcePoolUnitValueKind,
                >,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for kind: {}", e)
                    });
                self
            }
            pub fn pool_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.pool_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for pool_address: {}", e
                        )
                    });
                self
            }
            pub fn redemption_resource_count<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<i64>,
                T::Error: std::fmt::Display,
            {
                self.redemption_resource_count = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for redemption_resource_count: {}",
                            e
                        )
                    });
                self
            }
            pub fn unit_redemption_value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::NativeResourceUnitRedemptionValue>,
                T::Error: std::fmt::Display,
            {
                self.unit_redemption_value = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for unit_redemption_value: {}",
                            e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<NativeResourceMultiResourcePoolUnitValue>
        for super::NativeResourceMultiResourcePoolUnitValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: NativeResourceMultiResourcePoolUnitValue,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    kind: value.kind?,
                    pool_address: value.pool_address?,
                    redemption_resource_count: value.redemption_resource_count?,
                    unit_redemption_value: value.unit_redemption_value?,
                })
            }
        }
        impl From<super::NativeResourceMultiResourcePoolUnitValue>
        for NativeResourceMultiResourcePoolUnitValue {
            fn from(value: super::NativeResourceMultiResourcePoolUnitValue) -> Self {
                Self {
                    kind: Ok(value.kind),
                    pool_address: Ok(value.pool_address),
                    redemption_resource_count: Ok(value.redemption_resource_count),
                    unit_redemption_value: Ok(value.unit_redemption_value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct NativeResourceOneResourcePoolUnitValue {
            kind: Result<super::NativeResourceOneResourcePoolUnitValueKind, String>,
            pool_address: Result<super::Address, String>,
            redemption_resource_count: Result<i64, String>,
            unit_redemption_value: Result<
                super::NativeResourceUnitRedemptionValue,
                String,
            >,
        }
        impl Default for NativeResourceOneResourcePoolUnitValue {
            fn default() -> Self {
                Self {
                    kind: Err("no value supplied for kind".to_string()),
                    pool_address: Err("no value supplied for pool_address".to_string()),
                    redemption_resource_count: Err(
                        "no value supplied for redemption_resource_count".to_string(),
                    ),
                    unit_redemption_value: Err(
                        "no value supplied for unit_redemption_value".to_string(),
                    ),
                }
            }
        }
        impl NativeResourceOneResourcePoolUnitValue {
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::NativeResourceOneResourcePoolUnitValueKind,
                >,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for kind: {}", e)
                    });
                self
            }
            pub fn pool_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.pool_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for pool_address: {}", e
                        )
                    });
                self
            }
            pub fn redemption_resource_count<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<i64>,
                T::Error: std::fmt::Display,
            {
                self.redemption_resource_count = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for redemption_resource_count: {}",
                            e
                        )
                    });
                self
            }
            pub fn unit_redemption_value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::NativeResourceUnitRedemptionValue>,
                T::Error: std::fmt::Display,
            {
                self.unit_redemption_value = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for unit_redemption_value: {}",
                            e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<NativeResourceOneResourcePoolUnitValue>
        for super::NativeResourceOneResourcePoolUnitValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: NativeResourceOneResourcePoolUnitValue,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    kind: value.kind?,
                    pool_address: value.pool_address?,
                    redemption_resource_count: value.redemption_resource_count?,
                    unit_redemption_value: value.unit_redemption_value?,
                })
            }
        }
        impl From<super::NativeResourceOneResourcePoolUnitValue>
        for NativeResourceOneResourcePoolUnitValue {
            fn from(value: super::NativeResourceOneResourcePoolUnitValue) -> Self {
                Self {
                    kind: Ok(value.kind),
                    pool_address: Ok(value.pool_address),
                    redemption_resource_count: Ok(value.redemption_resource_count),
                    unit_redemption_value: Ok(value.unit_redemption_value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct NativeResourcePackageOfDirectCallerResourceValue {
            kind: Result<
                super::NativeResourcePackageOfDirectCallerResourceValueKind,
                String,
            >,
        }
        impl Default for NativeResourcePackageOfDirectCallerResourceValue {
            fn default() -> Self {
                Self {
                    kind: Err("no value supplied for kind".to_string()),
                }
            }
        }
        impl NativeResourcePackageOfDirectCallerResourceValue {
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::NativeResourcePackageOfDirectCallerResourceValueKind,
                >,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for kind: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<NativeResourcePackageOfDirectCallerResourceValue>
        for super::NativeResourcePackageOfDirectCallerResourceValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: NativeResourcePackageOfDirectCallerResourceValue,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self { kind: value.kind? })
            }
        }
        impl From<super::NativeResourcePackageOfDirectCallerResourceValue>
        for NativeResourcePackageOfDirectCallerResourceValue {
            fn from(
                value: super::NativeResourcePackageOfDirectCallerResourceValue,
            ) -> Self {
                Self { kind: Ok(value.kind) }
            }
        }
        #[derive(Clone, Debug)]
        pub struct NativeResourcePackageOwnerBadgeValue {
            kind: Result<super::NativeResourcePackageOwnerBadgeValueKind, String>,
        }
        impl Default for NativeResourcePackageOwnerBadgeValue {
            fn default() -> Self {
                Self {
                    kind: Err("no value supplied for kind".to_string()),
                }
            }
        }
        impl NativeResourcePackageOwnerBadgeValue {
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::NativeResourcePackageOwnerBadgeValueKind,
                >,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for kind: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<NativeResourcePackageOwnerBadgeValue>
        for super::NativeResourcePackageOwnerBadgeValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: NativeResourcePackageOwnerBadgeValue,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self { kind: value.kind? })
            }
        }
        impl From<super::NativeResourcePackageOwnerBadgeValue>
        for NativeResourcePackageOwnerBadgeValue {
            fn from(value: super::NativeResourcePackageOwnerBadgeValue) -> Self {
                Self { kind: Ok(value.kind) }
            }
        }
        #[derive(Clone, Debug)]
        pub struct NativeResourceRedemptionValueItem {
            amount: Result<Option<super::BigDecimal>, String>,
            resource_address: Result<super::Address, String>,
        }
        impl Default for NativeResourceRedemptionValueItem {
            fn default() -> Self {
                Self {
                    amount: Ok(Default::default()),
                    resource_address: Err(
                        "no value supplied for resource_address".to_string(),
                    ),
                }
            }
        }
        impl NativeResourceRedemptionValueItem {
            pub fn amount<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::BigDecimal>>,
                T::Error: std::fmt::Display,
            {
                self.amount = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for amount: {}", e)
                    });
                self
            }
            pub fn resource_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.resource_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_address: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<NativeResourceRedemptionValueItem>
        for super::NativeResourceRedemptionValueItem {
            type Error = super::error::ConversionError;
            fn try_from(
                value: NativeResourceRedemptionValueItem,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    amount: value.amount?,
                    resource_address: value.resource_address?,
                })
            }
        }
        impl From<super::NativeResourceRedemptionValueItem>
        for NativeResourceRedemptionValueItem {
            fn from(value: super::NativeResourceRedemptionValueItem) -> Self {
                Self {
                    amount: Ok(value.amount),
                    resource_address: Ok(value.resource_address),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct NativeResourceSecp256k1SignatureResourceValue {
            kind: Result<
                super::NativeResourceSecp256k1SignatureResourceValueKind,
                String,
            >,
        }
        impl Default for NativeResourceSecp256k1SignatureResourceValue {
            fn default() -> Self {
                Self {
                    kind: Err("no value supplied for kind".to_string()),
                }
            }
        }
        impl NativeResourceSecp256k1SignatureResourceValue {
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::NativeResourceSecp256k1SignatureResourceValueKind,
                >,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for kind: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<NativeResourceSecp256k1SignatureResourceValue>
        for super::NativeResourceSecp256k1SignatureResourceValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: NativeResourceSecp256k1SignatureResourceValue,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self { kind: value.kind? })
            }
        }
        impl From<super::NativeResourceSecp256k1SignatureResourceValue>
        for NativeResourceSecp256k1SignatureResourceValue {
            fn from(
                value: super::NativeResourceSecp256k1SignatureResourceValue,
            ) -> Self {
                Self { kind: Ok(value.kind) }
            }
        }
        #[derive(Clone, Debug)]
        pub struct NativeResourceSystemExecutionResourceValue {
            kind: Result<super::NativeResourceSystemExecutionResourceValueKind, String>,
        }
        impl Default for NativeResourceSystemExecutionResourceValue {
            fn default() -> Self {
                Self {
                    kind: Err("no value supplied for kind".to_string()),
                }
            }
        }
        impl NativeResourceSystemExecutionResourceValue {
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::NativeResourceSystemExecutionResourceValueKind,
                >,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for kind: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<NativeResourceSystemExecutionResourceValue>
        for super::NativeResourceSystemExecutionResourceValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: NativeResourceSystemExecutionResourceValue,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self { kind: value.kind? })
            }
        }
        impl From<super::NativeResourceSystemExecutionResourceValue>
        for NativeResourceSystemExecutionResourceValue {
            fn from(value: super::NativeResourceSystemExecutionResourceValue) -> Self {
                Self { kind: Ok(value.kind) }
            }
        }
        #[derive(Clone, Debug)]
        pub struct NativeResourceTwoResourcePoolUnitValue {
            kind: Result<super::NativeResourceTwoResourcePoolUnitValueKind, String>,
            pool_address: Result<super::Address, String>,
            redemption_resource_count: Result<i64, String>,
            unit_redemption_value: Result<
                super::NativeResourceUnitRedemptionValue,
                String,
            >,
        }
        impl Default for NativeResourceTwoResourcePoolUnitValue {
            fn default() -> Self {
                Self {
                    kind: Err("no value supplied for kind".to_string()),
                    pool_address: Err("no value supplied for pool_address".to_string()),
                    redemption_resource_count: Err(
                        "no value supplied for redemption_resource_count".to_string(),
                    ),
                    unit_redemption_value: Err(
                        "no value supplied for unit_redemption_value".to_string(),
                    ),
                }
            }
        }
        impl NativeResourceTwoResourcePoolUnitValue {
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::NativeResourceTwoResourcePoolUnitValueKind,
                >,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for kind: {}", e)
                    });
                self
            }
            pub fn pool_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.pool_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for pool_address: {}", e
                        )
                    });
                self
            }
            pub fn redemption_resource_count<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<i64>,
                T::Error: std::fmt::Display,
            {
                self.redemption_resource_count = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for redemption_resource_count: {}",
                            e
                        )
                    });
                self
            }
            pub fn unit_redemption_value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::NativeResourceUnitRedemptionValue>,
                T::Error: std::fmt::Display,
            {
                self.unit_redemption_value = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for unit_redemption_value: {}",
                            e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<NativeResourceTwoResourcePoolUnitValue>
        for super::NativeResourceTwoResourcePoolUnitValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: NativeResourceTwoResourcePoolUnitValue,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    kind: value.kind?,
                    pool_address: value.pool_address?,
                    redemption_resource_count: value.redemption_resource_count?,
                    unit_redemption_value: value.unit_redemption_value?,
                })
            }
        }
        impl From<super::NativeResourceTwoResourcePoolUnitValue>
        for NativeResourceTwoResourcePoolUnitValue {
            fn from(value: super::NativeResourceTwoResourcePoolUnitValue) -> Self {
                Self {
                    kind: Ok(value.kind),
                    pool_address: Ok(value.pool_address),
                    redemption_resource_count: Ok(value.redemption_resource_count),
                    unit_redemption_value: Ok(value.unit_redemption_value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct NativeResourceValidatorClaimNftValue {
            kind: Result<super::NativeResourceValidatorClaimNftValueKind, String>,
            validator_address: Result<super::Address, String>,
        }
        impl Default for NativeResourceValidatorClaimNftValue {
            fn default() -> Self {
                Self {
                    kind: Err("no value supplied for kind".to_string()),
                    validator_address: Err(
                        "no value supplied for validator_address".to_string(),
                    ),
                }
            }
        }
        impl NativeResourceValidatorClaimNftValue {
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::NativeResourceValidatorClaimNftValueKind,
                >,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for kind: {}", e)
                    });
                self
            }
            pub fn validator_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.validator_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for validator_address: {}",
                            e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<NativeResourceValidatorClaimNftValue>
        for super::NativeResourceValidatorClaimNftValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: NativeResourceValidatorClaimNftValue,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    kind: value.kind?,
                    validator_address: value.validator_address?,
                })
            }
        }
        impl From<super::NativeResourceValidatorClaimNftValue>
        for NativeResourceValidatorClaimNftValue {
            fn from(value: super::NativeResourceValidatorClaimNftValue) -> Self {
                Self {
                    kind: Ok(value.kind),
                    validator_address: Ok(value.validator_address),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct NativeResourceValidatorLiquidStakeUnitValue {
            kind: Result<super::NativeResourceValidatorLiquidStakeUnitValueKind, String>,
            redemption_resource_count: Result<i64, String>,
            unit_redemption_value: Result<
                super::NativeResourceUnitRedemptionValue,
                String,
            >,
            validator_address: Result<super::Address, String>,
        }
        impl Default for NativeResourceValidatorLiquidStakeUnitValue {
            fn default() -> Self {
                Self {
                    kind: Err("no value supplied for kind".to_string()),
                    redemption_resource_count: Err(
                        "no value supplied for redemption_resource_count".to_string(),
                    ),
                    unit_redemption_value: Err(
                        "no value supplied for unit_redemption_value".to_string(),
                    ),
                    validator_address: Err(
                        "no value supplied for validator_address".to_string(),
                    ),
                }
            }
        }
        impl NativeResourceValidatorLiquidStakeUnitValue {
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::NativeResourceValidatorLiquidStakeUnitValueKind,
                >,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for kind: {}", e)
                    });
                self
            }
            pub fn redemption_resource_count<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<i64>,
                T::Error: std::fmt::Display,
            {
                self.redemption_resource_count = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for redemption_resource_count: {}",
                            e
                        )
                    });
                self
            }
            pub fn unit_redemption_value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::NativeResourceUnitRedemptionValue>,
                T::Error: std::fmt::Display,
            {
                self.unit_redemption_value = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for unit_redemption_value: {}",
                            e
                        )
                    });
                self
            }
            pub fn validator_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.validator_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for validator_address: {}",
                            e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<NativeResourceValidatorLiquidStakeUnitValue>
        for super::NativeResourceValidatorLiquidStakeUnitValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: NativeResourceValidatorLiquidStakeUnitValue,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    kind: value.kind?,
                    redemption_resource_count: value.redemption_resource_count?,
                    unit_redemption_value: value.unit_redemption_value?,
                    validator_address: value.validator_address?,
                })
            }
        }
        impl From<super::NativeResourceValidatorLiquidStakeUnitValue>
        for NativeResourceValidatorLiquidStakeUnitValue {
            fn from(value: super::NativeResourceValidatorLiquidStakeUnitValue) -> Self {
                Self {
                    kind: Ok(value.kind),
                    redemption_resource_count: Ok(value.redemption_resource_count),
                    unit_redemption_value: Ok(value.unit_redemption_value),
                    validator_address: Ok(value.validator_address),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct NativeResourceValidatorOwnerBadgeValue {
            kind: Result<super::NativeResourceValidatorOwnerBadgeValueKind, String>,
        }
        impl Default for NativeResourceValidatorOwnerBadgeValue {
            fn default() -> Self {
                Self {
                    kind: Err("no value supplied for kind".to_string()),
                }
            }
        }
        impl NativeResourceValidatorOwnerBadgeValue {
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::NativeResourceValidatorOwnerBadgeValueKind,
                >,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for kind: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<NativeResourceValidatorOwnerBadgeValue>
        for super::NativeResourceValidatorOwnerBadgeValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: NativeResourceValidatorOwnerBadgeValue,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self { kind: value.kind? })
            }
        }
        impl From<super::NativeResourceValidatorOwnerBadgeValue>
        for NativeResourceValidatorOwnerBadgeValue {
            fn from(value: super::NativeResourceValidatorOwnerBadgeValue) -> Self {
                Self { kind: Ok(value.kind) }
            }
        }
        #[derive(Clone, Debug)]
        pub struct NativeResourceXrdValue {
            kind: Result<super::NativeResourceXrdValueKind, String>,
        }
        impl Default for NativeResourceXrdValue {
            fn default() -> Self {
                Self {
                    kind: Err("no value supplied for kind".to_string()),
                }
            }
        }
        impl NativeResourceXrdValue {
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::NativeResourceXrdValueKind>,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for kind: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<NativeResourceXrdValue>
        for super::NativeResourceXrdValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: NativeResourceXrdValue,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self { kind: value.kind? })
            }
        }
        impl From<super::NativeResourceXrdValue> for NativeResourceXrdValue {
            fn from(value: super::NativeResourceXrdValue) -> Self {
                Self { kind: Ok(value.kind) }
            }
        }
        #[derive(Clone, Debug)]
        pub struct NetworkConfigurationResponse {
            network_id: Result<super::NetworkId, String>,
            network_name: Result<super::NetworkName, String>,
            well_known_addresses: Result<
                super::NetworkConfigurationResponseWellKnownAddresses,
                String,
            >,
        }
        impl Default for NetworkConfigurationResponse {
            fn default() -> Self {
                Self {
                    network_id: Err("no value supplied for network_id".to_string()),
                    network_name: Err("no value supplied for network_name".to_string()),
                    well_known_addresses: Err(
                        "no value supplied for well_known_addresses".to_string(),
                    ),
                }
            }
        }
        impl NetworkConfigurationResponse {
            pub fn network_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::NetworkId>,
                T::Error: std::fmt::Display,
            {
                self.network_id = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for network_id: {}", e)
                    });
                self
            }
            pub fn network_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::NetworkName>,
                T::Error: std::fmt::Display,
            {
                self.network_name = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for network_name: {}", e
                        )
                    });
                self
            }
            pub fn well_known_addresses<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::NetworkConfigurationResponseWellKnownAddresses,
                >,
                T::Error: std::fmt::Display,
            {
                self.well_known_addresses = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for well_known_addresses: {}",
                            e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<NetworkConfigurationResponse>
        for super::NetworkConfigurationResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: NetworkConfigurationResponse,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    network_id: value.network_id?,
                    network_name: value.network_name?,
                    well_known_addresses: value.well_known_addresses?,
                })
            }
        }
        impl From<super::NetworkConfigurationResponse> for NetworkConfigurationResponse {
            fn from(value: super::NetworkConfigurationResponse) -> Self {
                Self {
                    network_id: Ok(value.network_id),
                    network_name: Ok(value.network_name),
                    well_known_addresses: Ok(value.well_known_addresses),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct NetworkConfigurationResponseWellKnownAddresses {
            access_controller_package: Result<super::Address, String>,
            access_rules_package: Result<super::Address, String>,
            account_owner_badge: Result<super::Address, String>,
            account_package: Result<super::Address, String>,
            consensus_manager: Result<super::Address, String>,
            consensus_manager_package: Result<super::Address, String>,
            ed25519_signature_virtual_badge: Result<super::Address, String>,
            faucet: Result<super::Address, String>,
            faucet_package: Result<super::Address, String>,
            genesis_helper: Result<super::Address, String>,
            genesis_helper_package: Result<super::Address, String>,
            global_caller_virtual_badge: Result<super::Address, String>,
            identity_owner_badge: Result<super::Address, String>,
            identity_package: Result<super::Address, String>,
            locker_package: Result<super::Address, String>,
            metadata_module_package: Result<super::Address, String>,
            package_of_direct_caller_virtual_badge: Result<super::Address, String>,
            package_owner_badge: Result<super::Address, String>,
            package_package: Result<super::Address, String>,
            pool_package: Result<super::Address, String>,
            resource_package: Result<super::Address, String>,
            role_assignment_module_package: Result<super::Address, String>,
            royalty_module_package: Result<super::Address, String>,
            secp256k1_signature_virtual_badge: Result<super::Address, String>,
            system_transaction_badge: Result<super::Address, String>,
            test_utils_package: Result<Option<super::Address>, String>,
            transaction_processor_package: Result<super::Address, String>,
            transaction_tracker: Result<super::Address, String>,
            transaction_tracker_package: Result<Option<super::Address>, String>,
            validator_owner_badge: Result<super::Address, String>,
            xrd: Result<super::Address, String>,
        }
        impl Default for NetworkConfigurationResponseWellKnownAddresses {
            fn default() -> Self {
                Self {
                    access_controller_package: Err(
                        "no value supplied for access_controller_package".to_string(),
                    ),
                    access_rules_package: Err(
                        "no value supplied for access_rules_package".to_string(),
                    ),
                    account_owner_badge: Err(
                        "no value supplied for account_owner_badge".to_string(),
                    ),
                    account_package: Err(
                        "no value supplied for account_package".to_string(),
                    ),
                    consensus_manager: Err(
                        "no value supplied for consensus_manager".to_string(),
                    ),
                    consensus_manager_package: Err(
                        "no value supplied for consensus_manager_package".to_string(),
                    ),
                    ed25519_signature_virtual_badge: Err(
                        "no value supplied for ed25519_signature_virtual_badge"
                            .to_string(),
                    ),
                    faucet: Err("no value supplied for faucet".to_string()),
                    faucet_package: Err(
                        "no value supplied for faucet_package".to_string(),
                    ),
                    genesis_helper: Err(
                        "no value supplied for genesis_helper".to_string(),
                    ),
                    genesis_helper_package: Err(
                        "no value supplied for genesis_helper_package".to_string(),
                    ),
                    global_caller_virtual_badge: Err(
                        "no value supplied for global_caller_virtual_badge".to_string(),
                    ),
                    identity_owner_badge: Err(
                        "no value supplied for identity_owner_badge".to_string(),
                    ),
                    identity_package: Err(
                        "no value supplied for identity_package".to_string(),
                    ),
                    locker_package: Err(
                        "no value supplied for locker_package".to_string(),
                    ),
                    metadata_module_package: Err(
                        "no value supplied for metadata_module_package".to_string(),
                    ),
                    package_of_direct_caller_virtual_badge: Err(
                        "no value supplied for package_of_direct_caller_virtual_badge"
                            .to_string(),
                    ),
                    package_owner_badge: Err(
                        "no value supplied for package_owner_badge".to_string(),
                    ),
                    package_package: Err(
                        "no value supplied for package_package".to_string(),
                    ),
                    pool_package: Err("no value supplied for pool_package".to_string()),
                    resource_package: Err(
                        "no value supplied for resource_package".to_string(),
                    ),
                    role_assignment_module_package: Err(
                        "no value supplied for role_assignment_module_package"
                            .to_string(),
                    ),
                    royalty_module_package: Err(
                        "no value supplied for royalty_module_package".to_string(),
                    ),
                    secp256k1_signature_virtual_badge: Err(
                        "no value supplied for secp256k1_signature_virtual_badge"
                            .to_string(),
                    ),
                    system_transaction_badge: Err(
                        "no value supplied for system_transaction_badge".to_string(),
                    ),
                    test_utils_package: Ok(Default::default()),
                    transaction_processor_package: Err(
                        "no value supplied for transaction_processor_package".to_string(),
                    ),
                    transaction_tracker: Err(
                        "no value supplied for transaction_tracker".to_string(),
                    ),
                    transaction_tracker_package: Ok(Default::default()),
                    validator_owner_badge: Err(
                        "no value supplied for validator_owner_badge".to_string(),
                    ),
                    xrd: Err("no value supplied for xrd".to_string()),
                }
            }
        }
        impl NetworkConfigurationResponseWellKnownAddresses {
            pub fn access_controller_package<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.access_controller_package = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for access_controller_package: {}",
                            e
                        )
                    });
                self
            }
            pub fn access_rules_package<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.access_rules_package = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for access_rules_package: {}",
                            e
                        )
                    });
                self
            }
            pub fn account_owner_badge<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.account_owner_badge = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for account_owner_badge: {}",
                            e
                        )
                    });
                self
            }
            pub fn account_package<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.account_package = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for account_package: {}", e
                        )
                    });
                self
            }
            pub fn consensus_manager<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.consensus_manager = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for consensus_manager: {}",
                            e
                        )
                    });
                self
            }
            pub fn consensus_manager_package<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.consensus_manager_package = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for consensus_manager_package: {}",
                            e
                        )
                    });
                self
            }
            pub fn ed25519_signature_virtual_badge<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.ed25519_signature_virtual_badge = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for ed25519_signature_virtual_badge: {}",
                            e
                        )
                    });
                self
            }
            pub fn faucet<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.faucet = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for faucet: {}", e)
                    });
                self
            }
            pub fn faucet_package<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.faucet_package = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for faucet_package: {}", e
                        )
                    });
                self
            }
            pub fn genesis_helper<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.genesis_helper = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for genesis_helper: {}", e
                        )
                    });
                self
            }
            pub fn genesis_helper_package<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.genesis_helper_package = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for genesis_helper_package: {}",
                            e
                        )
                    });
                self
            }
            pub fn global_caller_virtual_badge<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.global_caller_virtual_badge = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for global_caller_virtual_badge: {}",
                            e
                        )
                    });
                self
            }
            pub fn identity_owner_badge<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.identity_owner_badge = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for identity_owner_badge: {}",
                            e
                        )
                    });
                self
            }
            pub fn identity_package<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.identity_package = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for identity_package: {}", e
                        )
                    });
                self
            }
            pub fn locker_package<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.locker_package = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for locker_package: {}", e
                        )
                    });
                self
            }
            pub fn metadata_module_package<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.metadata_module_package = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for metadata_module_package: {}",
                            e
                        )
                    });
                self
            }
            pub fn package_of_direct_caller_virtual_badge<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.package_of_direct_caller_virtual_badge = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for package_of_direct_caller_virtual_badge: {}",
                            e
                        )
                    });
                self
            }
            pub fn package_owner_badge<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.package_owner_badge = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for package_owner_badge: {}",
                            e
                        )
                    });
                self
            }
            pub fn package_package<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.package_package = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for package_package: {}", e
                        )
                    });
                self
            }
            pub fn pool_package<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.pool_package = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for pool_package: {}", e
                        )
                    });
                self
            }
            pub fn resource_package<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.resource_package = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_package: {}", e
                        )
                    });
                self
            }
            pub fn role_assignment_module_package<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.role_assignment_module_package = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for role_assignment_module_package: {}",
                            e
                        )
                    });
                self
            }
            pub fn royalty_module_package<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.royalty_module_package = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for royalty_module_package: {}",
                            e
                        )
                    });
                self
            }
            pub fn secp256k1_signature_virtual_badge<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.secp256k1_signature_virtual_badge = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for secp256k1_signature_virtual_badge: {}",
                            e
                        )
                    });
                self
            }
            pub fn system_transaction_badge<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.system_transaction_badge = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for system_transaction_badge: {}",
                            e
                        )
                    });
                self
            }
            pub fn test_utils_package<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::Address>>,
                T::Error: std::fmt::Display,
            {
                self.test_utils_package = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for test_utils_package: {}",
                            e
                        )
                    });
                self
            }
            pub fn transaction_processor_package<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.transaction_processor_package = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for transaction_processor_package: {}",
                            e
                        )
                    });
                self
            }
            pub fn transaction_tracker<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.transaction_tracker = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for transaction_tracker: {}",
                            e
                        )
                    });
                self
            }
            pub fn transaction_tracker_package<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::Address>>,
                T::Error: std::fmt::Display,
            {
                self.transaction_tracker_package = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for transaction_tracker_package: {}",
                            e
                        )
                    });
                self
            }
            pub fn validator_owner_badge<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.validator_owner_badge = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for validator_owner_badge: {}",
                            e
                        )
                    });
                self
            }
            pub fn xrd<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.xrd = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for xrd: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<NetworkConfigurationResponseWellKnownAddresses>
        for super::NetworkConfigurationResponseWellKnownAddresses {
            type Error = super::error::ConversionError;
            fn try_from(
                value: NetworkConfigurationResponseWellKnownAddresses,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    access_controller_package: value.access_controller_package?,
                    access_rules_package: value.access_rules_package?,
                    account_owner_badge: value.account_owner_badge?,
                    account_package: value.account_package?,
                    consensus_manager: value.consensus_manager?,
                    consensus_manager_package: value.consensus_manager_package?,
                    ed25519_signature_virtual_badge: value
                        .ed25519_signature_virtual_badge?,
                    faucet: value.faucet?,
                    faucet_package: value.faucet_package?,
                    genesis_helper: value.genesis_helper?,
                    genesis_helper_package: value.genesis_helper_package?,
                    global_caller_virtual_badge: value.global_caller_virtual_badge?,
                    identity_owner_badge: value.identity_owner_badge?,
                    identity_package: value.identity_package?,
                    locker_package: value.locker_package?,
                    metadata_module_package: value.metadata_module_package?,
                    package_of_direct_caller_virtual_badge: value
                        .package_of_direct_caller_virtual_badge?,
                    package_owner_badge: value.package_owner_badge?,
                    package_package: value.package_package?,
                    pool_package: value.pool_package?,
                    resource_package: value.resource_package?,
                    role_assignment_module_package: value
                        .role_assignment_module_package?,
                    royalty_module_package: value.royalty_module_package?,
                    secp256k1_signature_virtual_badge: value
                        .secp256k1_signature_virtual_badge?,
                    system_transaction_badge: value.system_transaction_badge?,
                    test_utils_package: value.test_utils_package?,
                    transaction_processor_package: value.transaction_processor_package?,
                    transaction_tracker: value.transaction_tracker?,
                    transaction_tracker_package: value.transaction_tracker_package?,
                    validator_owner_badge: value.validator_owner_badge?,
                    xrd: value.xrd?,
                })
            }
        }
        impl From<super::NetworkConfigurationResponseWellKnownAddresses>
        for NetworkConfigurationResponseWellKnownAddresses {
            fn from(
                value: super::NetworkConfigurationResponseWellKnownAddresses,
            ) -> Self {
                Self {
                    access_controller_package: Ok(value.access_controller_package),
                    access_rules_package: Ok(value.access_rules_package),
                    account_owner_badge: Ok(value.account_owner_badge),
                    account_package: Ok(value.account_package),
                    consensus_manager: Ok(value.consensus_manager),
                    consensus_manager_package: Ok(value.consensus_manager_package),
                    ed25519_signature_virtual_badge: Ok(
                        value.ed25519_signature_virtual_badge,
                    ),
                    faucet: Ok(value.faucet),
                    faucet_package: Ok(value.faucet_package),
                    genesis_helper: Ok(value.genesis_helper),
                    genesis_helper_package: Ok(value.genesis_helper_package),
                    global_caller_virtual_badge: Ok(value.global_caller_virtual_badge),
                    identity_owner_badge: Ok(value.identity_owner_badge),
                    identity_package: Ok(value.identity_package),
                    locker_package: Ok(value.locker_package),
                    metadata_module_package: Ok(value.metadata_module_package),
                    package_of_direct_caller_virtual_badge: Ok(
                        value.package_of_direct_caller_virtual_badge,
                    ),
                    package_owner_badge: Ok(value.package_owner_badge),
                    package_package: Ok(value.package_package),
                    pool_package: Ok(value.pool_package),
                    resource_package: Ok(value.resource_package),
                    role_assignment_module_package: Ok(
                        value.role_assignment_module_package,
                    ),
                    royalty_module_package: Ok(value.royalty_module_package),
                    secp256k1_signature_virtual_badge: Ok(
                        value.secp256k1_signature_virtual_badge,
                    ),
                    system_transaction_badge: Ok(value.system_transaction_badge),
                    test_utils_package: Ok(value.test_utils_package),
                    transaction_processor_package: Ok(
                        value.transaction_processor_package,
                    ),
                    transaction_tracker: Ok(value.transaction_tracker),
                    transaction_tracker_package: Ok(value.transaction_tracker_package),
                    validator_owner_badge: Ok(value.validator_owner_badge),
                    xrd: Ok(value.xrd),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct NonFungibleIdsCollection {
            items: Result<Vec<super::NonFungibleId>, String>,
            next_cursor: Result<Option<String>, String>,
            total_count: Result<Option<i64>, String>,
        }
        impl Default for NonFungibleIdsCollection {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_cursor: Ok(Default::default()),
                    total_count: Ok(Default::default()),
                }
            }
        }
        impl NonFungibleIdsCollection {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::NonFungibleId>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {}", e)
                    });
                self
            }
            pub fn next_cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for next_cursor: {}", e)
                    });
                self
            }
            pub fn total_count<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.total_count = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for total_count: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<NonFungibleIdsCollection>
        for super::NonFungibleIdsCollection {
            type Error = super::error::ConversionError;
            fn try_from(
                value: NonFungibleIdsCollection,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_cursor: value.next_cursor?,
                    total_count: value.total_count?,
                })
            }
        }
        impl From<super::NonFungibleIdsCollection> for NonFungibleIdsCollection {
            fn from(value: super::NonFungibleIdsCollection) -> Self {
                Self {
                    items: Ok(value.items),
                    next_cursor: Ok(value.next_cursor),
                    total_count: Ok(value.total_count),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct NonFungibleResourcesCollection {
            items: Result<Vec<super::NonFungibleResourcesCollectionItem>, String>,
            next_cursor: Result<Option<String>, String>,
            total_count: Result<Option<i64>, String>,
        }
        impl Default for NonFungibleResourcesCollection {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_cursor: Ok(Default::default()),
                    total_count: Ok(Default::default()),
                }
            }
        }
        impl NonFungibleResourcesCollection {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::NonFungibleResourcesCollectionItem>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {}", e)
                    });
                self
            }
            pub fn next_cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for next_cursor: {}", e)
                    });
                self
            }
            pub fn total_count<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.total_count = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for total_count: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<NonFungibleResourcesCollection>
        for super::NonFungibleResourcesCollection {
            type Error = super::error::ConversionError;
            fn try_from(
                value: NonFungibleResourcesCollection,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_cursor: value.next_cursor?,
                    total_count: value.total_count?,
                })
            }
        }
        impl From<super::NonFungibleResourcesCollection>
        for NonFungibleResourcesCollection {
            fn from(value: super::NonFungibleResourcesCollection) -> Self {
                Self {
                    items: Ok(value.items),
                    next_cursor: Ok(value.next_cursor),
                    total_count: Ok(value.total_count),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct NonFungibleResourcesCollectionItemBase {
            aggregation_level: Result<super::ResourceAggregationLevel, String>,
            explicit_metadata: Result<Option<super::EntityMetadataCollection>, String>,
            resource_address: Result<super::Address, String>,
        }
        impl Default for NonFungibleResourcesCollectionItemBase {
            fn default() -> Self {
                Self {
                    aggregation_level: Err(
                        "no value supplied for aggregation_level".to_string(),
                    ),
                    explicit_metadata: Ok(Default::default()),
                    resource_address: Err(
                        "no value supplied for resource_address".to_string(),
                    ),
                }
            }
        }
        impl NonFungibleResourcesCollectionItemBase {
            pub fn aggregation_level<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ResourceAggregationLevel>,
                T::Error: std::fmt::Display,
            {
                self.aggregation_level = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for aggregation_level: {}",
                            e
                        )
                    });
                self
            }
            pub fn explicit_metadata<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::EntityMetadataCollection>>,
                T::Error: std::fmt::Display,
            {
                self.explicit_metadata = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for explicit_metadata: {}",
                            e
                        )
                    });
                self
            }
            pub fn resource_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.resource_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_address: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<NonFungibleResourcesCollectionItemBase>
        for super::NonFungibleResourcesCollectionItemBase {
            type Error = super::error::ConversionError;
            fn try_from(
                value: NonFungibleResourcesCollectionItemBase,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    aggregation_level: value.aggregation_level?,
                    explicit_metadata: value.explicit_metadata?,
                    resource_address: value.resource_address?,
                })
            }
        }
        impl From<super::NonFungibleResourcesCollectionItemBase>
        for NonFungibleResourcesCollectionItemBase {
            fn from(value: super::NonFungibleResourcesCollectionItemBase) -> Self {
                Self {
                    aggregation_level: Ok(value.aggregation_level),
                    explicit_metadata: Ok(value.explicit_metadata),
                    resource_address: Ok(value.resource_address),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct NonFungibleResourcesCollectionItemGloballyAggregated {
            aggregation_level: Result<
                super::NonFungibleResourcesCollectionItemGloballyAggregatedAggregationLevel,
                String,
            >,
            amount: Result<i64, String>,
            explicit_metadata: Result<Option<super::EntityMetadataCollection>, String>,
            last_updated_at_state_version: Result<
                super::LastUpdatedAtStateVersion,
                String,
            >,
            resource_address: Result<super::Address, String>,
        }
        impl Default for NonFungibleResourcesCollectionItemGloballyAggregated {
            fn default() -> Self {
                Self {
                    aggregation_level: Err(
                        "no value supplied for aggregation_level".to_string(),
                    ),
                    amount: Err("no value supplied for amount".to_string()),
                    explicit_metadata: Ok(Default::default()),
                    last_updated_at_state_version: Err(
                        "no value supplied for last_updated_at_state_version".to_string(),
                    ),
                    resource_address: Err(
                        "no value supplied for resource_address".to_string(),
                    ),
                }
            }
        }
        impl NonFungibleResourcesCollectionItemGloballyAggregated {
            pub fn aggregation_level<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::NonFungibleResourcesCollectionItemGloballyAggregatedAggregationLevel,
                >,
                T::Error: std::fmt::Display,
            {
                self.aggregation_level = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for aggregation_level: {}",
                            e
                        )
                    });
                self
            }
            pub fn amount<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<i64>,
                T::Error: std::fmt::Display,
            {
                self.amount = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for amount: {}", e)
                    });
                self
            }
            pub fn explicit_metadata<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::EntityMetadataCollection>>,
                T::Error: std::fmt::Display,
            {
                self.explicit_metadata = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for explicit_metadata: {}",
                            e
                        )
                    });
                self
            }
            pub fn last_updated_at_state_version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::LastUpdatedAtStateVersion>,
                T::Error: std::fmt::Display,
            {
                self.last_updated_at_state_version = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for last_updated_at_state_version: {}",
                            e
                        )
                    });
                self
            }
            pub fn resource_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.resource_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_address: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<NonFungibleResourcesCollectionItemGloballyAggregated>
        for super::NonFungibleResourcesCollectionItemGloballyAggregated {
            type Error = super::error::ConversionError;
            fn try_from(
                value: NonFungibleResourcesCollectionItemGloballyAggregated,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    aggregation_level: value.aggregation_level?,
                    amount: value.amount?,
                    explicit_metadata: value.explicit_metadata?,
                    last_updated_at_state_version: value.last_updated_at_state_version?,
                    resource_address: value.resource_address?,
                })
            }
        }
        impl From<super::NonFungibleResourcesCollectionItemGloballyAggregated>
        for NonFungibleResourcesCollectionItemGloballyAggregated {
            fn from(
                value: super::NonFungibleResourcesCollectionItemGloballyAggregated,
            ) -> Self {
                Self {
                    aggregation_level: Ok(value.aggregation_level),
                    amount: Ok(value.amount),
                    explicit_metadata: Ok(value.explicit_metadata),
                    last_updated_at_state_version: Ok(
                        value.last_updated_at_state_version,
                    ),
                    resource_address: Ok(value.resource_address),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct NonFungibleResourcesCollectionItemVaultAggregated {
            aggregation_level: Result<
                super::NonFungibleResourcesCollectionItemVaultAggregatedAggregationLevel,
                String,
            >,
            explicit_metadata: Result<Option<super::EntityMetadataCollection>, String>,
            resource_address: Result<super::Address, String>,
            vaults: Result<
                super::NonFungibleResourcesCollectionItemVaultAggregatedVault,
                String,
            >,
        }
        impl Default for NonFungibleResourcesCollectionItemVaultAggregated {
            fn default() -> Self {
                Self {
                    aggregation_level: Err(
                        "no value supplied for aggregation_level".to_string(),
                    ),
                    explicit_metadata: Ok(Default::default()),
                    resource_address: Err(
                        "no value supplied for resource_address".to_string(),
                    ),
                    vaults: Err("no value supplied for vaults".to_string()),
                }
            }
        }
        impl NonFungibleResourcesCollectionItemVaultAggregated {
            pub fn aggregation_level<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::NonFungibleResourcesCollectionItemVaultAggregatedAggregationLevel,
                >,
                T::Error: std::fmt::Display,
            {
                self.aggregation_level = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for aggregation_level: {}",
                            e
                        )
                    });
                self
            }
            pub fn explicit_metadata<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::EntityMetadataCollection>>,
                T::Error: std::fmt::Display,
            {
                self.explicit_metadata = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for explicit_metadata: {}",
                            e
                        )
                    });
                self
            }
            pub fn resource_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.resource_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_address: {}", e
                        )
                    });
                self
            }
            pub fn vaults<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::NonFungibleResourcesCollectionItemVaultAggregatedVault,
                >,
                T::Error: std::fmt::Display,
            {
                self.vaults = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for vaults: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<NonFungibleResourcesCollectionItemVaultAggregated>
        for super::NonFungibleResourcesCollectionItemVaultAggregated {
            type Error = super::error::ConversionError;
            fn try_from(
                value: NonFungibleResourcesCollectionItemVaultAggregated,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    aggregation_level: value.aggregation_level?,
                    explicit_metadata: value.explicit_metadata?,
                    resource_address: value.resource_address?,
                    vaults: value.vaults?,
                })
            }
        }
        impl From<super::NonFungibleResourcesCollectionItemVaultAggregated>
        for NonFungibleResourcesCollectionItemVaultAggregated {
            fn from(
                value: super::NonFungibleResourcesCollectionItemVaultAggregated,
            ) -> Self {
                Self {
                    aggregation_level: Ok(value.aggregation_level),
                    explicit_metadata: Ok(value.explicit_metadata),
                    resource_address: Ok(value.resource_address),
                    vaults: Ok(value.vaults),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct NonFungibleResourcesCollectionItemVaultAggregatedVault {
            items: Result<
                Vec<super::NonFungibleResourcesCollectionItemVaultAggregatedVaultItem>,
                String,
            >,
            next_cursor: Result<Option<String>, String>,
            total_count: Result<Option<i64>, String>,
        }
        impl Default for NonFungibleResourcesCollectionItemVaultAggregatedVault {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_cursor: Ok(Default::default()),
                    total_count: Ok(Default::default()),
                }
            }
        }
        impl NonFungibleResourcesCollectionItemVaultAggregatedVault {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    Vec<
                        super::NonFungibleResourcesCollectionItemVaultAggregatedVaultItem,
                    >,
                >,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {}", e)
                    });
                self
            }
            pub fn next_cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for next_cursor: {}", e)
                    });
                self
            }
            pub fn total_count<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.total_count = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for total_count: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<
            NonFungibleResourcesCollectionItemVaultAggregatedVault,
        > for super::NonFungibleResourcesCollectionItemVaultAggregatedVault {
            type Error = super::error::ConversionError;
            fn try_from(
                value: NonFungibleResourcesCollectionItemVaultAggregatedVault,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_cursor: value.next_cursor?,
                    total_count: value.total_count?,
                })
            }
        }
        impl From<super::NonFungibleResourcesCollectionItemVaultAggregatedVault>
        for NonFungibleResourcesCollectionItemVaultAggregatedVault {
            fn from(
                value: super::NonFungibleResourcesCollectionItemVaultAggregatedVault,
            ) -> Self {
                Self {
                    items: Ok(value.items),
                    next_cursor: Ok(value.next_cursor),
                    total_count: Ok(value.total_count),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct NonFungibleResourcesCollectionItemVaultAggregatedVaultItem {
            items: Result<Vec<super::NonFungibleId>, String>,
            last_updated_at_state_version: Result<
                super::LastUpdatedAtStateVersion,
                String,
            >,
            next_cursor: Result<Option<String>, String>,
            total_count: Result<i64, String>,
            vault_address: Result<super::Address, String>,
        }
        impl Default for NonFungibleResourcesCollectionItemVaultAggregatedVaultItem {
            fn default() -> Self {
                Self {
                    items: Ok(Default::default()),
                    last_updated_at_state_version: Err(
                        "no value supplied for last_updated_at_state_version".to_string(),
                    ),
                    next_cursor: Ok(Default::default()),
                    total_count: Err("no value supplied for total_count".to_string()),
                    vault_address: Err("no value supplied for vault_address".to_string()),
                }
            }
        }
        impl NonFungibleResourcesCollectionItemVaultAggregatedVaultItem {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::NonFungibleId>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {}", e)
                    });
                self
            }
            pub fn last_updated_at_state_version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::LastUpdatedAtStateVersion>,
                T::Error: std::fmt::Display,
            {
                self.last_updated_at_state_version = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for last_updated_at_state_version: {}",
                            e
                        )
                    });
                self
            }
            pub fn next_cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for next_cursor: {}", e)
                    });
                self
            }
            pub fn total_count<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<i64>,
                T::Error: std::fmt::Display,
            {
                self.total_count = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for total_count: {}", e)
                    });
                self
            }
            pub fn vault_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.vault_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for vault_address: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<
            NonFungibleResourcesCollectionItemVaultAggregatedVaultItem,
        > for super::NonFungibleResourcesCollectionItemVaultAggregatedVaultItem {
            type Error = super::error::ConversionError;
            fn try_from(
                value: NonFungibleResourcesCollectionItemVaultAggregatedVaultItem,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    last_updated_at_state_version: value.last_updated_at_state_version?,
                    next_cursor: value.next_cursor?,
                    total_count: value.total_count?,
                    vault_address: value.vault_address?,
                })
            }
        }
        impl From<super::NonFungibleResourcesCollectionItemVaultAggregatedVaultItem>
        for NonFungibleResourcesCollectionItemVaultAggregatedVaultItem {
            fn from(
                value: super::NonFungibleResourcesCollectionItemVaultAggregatedVaultItem,
            ) -> Self {
                Self {
                    items: Ok(value.items),
                    last_updated_at_state_version: Ok(
                        value.last_updated_at_state_version,
                    ),
                    next_cursor: Ok(value.next_cursor),
                    total_count: Ok(value.total_count),
                    vault_address: Ok(value.vault_address),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct NotSyncedUpError {
            current_sync_delay_seconds: Result<i64, String>,
            max_allowed_sync_delay_seconds: Result<i64, String>,
            request_type: Result<String, String>,
            type_: Result<super::NotSyncedUpErrorType, String>,
        }
        impl Default for NotSyncedUpError {
            fn default() -> Self {
                Self {
                    current_sync_delay_seconds: Err(
                        "no value supplied for current_sync_delay_seconds".to_string(),
                    ),
                    max_allowed_sync_delay_seconds: Err(
                        "no value supplied for max_allowed_sync_delay_seconds"
                            .to_string(),
                    ),
                    request_type: Err("no value supplied for request_type".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl NotSyncedUpError {
            pub fn current_sync_delay_seconds<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<i64>,
                T::Error: std::fmt::Display,
            {
                self.current_sync_delay_seconds = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for current_sync_delay_seconds: {}",
                            e
                        )
                    });
                self
            }
            pub fn max_allowed_sync_delay_seconds<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<i64>,
                T::Error: std::fmt::Display,
            {
                self.max_allowed_sync_delay_seconds = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for max_allowed_sync_delay_seconds: {}",
                            e
                        )
                    });
                self
            }
            pub fn request_type<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.request_type = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for request_type: {}", e
                        )
                    });
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::NotSyncedUpErrorType>,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<NotSyncedUpError> for super::NotSyncedUpError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: NotSyncedUpError,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    current_sync_delay_seconds: value.current_sync_delay_seconds?,
                    max_allowed_sync_delay_seconds: value
                        .max_allowed_sync_delay_seconds?,
                    request_type: value.request_type?,
                    type_: value.type_?,
                })
            }
        }
        impl From<super::NotSyncedUpError> for NotSyncedUpError {
            fn from(value: super::NotSyncedUpError) -> Self {
                Self {
                    current_sync_delay_seconds: Ok(value.current_sync_delay_seconds),
                    max_allowed_sync_delay_seconds: Ok(
                        value.max_allowed_sync_delay_seconds,
                    ),
                    request_type: Ok(value.request_type),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct OptionalNonFungibleIdsCollection {
            items: Result<Vec<super::NonFungibleId>, String>,
            next_cursor: Result<Option<String>, String>,
            total_count: Result<Option<i64>, String>,
        }
        impl Default for OptionalNonFungibleIdsCollection {
            fn default() -> Self {
                Self {
                    items: Ok(Default::default()),
                    next_cursor: Ok(Default::default()),
                    total_count: Ok(Default::default()),
                }
            }
        }
        impl OptionalNonFungibleIdsCollection {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::NonFungibleId>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {}", e)
                    });
                self
            }
            pub fn next_cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for next_cursor: {}", e)
                    });
                self
            }
            pub fn total_count<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.total_count = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for total_count: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<OptionalNonFungibleIdsCollection>
        for super::OptionalNonFungibleIdsCollection {
            type Error = super::error::ConversionError;
            fn try_from(
                value: OptionalNonFungibleIdsCollection,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_cursor: value.next_cursor?,
                    total_count: value.total_count?,
                })
            }
        }
        impl From<super::OptionalNonFungibleIdsCollection>
        for OptionalNonFungibleIdsCollection {
            fn from(value: super::OptionalNonFungibleIdsCollection) -> Self {
                Self {
                    items: Ok(value.items),
                    next_cursor: Ok(value.next_cursor),
                    total_count: Ok(value.total_count),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PackageBlueprintCollection {
            items: Result<Vec<super::PackageBlueprintCollectionItem>, String>,
            next_cursor: Result<Option<String>, String>,
            total_count: Result<Option<i64>, String>,
        }
        impl Default for PackageBlueprintCollection {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_cursor: Ok(Default::default()),
                    total_count: Ok(Default::default()),
                }
            }
        }
        impl PackageBlueprintCollection {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::PackageBlueprintCollectionItem>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {}", e)
                    });
                self
            }
            pub fn next_cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for next_cursor: {}", e)
                    });
                self
            }
            pub fn total_count<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.total_count = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for total_count: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<PackageBlueprintCollection>
        for super::PackageBlueprintCollection {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PackageBlueprintCollection,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_cursor: value.next_cursor?,
                    total_count: value.total_count?,
                })
            }
        }
        impl From<super::PackageBlueprintCollection> for PackageBlueprintCollection {
            fn from(value: super::PackageBlueprintCollection) -> Self {
                Self {
                    items: Ok(value.items),
                    next_cursor: Ok(value.next_cursor),
                    total_count: Ok(value.total_count),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PackageBlueprintCollectionItem {
            auth_template: Result<
                ::serde_json::Map<String, ::serde_json::Value>,
                String,
            >,
            auth_template_is_locked: Result<Option<bool>, String>,
            definition: Result<::serde_json::Map<String, ::serde_json::Value>, String>,
            dependant_entities: Result<Vec<super::Address>, String>,
            name: Result<String, String>,
            royalty_config: Result<Option<super::BlueprintRoyaltyConfig>, String>,
            royalty_config_is_locked: Result<Option<bool>, String>,
            version: Result<String, String>,
        }
        impl Default for PackageBlueprintCollectionItem {
            fn default() -> Self {
                Self {
                    auth_template: Ok(Default::default()),
                    auth_template_is_locked: Ok(Default::default()),
                    definition: Err("no value supplied for definition".to_string()),
                    dependant_entities: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    royalty_config: Ok(Default::default()),
                    royalty_config_is_locked: Ok(Default::default()),
                    version: Err("no value supplied for version".to_string()),
                }
            }
        }
        impl PackageBlueprintCollectionItem {
            pub fn auth_template<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<::serde_json::Map<String, ::serde_json::Value>>,
                T::Error: std::fmt::Display,
            {
                self.auth_template = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for auth_template: {}", e
                        )
                    });
                self
            }
            pub fn auth_template_is_locked<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<bool>>,
                T::Error: std::fmt::Display,
            {
                self.auth_template_is_locked = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for auth_template_is_locked: {}",
                            e
                        )
                    });
                self
            }
            pub fn definition<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<::serde_json::Map<String, ::serde_json::Value>>,
                T::Error: std::fmt::Display,
            {
                self.definition = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for definition: {}", e)
                    });
                self
            }
            pub fn dependant_entities<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Address>>,
                T::Error: std::fmt::Display,
            {
                self.dependant_entities = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for dependant_entities: {}",
                            e
                        )
                    });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for name: {}", e)
                    });
                self
            }
            pub fn royalty_config<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::BlueprintRoyaltyConfig>>,
                T::Error: std::fmt::Display,
            {
                self.royalty_config = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for royalty_config: {}", e
                        )
                    });
                self
            }
            pub fn royalty_config_is_locked<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<bool>>,
                T::Error: std::fmt::Display,
            {
                self.royalty_config_is_locked = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for royalty_config_is_locked: {}",
                            e
                        )
                    });
                self
            }
            pub fn version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.version = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for version: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<PackageBlueprintCollectionItem>
        for super::PackageBlueprintCollectionItem {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PackageBlueprintCollectionItem,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    auth_template: value.auth_template?,
                    auth_template_is_locked: value.auth_template_is_locked?,
                    definition: value.definition?,
                    dependant_entities: value.dependant_entities?,
                    name: value.name?,
                    royalty_config: value.royalty_config?,
                    royalty_config_is_locked: value.royalty_config_is_locked?,
                    version: value.version?,
                })
            }
        }
        impl From<super::PackageBlueprintCollectionItem>
        for PackageBlueprintCollectionItem {
            fn from(value: super::PackageBlueprintCollectionItem) -> Self {
                Self {
                    auth_template: Ok(value.auth_template),
                    auth_template_is_locked: Ok(value.auth_template_is_locked),
                    definition: Ok(value.definition),
                    dependant_entities: Ok(value.dependant_entities),
                    name: Ok(value.name),
                    royalty_config: Ok(value.royalty_config),
                    royalty_config_is_locked: Ok(value.royalty_config_is_locked),
                    version: Ok(value.version),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PackageCodeCollection {
            items: Result<Vec<super::PackageCodeCollectionItem>, String>,
            next_cursor: Result<Option<String>, String>,
            total_count: Result<Option<i64>, String>,
        }
        impl Default for PackageCodeCollection {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_cursor: Ok(Default::default()),
                    total_count: Ok(Default::default()),
                }
            }
        }
        impl PackageCodeCollection {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::PackageCodeCollectionItem>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {}", e)
                    });
                self
            }
            pub fn next_cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for next_cursor: {}", e)
                    });
                self
            }
            pub fn total_count<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.total_count = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for total_count: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<PackageCodeCollection>
        for super::PackageCodeCollection {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PackageCodeCollection,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_cursor: value.next_cursor?,
                    total_count: value.total_count?,
                })
            }
        }
        impl From<super::PackageCodeCollection> for PackageCodeCollection {
            fn from(value: super::PackageCodeCollection) -> Self {
                Self {
                    items: Ok(value.items),
                    next_cursor: Ok(value.next_cursor),
                    total_count: Ok(value.total_count),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PackageCodeCollectionItem {
            code_hash_hex: Result<super::HexString, String>,
            code_hex: Result<super::HexString, String>,
            vm_type: Result<super::PackageVmType, String>,
        }
        impl Default for PackageCodeCollectionItem {
            fn default() -> Self {
                Self {
                    code_hash_hex: Err(
                        "no value supplied for code_hash_hex".to_string(),
                    ),
                    code_hex: Err("no value supplied for code_hex".to_string()),
                    vm_type: Err("no value supplied for vm_type".to_string()),
                }
            }
        }
        impl PackageCodeCollectionItem {
            pub fn code_hash_hex<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::HexString>,
                T::Error: std::fmt::Display,
            {
                self.code_hash_hex = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for code_hash_hex: {}", e
                        )
                    });
                self
            }
            pub fn code_hex<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::HexString>,
                T::Error: std::fmt::Display,
            {
                self.code_hex = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for code_hex: {}", e)
                    });
                self
            }
            pub fn vm_type<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::PackageVmType>,
                T::Error: std::fmt::Display,
            {
                self.vm_type = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for vm_type: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<PackageCodeCollectionItem>
        for super::PackageCodeCollectionItem {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PackageCodeCollectionItem,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code_hash_hex: value.code_hash_hex?,
                    code_hex: value.code_hex?,
                    vm_type: value.vm_type?,
                })
            }
        }
        impl From<super::PackageCodeCollectionItem> for PackageCodeCollectionItem {
            fn from(value: super::PackageCodeCollectionItem) -> Self {
                Self {
                    code_hash_hex: Ok(value.code_hash_hex),
                    code_hex: Ok(value.code_hex),
                    vm_type: Ok(value.vm_type),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PreviewFlags {
            assume_all_signature_proofs: Result<bool, String>,
            disable_auth_checks: Result<bool, String>,
            skip_epoch_check: Result<bool, String>,
            use_free_credit: Result<bool, String>,
        }
        impl Default for PreviewFlags {
            fn default() -> Self {
                Self {
                    assume_all_signature_proofs: Ok(Default::default()),
                    disable_auth_checks: Ok(Default::default()),
                    skip_epoch_check: Ok(Default::default()),
                    use_free_credit: Ok(Default::default()),
                }
            }
        }
        impl PreviewFlags {
            pub fn assume_all_signature_proofs<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.assume_all_signature_proofs = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for assume_all_signature_proofs: {}",
                            e
                        )
                    });
                self
            }
            pub fn disable_auth_checks<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.disable_auth_checks = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for disable_auth_checks: {}",
                            e
                        )
                    });
                self
            }
            pub fn skip_epoch_check<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.skip_epoch_check = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for skip_epoch_check: {}", e
                        )
                    });
                self
            }
            pub fn use_free_credit<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.use_free_credit = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for use_free_credit: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<PreviewFlags> for super::PreviewFlags {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PreviewFlags,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    assume_all_signature_proofs: value.assume_all_signature_proofs?,
                    disable_auth_checks: value.disable_auth_checks?,
                    skip_epoch_check: value.skip_epoch_check?,
                    use_free_credit: value.use_free_credit?,
                })
            }
        }
        impl From<super::PreviewFlags> for PreviewFlags {
            fn from(value: super::PreviewFlags) -> Self {
                Self {
                    assume_all_signature_proofs: Ok(value.assume_all_signature_proofs),
                    disable_auth_checks: Ok(value.disable_auth_checks),
                    skip_epoch_check: Ok(value.skip_epoch_check),
                    use_free_credit: Ok(value.use_free_credit),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PreviewTransactionBase {
            type_: Result<super::PreviewTransactionType, String>,
        }
        impl Default for PreviewTransactionBase {
            fn default() -> Self {
                Self {
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl PreviewTransactionBase {
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::PreviewTransactionType>,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<PreviewTransactionBase>
        for super::PreviewTransactionBase {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PreviewTransactionBase,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self { type_: value.type_? })
            }
        }
        impl From<super::PreviewTransactionBase> for PreviewTransactionBase {
            fn from(value: super::PreviewTransactionBase) -> Self {
                Self { type_: Ok(value.type_) }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ProgrammaticScryptoSborValueArray {
            element_kind: Result<super::ProgrammaticScryptoSborValueKind, String>,
            element_type_name: Result<Option<String>, String>,
            elements: Result<Vec<super::ProgrammaticScryptoSborValue>, String>,
            field_name: Result<Option<String>, String>,
            kind: Result<super::ProgrammaticScryptoSborValueArrayKind, String>,
            type_name: Result<Option<String>, String>,
        }
        impl Default for ProgrammaticScryptoSborValueArray {
            fn default() -> Self {
                Self {
                    element_kind: Err("no value supplied for element_kind".to_string()),
                    element_type_name: Ok(Default::default()),
                    elements: Err("no value supplied for elements".to_string()),
                    field_name: Ok(Default::default()),
                    kind: Err("no value supplied for kind".to_string()),
                    type_name: Ok(Default::default()),
                }
            }
        }
        impl ProgrammaticScryptoSborValueArray {
            pub fn element_kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ProgrammaticScryptoSborValueKind>,
                T::Error: std::fmt::Display,
            {
                self.element_kind = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for element_kind: {}", e
                        )
                    });
                self
            }
            pub fn element_type_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.element_type_name = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for element_type_name: {}",
                            e
                        )
                    });
                self
            }
            pub fn elements<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::ProgrammaticScryptoSborValue>>,
                T::Error: std::fmt::Display,
            {
                self.elements = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for elements: {}", e)
                    });
                self
            }
            pub fn field_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.field_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for field_name: {}", e)
                    });
                self
            }
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ProgrammaticScryptoSborValueArrayKind>,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for kind: {}", e)
                    });
                self
            }
            pub fn type_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.type_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_name: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<ProgrammaticScryptoSborValueArray>
        for super::ProgrammaticScryptoSborValueArray {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ProgrammaticScryptoSborValueArray,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    element_kind: value.element_kind?,
                    element_type_name: value.element_type_name?,
                    elements: value.elements?,
                    field_name: value.field_name?,
                    kind: value.kind?,
                    type_name: value.type_name?,
                })
            }
        }
        impl From<super::ProgrammaticScryptoSborValueArray>
        for ProgrammaticScryptoSborValueArray {
            fn from(value: super::ProgrammaticScryptoSborValueArray) -> Self {
                Self {
                    element_kind: Ok(value.element_kind),
                    element_type_name: Ok(value.element_type_name),
                    elements: Ok(value.elements),
                    field_name: Ok(value.field_name),
                    kind: Ok(value.kind),
                    type_name: Ok(value.type_name),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ProgrammaticScryptoSborValueBase {
            field_name: Result<Option<String>, String>,
            kind: Result<super::ProgrammaticScryptoSborValueKind, String>,
            type_name: Result<Option<String>, String>,
        }
        impl Default for ProgrammaticScryptoSborValueBase {
            fn default() -> Self {
                Self {
                    field_name: Ok(Default::default()),
                    kind: Err("no value supplied for kind".to_string()),
                    type_name: Ok(Default::default()),
                }
            }
        }
        impl ProgrammaticScryptoSborValueBase {
            pub fn field_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.field_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for field_name: {}", e)
                    });
                self
            }
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ProgrammaticScryptoSborValueKind>,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for kind: {}", e)
                    });
                self
            }
            pub fn type_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.type_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_name: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<ProgrammaticScryptoSborValueBase>
        for super::ProgrammaticScryptoSborValueBase {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ProgrammaticScryptoSborValueBase,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    field_name: value.field_name?,
                    kind: value.kind?,
                    type_name: value.type_name?,
                })
            }
        }
        impl From<super::ProgrammaticScryptoSborValueBase>
        for ProgrammaticScryptoSborValueBase {
            fn from(value: super::ProgrammaticScryptoSborValueBase) -> Self {
                Self {
                    field_name: Ok(value.field_name),
                    kind: Ok(value.kind),
                    type_name: Ok(value.type_name),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ProgrammaticScryptoSborValueBool {
            field_name: Result<Option<String>, String>,
            kind: Result<super::ProgrammaticScryptoSborValueBoolKind, String>,
            type_name: Result<Option<String>, String>,
            value: Result<bool, String>,
        }
        impl Default for ProgrammaticScryptoSborValueBool {
            fn default() -> Self {
                Self {
                    field_name: Ok(Default::default()),
                    kind: Err("no value supplied for kind".to_string()),
                    type_name: Ok(Default::default()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl ProgrammaticScryptoSborValueBool {
            pub fn field_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.field_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for field_name: {}", e)
                    });
                self
            }
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ProgrammaticScryptoSborValueBoolKind>,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for kind: {}", e)
                    });
                self
            }
            pub fn type_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.type_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_name: {}", e)
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<ProgrammaticScryptoSborValueBool>
        for super::ProgrammaticScryptoSborValueBool {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ProgrammaticScryptoSborValueBool,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    field_name: value.field_name?,
                    kind: value.kind?,
                    type_name: value.type_name?,
                    value: value.value?,
                })
            }
        }
        impl From<super::ProgrammaticScryptoSborValueBool>
        for ProgrammaticScryptoSborValueBool {
            fn from(value: super::ProgrammaticScryptoSborValueBool) -> Self {
                Self {
                    field_name: Ok(value.field_name),
                    kind: Ok(value.kind),
                    type_name: Ok(value.type_name),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ProgrammaticScryptoSborValueBytes {
            element_kind: Result<super::ProgrammaticScryptoSborValueKind, String>,
            element_type_name: Result<Option<String>, String>,
            field_name: Result<Option<String>, String>,
            hex: Result<super::HexString, String>,
            kind: Result<super::ProgrammaticScryptoSborValueBytesKind, String>,
            type_name: Result<Option<String>, String>,
        }
        impl Default for ProgrammaticScryptoSborValueBytes {
            fn default() -> Self {
                Self {
                    element_kind: Err("no value supplied for element_kind".to_string()),
                    element_type_name: Ok(Default::default()),
                    field_name: Ok(Default::default()),
                    hex: Err("no value supplied for hex".to_string()),
                    kind: Err("no value supplied for kind".to_string()),
                    type_name: Ok(Default::default()),
                }
            }
        }
        impl ProgrammaticScryptoSborValueBytes {
            pub fn element_kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ProgrammaticScryptoSborValueKind>,
                T::Error: std::fmt::Display,
            {
                self.element_kind = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for element_kind: {}", e
                        )
                    });
                self
            }
            pub fn element_type_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.element_type_name = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for element_type_name: {}",
                            e
                        )
                    });
                self
            }
            pub fn field_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.field_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for field_name: {}", e)
                    });
                self
            }
            pub fn hex<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::HexString>,
                T::Error: std::fmt::Display,
            {
                self.hex = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for hex: {}", e)
                    });
                self
            }
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ProgrammaticScryptoSborValueBytesKind>,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for kind: {}", e)
                    });
                self
            }
            pub fn type_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.type_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_name: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<ProgrammaticScryptoSborValueBytes>
        for super::ProgrammaticScryptoSborValueBytes {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ProgrammaticScryptoSborValueBytes,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    element_kind: value.element_kind?,
                    element_type_name: value.element_type_name?,
                    field_name: value.field_name?,
                    hex: value.hex?,
                    kind: value.kind?,
                    type_name: value.type_name?,
                })
            }
        }
        impl From<super::ProgrammaticScryptoSborValueBytes>
        for ProgrammaticScryptoSborValueBytes {
            fn from(value: super::ProgrammaticScryptoSborValueBytes) -> Self {
                Self {
                    element_kind: Ok(value.element_kind),
                    element_type_name: Ok(value.element_type_name),
                    field_name: Ok(value.field_name),
                    hex: Ok(value.hex),
                    kind: Ok(value.kind),
                    type_name: Ok(value.type_name),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ProgrammaticScryptoSborValueDecimal {
            field_name: Result<Option<String>, String>,
            kind: Result<super::ProgrammaticScryptoSborValueDecimalKind, String>,
            type_name: Result<Option<String>, String>,
            value: Result<String, String>,
        }
        impl Default for ProgrammaticScryptoSborValueDecimal {
            fn default() -> Self {
                Self {
                    field_name: Ok(Default::default()),
                    kind: Err("no value supplied for kind".to_string()),
                    type_name: Ok(Default::default()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl ProgrammaticScryptoSborValueDecimal {
            pub fn field_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.field_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for field_name: {}", e)
                    });
                self
            }
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ProgrammaticScryptoSborValueDecimalKind>,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for kind: {}", e)
                    });
                self
            }
            pub fn type_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.type_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_name: {}", e)
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<ProgrammaticScryptoSborValueDecimal>
        for super::ProgrammaticScryptoSborValueDecimal {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ProgrammaticScryptoSborValueDecimal,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    field_name: value.field_name?,
                    kind: value.kind?,
                    type_name: value.type_name?,
                    value: value.value?,
                })
            }
        }
        impl From<super::ProgrammaticScryptoSborValueDecimal>
        for ProgrammaticScryptoSborValueDecimal {
            fn from(value: super::ProgrammaticScryptoSborValueDecimal) -> Self {
                Self {
                    field_name: Ok(value.field_name),
                    kind: Ok(value.kind),
                    type_name: Ok(value.type_name),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ProgrammaticScryptoSborValueEnum {
            field_name: Result<Option<String>, String>,
            fields: Result<Vec<super::ProgrammaticScryptoSborValue>, String>,
            kind: Result<super::ProgrammaticScryptoSborValueEnumKind, String>,
            type_name: Result<Option<String>, String>,
            variant_id: Result<String, String>,
            variant_name: Result<Option<String>, String>,
        }
        impl Default for ProgrammaticScryptoSborValueEnum {
            fn default() -> Self {
                Self {
                    field_name: Ok(Default::default()),
                    fields: Err("no value supplied for fields".to_string()),
                    kind: Err("no value supplied for kind".to_string()),
                    type_name: Ok(Default::default()),
                    variant_id: Err("no value supplied for variant_id".to_string()),
                    variant_name: Ok(Default::default()),
                }
            }
        }
        impl ProgrammaticScryptoSborValueEnum {
            pub fn field_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.field_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for field_name: {}", e)
                    });
                self
            }
            pub fn fields<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::ProgrammaticScryptoSborValue>>,
                T::Error: std::fmt::Display,
            {
                self.fields = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for fields: {}", e)
                    });
                self
            }
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ProgrammaticScryptoSborValueEnumKind>,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for kind: {}", e)
                    });
                self
            }
            pub fn type_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.type_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_name: {}", e)
                    });
                self
            }
            pub fn variant_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.variant_id = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for variant_id: {}", e)
                    });
                self
            }
            pub fn variant_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.variant_name = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for variant_name: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<ProgrammaticScryptoSborValueEnum>
        for super::ProgrammaticScryptoSborValueEnum {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ProgrammaticScryptoSborValueEnum,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    field_name: value.field_name?,
                    fields: value.fields?,
                    kind: value.kind?,
                    type_name: value.type_name?,
                    variant_id: value.variant_id?,
                    variant_name: value.variant_name?,
                })
            }
        }
        impl From<super::ProgrammaticScryptoSborValueEnum>
        for ProgrammaticScryptoSborValueEnum {
            fn from(value: super::ProgrammaticScryptoSborValueEnum) -> Self {
                Self {
                    field_name: Ok(value.field_name),
                    fields: Ok(value.fields),
                    kind: Ok(value.kind),
                    type_name: Ok(value.type_name),
                    variant_id: Ok(value.variant_id),
                    variant_name: Ok(value.variant_name),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ProgrammaticScryptoSborValueI128 {
            field_name: Result<Option<String>, String>,
            kind: Result<super::ProgrammaticScryptoSborValueI128Kind, String>,
            type_name: Result<Option<String>, String>,
            value: Result<String, String>,
        }
        impl Default for ProgrammaticScryptoSborValueI128 {
            fn default() -> Self {
                Self {
                    field_name: Ok(Default::default()),
                    kind: Err("no value supplied for kind".to_string()),
                    type_name: Ok(Default::default()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl ProgrammaticScryptoSborValueI128 {
            pub fn field_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.field_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for field_name: {}", e)
                    });
                self
            }
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ProgrammaticScryptoSborValueI128Kind>,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for kind: {}", e)
                    });
                self
            }
            pub fn type_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.type_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_name: {}", e)
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<ProgrammaticScryptoSborValueI128>
        for super::ProgrammaticScryptoSborValueI128 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ProgrammaticScryptoSborValueI128,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    field_name: value.field_name?,
                    kind: value.kind?,
                    type_name: value.type_name?,
                    value: value.value?,
                })
            }
        }
        impl From<super::ProgrammaticScryptoSborValueI128>
        for ProgrammaticScryptoSborValueI128 {
            fn from(value: super::ProgrammaticScryptoSborValueI128) -> Self {
                Self {
                    field_name: Ok(value.field_name),
                    kind: Ok(value.kind),
                    type_name: Ok(value.type_name),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ProgrammaticScryptoSborValueI16 {
            field_name: Result<Option<String>, String>,
            kind: Result<super::ProgrammaticScryptoSborValueI16Kind, String>,
            type_name: Result<Option<String>, String>,
            value: Result<String, String>,
        }
        impl Default for ProgrammaticScryptoSborValueI16 {
            fn default() -> Self {
                Self {
                    field_name: Ok(Default::default()),
                    kind: Err("no value supplied for kind".to_string()),
                    type_name: Ok(Default::default()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl ProgrammaticScryptoSborValueI16 {
            pub fn field_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.field_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for field_name: {}", e)
                    });
                self
            }
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ProgrammaticScryptoSborValueI16Kind>,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for kind: {}", e)
                    });
                self
            }
            pub fn type_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.type_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_name: {}", e)
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<ProgrammaticScryptoSborValueI16>
        for super::ProgrammaticScryptoSborValueI16 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ProgrammaticScryptoSborValueI16,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    field_name: value.field_name?,
                    kind: value.kind?,
                    type_name: value.type_name?,
                    value: value.value?,
                })
            }
        }
        impl From<super::ProgrammaticScryptoSborValueI16>
        for ProgrammaticScryptoSborValueI16 {
            fn from(value: super::ProgrammaticScryptoSborValueI16) -> Self {
                Self {
                    field_name: Ok(value.field_name),
                    kind: Ok(value.kind),
                    type_name: Ok(value.type_name),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ProgrammaticScryptoSborValueI32 {
            field_name: Result<Option<String>, String>,
            kind: Result<super::ProgrammaticScryptoSborValueI32Kind, String>,
            type_name: Result<Option<String>, String>,
            value: Result<String, String>,
        }
        impl Default for ProgrammaticScryptoSborValueI32 {
            fn default() -> Self {
                Self {
                    field_name: Ok(Default::default()),
                    kind: Err("no value supplied for kind".to_string()),
                    type_name: Ok(Default::default()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl ProgrammaticScryptoSborValueI32 {
            pub fn field_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.field_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for field_name: {}", e)
                    });
                self
            }
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ProgrammaticScryptoSborValueI32Kind>,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for kind: {}", e)
                    });
                self
            }
            pub fn type_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.type_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_name: {}", e)
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<ProgrammaticScryptoSborValueI32>
        for super::ProgrammaticScryptoSborValueI32 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ProgrammaticScryptoSborValueI32,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    field_name: value.field_name?,
                    kind: value.kind?,
                    type_name: value.type_name?,
                    value: value.value?,
                })
            }
        }
        impl From<super::ProgrammaticScryptoSborValueI32>
        for ProgrammaticScryptoSborValueI32 {
            fn from(value: super::ProgrammaticScryptoSborValueI32) -> Self {
                Self {
                    field_name: Ok(value.field_name),
                    kind: Ok(value.kind),
                    type_name: Ok(value.type_name),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ProgrammaticScryptoSborValueI64 {
            field_name: Result<Option<String>, String>,
            kind: Result<super::ProgrammaticScryptoSborValueI64Kind, String>,
            type_name: Result<Option<String>, String>,
            value: Result<String, String>,
        }
        impl Default for ProgrammaticScryptoSborValueI64 {
            fn default() -> Self {
                Self {
                    field_name: Ok(Default::default()),
                    kind: Err("no value supplied for kind".to_string()),
                    type_name: Ok(Default::default()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl ProgrammaticScryptoSborValueI64 {
            pub fn field_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.field_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for field_name: {}", e)
                    });
                self
            }
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ProgrammaticScryptoSborValueI64Kind>,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for kind: {}", e)
                    });
                self
            }
            pub fn type_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.type_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_name: {}", e)
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<ProgrammaticScryptoSborValueI64>
        for super::ProgrammaticScryptoSborValueI64 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ProgrammaticScryptoSborValueI64,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    field_name: value.field_name?,
                    kind: value.kind?,
                    type_name: value.type_name?,
                    value: value.value?,
                })
            }
        }
        impl From<super::ProgrammaticScryptoSborValueI64>
        for ProgrammaticScryptoSborValueI64 {
            fn from(value: super::ProgrammaticScryptoSborValueI64) -> Self {
                Self {
                    field_name: Ok(value.field_name),
                    kind: Ok(value.kind),
                    type_name: Ok(value.type_name),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ProgrammaticScryptoSborValueI8 {
            field_name: Result<Option<String>, String>,
            kind: Result<super::ProgrammaticScryptoSborValueI8Kind, String>,
            type_name: Result<Option<String>, String>,
            value: Result<String, String>,
        }
        impl Default for ProgrammaticScryptoSborValueI8 {
            fn default() -> Self {
                Self {
                    field_name: Ok(Default::default()),
                    kind: Err("no value supplied for kind".to_string()),
                    type_name: Ok(Default::default()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl ProgrammaticScryptoSborValueI8 {
            pub fn field_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.field_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for field_name: {}", e)
                    });
                self
            }
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ProgrammaticScryptoSborValueI8Kind>,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for kind: {}", e)
                    });
                self
            }
            pub fn type_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.type_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_name: {}", e)
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<ProgrammaticScryptoSborValueI8>
        for super::ProgrammaticScryptoSborValueI8 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ProgrammaticScryptoSborValueI8,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    field_name: value.field_name?,
                    kind: value.kind?,
                    type_name: value.type_name?,
                    value: value.value?,
                })
            }
        }
        impl From<super::ProgrammaticScryptoSborValueI8>
        for ProgrammaticScryptoSborValueI8 {
            fn from(value: super::ProgrammaticScryptoSborValueI8) -> Self {
                Self {
                    field_name: Ok(value.field_name),
                    kind: Ok(value.kind),
                    type_name: Ok(value.type_name),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ProgrammaticScryptoSborValueMap {
            entries: Result<Vec<super::ProgrammaticScryptoSborValueMapEntry>, String>,
            field_name: Result<Option<String>, String>,
            key_kind: Result<super::ProgrammaticScryptoSborValueKind, String>,
            key_type_name: Result<Option<String>, String>,
            kind: Result<super::ProgrammaticScryptoSborValueMapKind, String>,
            type_name: Result<Option<String>, String>,
            value_kind: Result<super::ProgrammaticScryptoSborValueKind, String>,
            value_type_name: Result<Option<String>, String>,
        }
        impl Default for ProgrammaticScryptoSborValueMap {
            fn default() -> Self {
                Self {
                    entries: Err("no value supplied for entries".to_string()),
                    field_name: Ok(Default::default()),
                    key_kind: Err("no value supplied for key_kind".to_string()),
                    key_type_name: Ok(Default::default()),
                    kind: Err("no value supplied for kind".to_string()),
                    type_name: Ok(Default::default()),
                    value_kind: Err("no value supplied for value_kind".to_string()),
                    value_type_name: Ok(Default::default()),
                }
            }
        }
        impl ProgrammaticScryptoSborValueMap {
            pub fn entries<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    Vec<super::ProgrammaticScryptoSborValueMapEntry>,
                >,
                T::Error: std::fmt::Display,
            {
                self.entries = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for entries: {}", e)
                    });
                self
            }
            pub fn field_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.field_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for field_name: {}", e)
                    });
                self
            }
            pub fn key_kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ProgrammaticScryptoSborValueKind>,
                T::Error: std::fmt::Display,
            {
                self.key_kind = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for key_kind: {}", e)
                    });
                self
            }
            pub fn key_type_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.key_type_name = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for key_type_name: {}", e
                        )
                    });
                self
            }
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ProgrammaticScryptoSborValueMapKind>,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for kind: {}", e)
                    });
                self
            }
            pub fn type_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.type_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_name: {}", e)
                    });
                self
            }
            pub fn value_kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ProgrammaticScryptoSborValueKind>,
                T::Error: std::fmt::Display,
            {
                self.value_kind = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value_kind: {}", e)
                    });
                self
            }
            pub fn value_type_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.value_type_name = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for value_type_name: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<ProgrammaticScryptoSborValueMap>
        for super::ProgrammaticScryptoSborValueMap {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ProgrammaticScryptoSborValueMap,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    entries: value.entries?,
                    field_name: value.field_name?,
                    key_kind: value.key_kind?,
                    key_type_name: value.key_type_name?,
                    kind: value.kind?,
                    type_name: value.type_name?,
                    value_kind: value.value_kind?,
                    value_type_name: value.value_type_name?,
                })
            }
        }
        impl From<super::ProgrammaticScryptoSborValueMap>
        for ProgrammaticScryptoSborValueMap {
            fn from(value: super::ProgrammaticScryptoSborValueMap) -> Self {
                Self {
                    entries: Ok(value.entries),
                    field_name: Ok(value.field_name),
                    key_kind: Ok(value.key_kind),
                    key_type_name: Ok(value.key_type_name),
                    kind: Ok(value.kind),
                    type_name: Ok(value.type_name),
                    value_kind: Ok(value.value_kind),
                    value_type_name: Ok(value.value_type_name),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ProgrammaticScryptoSborValueMapEntry {
            key: Result<super::ProgrammaticScryptoSborValue, String>,
            value: Result<super::ProgrammaticScryptoSborValue, String>,
        }
        impl Default for ProgrammaticScryptoSborValueMapEntry {
            fn default() -> Self {
                Self {
                    key: Err("no value supplied for key".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl ProgrammaticScryptoSborValueMapEntry {
            pub fn key<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ProgrammaticScryptoSborValue>,
                T::Error: std::fmt::Display,
            {
                self.key = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for key: {}", e)
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ProgrammaticScryptoSborValue>,
                T::Error: std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<ProgrammaticScryptoSborValueMapEntry>
        for super::ProgrammaticScryptoSborValueMapEntry {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ProgrammaticScryptoSborValueMapEntry,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    key: value.key?,
                    value: value.value?,
                })
            }
        }
        impl From<super::ProgrammaticScryptoSborValueMapEntry>
        for ProgrammaticScryptoSborValueMapEntry {
            fn from(value: super::ProgrammaticScryptoSborValueMapEntry) -> Self {
                Self {
                    key: Ok(value.key),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ProgrammaticScryptoSborValueNonFungibleLocalId {
            field_name: Result<Option<String>, String>,
            kind: Result<
                super::ProgrammaticScryptoSborValueNonFungibleLocalIdKind,
                String,
            >,
            type_name: Result<Option<String>, String>,
            value: Result<String, String>,
        }
        impl Default for ProgrammaticScryptoSborValueNonFungibleLocalId {
            fn default() -> Self {
                Self {
                    field_name: Ok(Default::default()),
                    kind: Err("no value supplied for kind".to_string()),
                    type_name: Ok(Default::default()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl ProgrammaticScryptoSborValueNonFungibleLocalId {
            pub fn field_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.field_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for field_name: {}", e)
                    });
                self
            }
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::ProgrammaticScryptoSborValueNonFungibleLocalIdKind,
                >,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for kind: {}", e)
                    });
                self
            }
            pub fn type_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.type_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_name: {}", e)
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<ProgrammaticScryptoSborValueNonFungibleLocalId>
        for super::ProgrammaticScryptoSborValueNonFungibleLocalId {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ProgrammaticScryptoSborValueNonFungibleLocalId,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    field_name: value.field_name?,
                    kind: value.kind?,
                    type_name: value.type_name?,
                    value: value.value?,
                })
            }
        }
        impl From<super::ProgrammaticScryptoSborValueNonFungibleLocalId>
        for ProgrammaticScryptoSborValueNonFungibleLocalId {
            fn from(
                value: super::ProgrammaticScryptoSborValueNonFungibleLocalId,
            ) -> Self {
                Self {
                    field_name: Ok(value.field_name),
                    kind: Ok(value.kind),
                    type_name: Ok(value.type_name),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ProgrammaticScryptoSborValueOwn {
            field_name: Result<Option<String>, String>,
            kind: Result<super::ProgrammaticScryptoSborValueOwnKind, String>,
            type_name: Result<Option<String>, String>,
            value: Result<super::Address, String>,
        }
        impl Default for ProgrammaticScryptoSborValueOwn {
            fn default() -> Self {
                Self {
                    field_name: Ok(Default::default()),
                    kind: Err("no value supplied for kind".to_string()),
                    type_name: Ok(Default::default()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl ProgrammaticScryptoSborValueOwn {
            pub fn field_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.field_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for field_name: {}", e)
                    });
                self
            }
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ProgrammaticScryptoSborValueOwnKind>,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for kind: {}", e)
                    });
                self
            }
            pub fn type_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.type_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_name: {}", e)
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<ProgrammaticScryptoSborValueOwn>
        for super::ProgrammaticScryptoSborValueOwn {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ProgrammaticScryptoSborValueOwn,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    field_name: value.field_name?,
                    kind: value.kind?,
                    type_name: value.type_name?,
                    value: value.value?,
                })
            }
        }
        impl From<super::ProgrammaticScryptoSborValueOwn>
        for ProgrammaticScryptoSborValueOwn {
            fn from(value: super::ProgrammaticScryptoSborValueOwn) -> Self {
                Self {
                    field_name: Ok(value.field_name),
                    kind: Ok(value.kind),
                    type_name: Ok(value.type_name),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ProgrammaticScryptoSborValuePreciseDecimal {
            field_name: Result<Option<String>, String>,
            kind: Result<super::ProgrammaticScryptoSborValuePreciseDecimalKind, String>,
            type_name: Result<Option<String>, String>,
            value: Result<String, String>,
        }
        impl Default for ProgrammaticScryptoSborValuePreciseDecimal {
            fn default() -> Self {
                Self {
                    field_name: Ok(Default::default()),
                    kind: Err("no value supplied for kind".to_string()),
                    type_name: Ok(Default::default()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl ProgrammaticScryptoSborValuePreciseDecimal {
            pub fn field_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.field_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for field_name: {}", e)
                    });
                self
            }
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::ProgrammaticScryptoSborValuePreciseDecimalKind,
                >,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for kind: {}", e)
                    });
                self
            }
            pub fn type_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.type_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_name: {}", e)
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<ProgrammaticScryptoSborValuePreciseDecimal>
        for super::ProgrammaticScryptoSborValuePreciseDecimal {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ProgrammaticScryptoSborValuePreciseDecimal,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    field_name: value.field_name?,
                    kind: value.kind?,
                    type_name: value.type_name?,
                    value: value.value?,
                })
            }
        }
        impl From<super::ProgrammaticScryptoSborValuePreciseDecimal>
        for ProgrammaticScryptoSborValuePreciseDecimal {
            fn from(value: super::ProgrammaticScryptoSborValuePreciseDecimal) -> Self {
                Self {
                    field_name: Ok(value.field_name),
                    kind: Ok(value.kind),
                    type_name: Ok(value.type_name),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ProgrammaticScryptoSborValueReference {
            field_name: Result<Option<String>, String>,
            kind: Result<super::ProgrammaticScryptoSborValueReferenceKind, String>,
            type_name: Result<Option<String>, String>,
            value: Result<super::Address, String>,
        }
        impl Default for ProgrammaticScryptoSborValueReference {
            fn default() -> Self {
                Self {
                    field_name: Ok(Default::default()),
                    kind: Err("no value supplied for kind".to_string()),
                    type_name: Ok(Default::default()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl ProgrammaticScryptoSborValueReference {
            pub fn field_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.field_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for field_name: {}", e)
                    });
                self
            }
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::ProgrammaticScryptoSborValueReferenceKind,
                >,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for kind: {}", e)
                    });
                self
            }
            pub fn type_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.type_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_name: {}", e)
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<ProgrammaticScryptoSborValueReference>
        for super::ProgrammaticScryptoSborValueReference {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ProgrammaticScryptoSborValueReference,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    field_name: value.field_name?,
                    kind: value.kind?,
                    type_name: value.type_name?,
                    value: value.value?,
                })
            }
        }
        impl From<super::ProgrammaticScryptoSborValueReference>
        for ProgrammaticScryptoSborValueReference {
            fn from(value: super::ProgrammaticScryptoSborValueReference) -> Self {
                Self {
                    field_name: Ok(value.field_name),
                    kind: Ok(value.kind),
                    type_name: Ok(value.type_name),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ProgrammaticScryptoSborValueString {
            field_name: Result<Option<String>, String>,
            kind: Result<super::ProgrammaticScryptoSborValueStringKind, String>,
            type_name: Result<Option<String>, String>,
            value: Result<String, String>,
        }
        impl Default for ProgrammaticScryptoSborValueString {
            fn default() -> Self {
                Self {
                    field_name: Ok(Default::default()),
                    kind: Err("no value supplied for kind".to_string()),
                    type_name: Ok(Default::default()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl ProgrammaticScryptoSborValueString {
            pub fn field_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.field_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for field_name: {}", e)
                    });
                self
            }
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ProgrammaticScryptoSborValueStringKind>,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for kind: {}", e)
                    });
                self
            }
            pub fn type_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.type_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_name: {}", e)
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<ProgrammaticScryptoSborValueString>
        for super::ProgrammaticScryptoSborValueString {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ProgrammaticScryptoSborValueString,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    field_name: value.field_name?,
                    kind: value.kind?,
                    type_name: value.type_name?,
                    value: value.value?,
                })
            }
        }
        impl From<super::ProgrammaticScryptoSborValueString>
        for ProgrammaticScryptoSborValueString {
            fn from(value: super::ProgrammaticScryptoSborValueString) -> Self {
                Self {
                    field_name: Ok(value.field_name),
                    kind: Ok(value.kind),
                    type_name: Ok(value.type_name),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ProgrammaticScryptoSborValueTuple {
            field_name: Result<Option<String>, String>,
            fields: Result<Vec<super::ProgrammaticScryptoSborValue>, String>,
            kind: Result<super::ProgrammaticScryptoSborValueTupleKind, String>,
            type_name: Result<Option<String>, String>,
        }
        impl Default for ProgrammaticScryptoSborValueTuple {
            fn default() -> Self {
                Self {
                    field_name: Ok(Default::default()),
                    fields: Err("no value supplied for fields".to_string()),
                    kind: Err("no value supplied for kind".to_string()),
                    type_name: Ok(Default::default()),
                }
            }
        }
        impl ProgrammaticScryptoSborValueTuple {
            pub fn field_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.field_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for field_name: {}", e)
                    });
                self
            }
            pub fn fields<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::ProgrammaticScryptoSborValue>>,
                T::Error: std::fmt::Display,
            {
                self.fields = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for fields: {}", e)
                    });
                self
            }
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ProgrammaticScryptoSborValueTupleKind>,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for kind: {}", e)
                    });
                self
            }
            pub fn type_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.type_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_name: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<ProgrammaticScryptoSborValueTuple>
        for super::ProgrammaticScryptoSborValueTuple {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ProgrammaticScryptoSborValueTuple,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    field_name: value.field_name?,
                    fields: value.fields?,
                    kind: value.kind?,
                    type_name: value.type_name?,
                })
            }
        }
        impl From<super::ProgrammaticScryptoSborValueTuple>
        for ProgrammaticScryptoSborValueTuple {
            fn from(value: super::ProgrammaticScryptoSborValueTuple) -> Self {
                Self {
                    field_name: Ok(value.field_name),
                    fields: Ok(value.fields),
                    kind: Ok(value.kind),
                    type_name: Ok(value.type_name),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ProgrammaticScryptoSborValueU128 {
            field_name: Result<Option<String>, String>,
            kind: Result<super::ProgrammaticScryptoSborValueU128Kind, String>,
            type_name: Result<Option<String>, String>,
            value: Result<String, String>,
        }
        impl Default for ProgrammaticScryptoSborValueU128 {
            fn default() -> Self {
                Self {
                    field_name: Ok(Default::default()),
                    kind: Err("no value supplied for kind".to_string()),
                    type_name: Ok(Default::default()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl ProgrammaticScryptoSborValueU128 {
            pub fn field_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.field_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for field_name: {}", e)
                    });
                self
            }
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ProgrammaticScryptoSborValueU128Kind>,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for kind: {}", e)
                    });
                self
            }
            pub fn type_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.type_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_name: {}", e)
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<ProgrammaticScryptoSborValueU128>
        for super::ProgrammaticScryptoSborValueU128 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ProgrammaticScryptoSborValueU128,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    field_name: value.field_name?,
                    kind: value.kind?,
                    type_name: value.type_name?,
                    value: value.value?,
                })
            }
        }
        impl From<super::ProgrammaticScryptoSborValueU128>
        for ProgrammaticScryptoSborValueU128 {
            fn from(value: super::ProgrammaticScryptoSborValueU128) -> Self {
                Self {
                    field_name: Ok(value.field_name),
                    kind: Ok(value.kind),
                    type_name: Ok(value.type_name),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ProgrammaticScryptoSborValueU16 {
            field_name: Result<Option<String>, String>,
            kind: Result<super::ProgrammaticScryptoSborValueU16Kind, String>,
            type_name: Result<Option<String>, String>,
            value: Result<String, String>,
        }
        impl Default for ProgrammaticScryptoSborValueU16 {
            fn default() -> Self {
                Self {
                    field_name: Ok(Default::default()),
                    kind: Err("no value supplied for kind".to_string()),
                    type_name: Ok(Default::default()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl ProgrammaticScryptoSborValueU16 {
            pub fn field_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.field_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for field_name: {}", e)
                    });
                self
            }
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ProgrammaticScryptoSborValueU16Kind>,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for kind: {}", e)
                    });
                self
            }
            pub fn type_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.type_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_name: {}", e)
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<ProgrammaticScryptoSborValueU16>
        for super::ProgrammaticScryptoSborValueU16 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ProgrammaticScryptoSborValueU16,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    field_name: value.field_name?,
                    kind: value.kind?,
                    type_name: value.type_name?,
                    value: value.value?,
                })
            }
        }
        impl From<super::ProgrammaticScryptoSborValueU16>
        for ProgrammaticScryptoSborValueU16 {
            fn from(value: super::ProgrammaticScryptoSborValueU16) -> Self {
                Self {
                    field_name: Ok(value.field_name),
                    kind: Ok(value.kind),
                    type_name: Ok(value.type_name),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ProgrammaticScryptoSborValueU32 {
            field_name: Result<Option<String>, String>,
            kind: Result<super::ProgrammaticScryptoSborValueU32Kind, String>,
            type_name: Result<Option<String>, String>,
            value: Result<String, String>,
        }
        impl Default for ProgrammaticScryptoSborValueU32 {
            fn default() -> Self {
                Self {
                    field_name: Ok(Default::default()),
                    kind: Err("no value supplied for kind".to_string()),
                    type_name: Ok(Default::default()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl ProgrammaticScryptoSborValueU32 {
            pub fn field_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.field_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for field_name: {}", e)
                    });
                self
            }
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ProgrammaticScryptoSborValueU32Kind>,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for kind: {}", e)
                    });
                self
            }
            pub fn type_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.type_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_name: {}", e)
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<ProgrammaticScryptoSborValueU32>
        for super::ProgrammaticScryptoSborValueU32 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ProgrammaticScryptoSborValueU32,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    field_name: value.field_name?,
                    kind: value.kind?,
                    type_name: value.type_name?,
                    value: value.value?,
                })
            }
        }
        impl From<super::ProgrammaticScryptoSborValueU32>
        for ProgrammaticScryptoSborValueU32 {
            fn from(value: super::ProgrammaticScryptoSborValueU32) -> Self {
                Self {
                    field_name: Ok(value.field_name),
                    kind: Ok(value.kind),
                    type_name: Ok(value.type_name),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ProgrammaticScryptoSborValueU64 {
            field_name: Result<Option<String>, String>,
            kind: Result<super::ProgrammaticScryptoSborValueU64Kind, String>,
            type_name: Result<Option<String>, String>,
            value: Result<String, String>,
        }
        impl Default for ProgrammaticScryptoSborValueU64 {
            fn default() -> Self {
                Self {
                    field_name: Ok(Default::default()),
                    kind: Err("no value supplied for kind".to_string()),
                    type_name: Ok(Default::default()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl ProgrammaticScryptoSborValueU64 {
            pub fn field_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.field_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for field_name: {}", e)
                    });
                self
            }
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ProgrammaticScryptoSborValueU64Kind>,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for kind: {}", e)
                    });
                self
            }
            pub fn type_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.type_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_name: {}", e)
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<ProgrammaticScryptoSborValueU64>
        for super::ProgrammaticScryptoSborValueU64 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ProgrammaticScryptoSborValueU64,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    field_name: value.field_name?,
                    kind: value.kind?,
                    type_name: value.type_name?,
                    value: value.value?,
                })
            }
        }
        impl From<super::ProgrammaticScryptoSborValueU64>
        for ProgrammaticScryptoSborValueU64 {
            fn from(value: super::ProgrammaticScryptoSborValueU64) -> Self {
                Self {
                    field_name: Ok(value.field_name),
                    kind: Ok(value.kind),
                    type_name: Ok(value.type_name),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ProgrammaticScryptoSborValueU8 {
            field_name: Result<Option<String>, String>,
            kind: Result<super::ProgrammaticScryptoSborValueU8Kind, String>,
            type_name: Result<Option<String>, String>,
            value: Result<String, String>,
        }
        impl Default for ProgrammaticScryptoSborValueU8 {
            fn default() -> Self {
                Self {
                    field_name: Ok(Default::default()),
                    kind: Err("no value supplied for kind".to_string()),
                    type_name: Ok(Default::default()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl ProgrammaticScryptoSborValueU8 {
            pub fn field_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.field_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for field_name: {}", e)
                    });
                self
            }
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ProgrammaticScryptoSborValueU8Kind>,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for kind: {}", e)
                    });
                self
            }
            pub fn type_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.type_name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_name: {}", e)
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<ProgrammaticScryptoSborValueU8>
        for super::ProgrammaticScryptoSborValueU8 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ProgrammaticScryptoSborValueU8,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    field_name: value.field_name?,
                    kind: value.kind?,
                    type_name: value.type_name?,
                    value: value.value?,
                })
            }
        }
        impl From<super::ProgrammaticScryptoSborValueU8>
        for ProgrammaticScryptoSborValueU8 {
            fn from(value: super::ProgrammaticScryptoSborValueU8) -> Self {
                Self {
                    field_name: Ok(value.field_name),
                    kind: Ok(value.kind),
                    type_name: Ok(value.type_name),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PublicKeyBase {
            key_type: Result<super::PublicKeyType, String>,
        }
        impl Default for PublicKeyBase {
            fn default() -> Self {
                Self {
                    key_type: Err("no value supplied for key_type".to_string()),
                }
            }
        }
        impl PublicKeyBase {
            pub fn key_type<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::PublicKeyType>,
                T::Error: std::fmt::Display,
            {
                self.key_type = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for key_type: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<PublicKeyBase> for super::PublicKeyBase {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PublicKeyBase,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self { key_type: value.key_type? })
            }
        }
        impl From<super::PublicKeyBase> for PublicKeyBase {
            fn from(value: super::PublicKeyBase) -> Self {
                Self {
                    key_type: Ok(value.key_type),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PublicKeyEcdsaSecp256k1 {
            key_hex: Result<super::PublicKeyEcdsaSecp256k1KeyHex, String>,
            key_type: Result<super::PublicKeyEcdsaSecp256k1KeyType, String>,
        }
        impl Default for PublicKeyEcdsaSecp256k1 {
            fn default() -> Self {
                Self {
                    key_hex: Err("no value supplied for key_hex".to_string()),
                    key_type: Err("no value supplied for key_type".to_string()),
                }
            }
        }
        impl PublicKeyEcdsaSecp256k1 {
            pub fn key_hex<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::PublicKeyEcdsaSecp256k1KeyHex>,
                T::Error: std::fmt::Display,
            {
                self.key_hex = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for key_hex: {}", e)
                    });
                self
            }
            pub fn key_type<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::PublicKeyEcdsaSecp256k1KeyType>,
                T::Error: std::fmt::Display,
            {
                self.key_type = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for key_type: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<PublicKeyEcdsaSecp256k1>
        for super::PublicKeyEcdsaSecp256k1 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PublicKeyEcdsaSecp256k1,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    key_hex: value.key_hex?,
                    key_type: value.key_type?,
                })
            }
        }
        impl From<super::PublicKeyEcdsaSecp256k1> for PublicKeyEcdsaSecp256k1 {
            fn from(value: super::PublicKeyEcdsaSecp256k1) -> Self {
                Self {
                    key_hex: Ok(value.key_hex),
                    key_type: Ok(value.key_type),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PublicKeyEddsaEd25519 {
            key_hex: Result<super::PublicKeyEddsaEd25519KeyHex, String>,
            key_type: Result<super::PublicKeyEddsaEd25519KeyType, String>,
        }
        impl Default for PublicKeyEddsaEd25519 {
            fn default() -> Self {
                Self {
                    key_hex: Err("no value supplied for key_hex".to_string()),
                    key_type: Err("no value supplied for key_type".to_string()),
                }
            }
        }
        impl PublicKeyEddsaEd25519 {
            pub fn key_hex<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::PublicKeyEddsaEd25519KeyHex>,
                T::Error: std::fmt::Display,
            {
                self.key_hex = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for key_hex: {}", e)
                    });
                self
            }
            pub fn key_type<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::PublicKeyEddsaEd25519KeyType>,
                T::Error: std::fmt::Display,
            {
                self.key_type = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for key_type: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<PublicKeyEddsaEd25519>
        for super::PublicKeyEddsaEd25519 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PublicKeyEddsaEd25519,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    key_hex: value.key_hex?,
                    key_type: value.key_type?,
                })
            }
        }
        impl From<super::PublicKeyEddsaEd25519> for PublicKeyEddsaEd25519 {
            fn from(value: super::PublicKeyEddsaEd25519) -> Self {
                Self {
                    key_hex: Ok(value.key_hex),
                    key_type: Ok(value.key_type),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PublicKeyHashBase {
            key_hash_type: Result<super::PublicKeyHashType, String>,
        }
        impl Default for PublicKeyHashBase {
            fn default() -> Self {
                Self {
                    key_hash_type: Err("no value supplied for key_hash_type".to_string()),
                }
            }
        }
        impl PublicKeyHashBase {
            pub fn key_hash_type<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::PublicKeyHashType>,
                T::Error: std::fmt::Display,
            {
                self.key_hash_type = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for key_hash_type: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<PublicKeyHashBase> for super::PublicKeyHashBase {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PublicKeyHashBase,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    key_hash_type: value.key_hash_type?,
                })
            }
        }
        impl From<super::PublicKeyHashBase> for PublicKeyHashBase {
            fn from(value: super::PublicKeyHashBase) -> Self {
                Self {
                    key_hash_type: Ok(value.key_hash_type),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PublicKeyHashEcdsaSecp256k1 {
            hash_hex: Result<super::HashHexString, String>,
            key_hash_type: Result<super::PublicKeyHashEcdsaSecp256k1KeyHashType, String>,
        }
        impl Default for PublicKeyHashEcdsaSecp256k1 {
            fn default() -> Self {
                Self {
                    hash_hex: Err("no value supplied for hash_hex".to_string()),
                    key_hash_type: Err("no value supplied for key_hash_type".to_string()),
                }
            }
        }
        impl PublicKeyHashEcdsaSecp256k1 {
            pub fn hash_hex<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::HashHexString>,
                T::Error: std::fmt::Display,
            {
                self.hash_hex = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for hash_hex: {}", e)
                    });
                self
            }
            pub fn key_hash_type<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::PublicKeyHashEcdsaSecp256k1KeyHashType>,
                T::Error: std::fmt::Display,
            {
                self.key_hash_type = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for key_hash_type: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<PublicKeyHashEcdsaSecp256k1>
        for super::PublicKeyHashEcdsaSecp256k1 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PublicKeyHashEcdsaSecp256k1,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    hash_hex: value.hash_hex?,
                    key_hash_type: value.key_hash_type?,
                })
            }
        }
        impl From<super::PublicKeyHashEcdsaSecp256k1> for PublicKeyHashEcdsaSecp256k1 {
            fn from(value: super::PublicKeyHashEcdsaSecp256k1) -> Self {
                Self {
                    hash_hex: Ok(value.hash_hex),
                    key_hash_type: Ok(value.key_hash_type),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PublicKeyHashEddsaEd25519 {
            hash_hex: Result<super::HashHexString, String>,
            key_hash_type: Result<super::PublicKeyHashEddsaEd25519KeyHashType, String>,
        }
        impl Default for PublicKeyHashEddsaEd25519 {
            fn default() -> Self {
                Self {
                    hash_hex: Err("no value supplied for hash_hex".to_string()),
                    key_hash_type: Err("no value supplied for key_hash_type".to_string()),
                }
            }
        }
        impl PublicKeyHashEddsaEd25519 {
            pub fn hash_hex<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::HashHexString>,
                T::Error: std::fmt::Display,
            {
                self.hash_hex = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for hash_hex: {}", e)
                    });
                self
            }
            pub fn key_hash_type<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::PublicKeyHashEddsaEd25519KeyHashType>,
                T::Error: std::fmt::Display,
            {
                self.key_hash_type = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for key_hash_type: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<PublicKeyHashEddsaEd25519>
        for super::PublicKeyHashEddsaEd25519 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PublicKeyHashEddsaEd25519,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    hash_hex: value.hash_hex?,
                    key_hash_type: value.key_hash_type?,
                })
            }
        }
        impl From<super::PublicKeyHashEddsaEd25519> for PublicKeyHashEddsaEd25519 {
            fn from(value: super::PublicKeyHashEddsaEd25519) -> Self {
                Self {
                    hash_hex: Ok(value.hash_hex),
                    key_hash_type: Ok(value.key_hash_type),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ResourceHoldersCollection {
            items: Result<Vec<super::ResourceHoldersCollectionItem>, String>,
            next_cursor: Result<Option<String>, String>,
            total_count: Result<Option<i64>, String>,
        }
        impl Default for ResourceHoldersCollection {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_cursor: Ok(Default::default()),
                    total_count: Ok(Default::default()),
                }
            }
        }
        impl ResourceHoldersCollection {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::ResourceHoldersCollectionItem>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {}", e)
                    });
                self
            }
            pub fn next_cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for next_cursor: {}", e)
                    });
                self
            }
            pub fn total_count<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.total_count = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for total_count: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<ResourceHoldersCollection>
        for super::ResourceHoldersCollection {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ResourceHoldersCollection,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_cursor: value.next_cursor?,
                    total_count: value.total_count?,
                })
            }
        }
        impl From<super::ResourceHoldersCollection> for ResourceHoldersCollection {
            fn from(value: super::ResourceHoldersCollection) -> Self {
                Self {
                    items: Ok(value.items),
                    next_cursor: Ok(value.next_cursor),
                    total_count: Ok(value.total_count),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ResourceHoldersCollectionFungibleResourceItem {
            amount: Result<super::BigDecimal, String>,
            holder_address: Result<super::Address, String>,
            last_updated_at_state_version: Result<i64, String>,
            type_: Result<
                super::ResourceHoldersCollectionFungibleResourceItemType,
                String,
            >,
        }
        impl Default for ResourceHoldersCollectionFungibleResourceItem {
            fn default() -> Self {
                Self {
                    amount: Err("no value supplied for amount".to_string()),
                    holder_address: Err(
                        "no value supplied for holder_address".to_string(),
                    ),
                    last_updated_at_state_version: Err(
                        "no value supplied for last_updated_at_state_version".to_string(),
                    ),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl ResourceHoldersCollectionFungibleResourceItem {
            pub fn amount<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::BigDecimal>,
                T::Error: std::fmt::Display,
            {
                self.amount = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for amount: {}", e)
                    });
                self
            }
            pub fn holder_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.holder_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for holder_address: {}", e
                        )
                    });
                self
            }
            pub fn last_updated_at_state_version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<i64>,
                T::Error: std::fmt::Display,
            {
                self.last_updated_at_state_version = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for last_updated_at_state_version: {}",
                            e
                        )
                    });
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::ResourceHoldersCollectionFungibleResourceItemType,
                >,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<ResourceHoldersCollectionFungibleResourceItem>
        for super::ResourceHoldersCollectionFungibleResourceItem {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ResourceHoldersCollectionFungibleResourceItem,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    amount: value.amount?,
                    holder_address: value.holder_address?,
                    last_updated_at_state_version: value.last_updated_at_state_version?,
                    type_: value.type_?,
                })
            }
        }
        impl From<super::ResourceHoldersCollectionFungibleResourceItem>
        for ResourceHoldersCollectionFungibleResourceItem {
            fn from(
                value: super::ResourceHoldersCollectionFungibleResourceItem,
            ) -> Self {
                Self {
                    amount: Ok(value.amount),
                    holder_address: Ok(value.holder_address),
                    last_updated_at_state_version: Ok(
                        value.last_updated_at_state_version,
                    ),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ResourceHoldersCollectionItemBase {
            holder_address: Result<super::Address, String>,
            last_updated_at_state_version: Result<i64, String>,
            type_: Result<super::ResourceHoldersResourceType, String>,
        }
        impl Default for ResourceHoldersCollectionItemBase {
            fn default() -> Self {
                Self {
                    holder_address: Err(
                        "no value supplied for holder_address".to_string(),
                    ),
                    last_updated_at_state_version: Err(
                        "no value supplied for last_updated_at_state_version".to_string(),
                    ),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl ResourceHoldersCollectionItemBase {
            pub fn holder_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.holder_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for holder_address: {}", e
                        )
                    });
                self
            }
            pub fn last_updated_at_state_version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<i64>,
                T::Error: std::fmt::Display,
            {
                self.last_updated_at_state_version = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for last_updated_at_state_version: {}",
                            e
                        )
                    });
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ResourceHoldersResourceType>,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<ResourceHoldersCollectionItemBase>
        for super::ResourceHoldersCollectionItemBase {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ResourceHoldersCollectionItemBase,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    holder_address: value.holder_address?,
                    last_updated_at_state_version: value.last_updated_at_state_version?,
                    type_: value.type_?,
                })
            }
        }
        impl From<super::ResourceHoldersCollectionItemBase>
        for ResourceHoldersCollectionItemBase {
            fn from(value: super::ResourceHoldersCollectionItemBase) -> Self {
                Self {
                    holder_address: Ok(value.holder_address),
                    last_updated_at_state_version: Ok(
                        value.last_updated_at_state_version,
                    ),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ResourceHoldersCollectionNonFungibleResourceItem {
            holder_address: Result<super::Address, String>,
            last_updated_at_state_version: Result<i64, String>,
            non_fungible_ids_count: Result<i64, String>,
            type_: Result<
                super::ResourceHoldersCollectionNonFungibleResourceItemType,
                String,
            >,
        }
        impl Default for ResourceHoldersCollectionNonFungibleResourceItem {
            fn default() -> Self {
                Self {
                    holder_address: Err(
                        "no value supplied for holder_address".to_string(),
                    ),
                    last_updated_at_state_version: Err(
                        "no value supplied for last_updated_at_state_version".to_string(),
                    ),
                    non_fungible_ids_count: Err(
                        "no value supplied for non_fungible_ids_count".to_string(),
                    ),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl ResourceHoldersCollectionNonFungibleResourceItem {
            pub fn holder_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.holder_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for holder_address: {}", e
                        )
                    });
                self
            }
            pub fn last_updated_at_state_version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<i64>,
                T::Error: std::fmt::Display,
            {
                self.last_updated_at_state_version = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for last_updated_at_state_version: {}",
                            e
                        )
                    });
                self
            }
            pub fn non_fungible_ids_count<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<i64>,
                T::Error: std::fmt::Display,
            {
                self.non_fungible_ids_count = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for non_fungible_ids_count: {}",
                            e
                        )
                    });
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::ResourceHoldersCollectionNonFungibleResourceItemType,
                >,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<ResourceHoldersCollectionNonFungibleResourceItem>
        for super::ResourceHoldersCollectionNonFungibleResourceItem {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ResourceHoldersCollectionNonFungibleResourceItem,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    holder_address: value.holder_address?,
                    last_updated_at_state_version: value.last_updated_at_state_version?,
                    non_fungible_ids_count: value.non_fungible_ids_count?,
                    type_: value.type_?,
                })
            }
        }
        impl From<super::ResourceHoldersCollectionNonFungibleResourceItem>
        for ResourceHoldersCollectionNonFungibleResourceItem {
            fn from(
                value: super::ResourceHoldersCollectionNonFungibleResourceItem,
            ) -> Self {
                Self {
                    holder_address: Ok(value.holder_address),
                    last_updated_at_state_version: Ok(
                        value.last_updated_at_state_version,
                    ),
                    non_fungible_ids_count: Ok(value.non_fungible_ids_count),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ResourceHoldersRequest {
            cursor: Result<Option<String>, String>,
            limit_per_page: Result<Option<i64>, String>,
            resource_address: Result<Option<super::Address>, String>,
        }
        impl Default for ResourceHoldersRequest {
            fn default() -> Self {
                Self {
                    cursor: Ok(Default::default()),
                    limit_per_page: Ok(Default::default()),
                    resource_address: Ok(Default::default()),
                }
            }
        }
        impl ResourceHoldersRequest {
            pub fn cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for cursor: {}", e)
                    });
                self
            }
            pub fn limit_per_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.limit_per_page = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for limit_per_page: {}", e
                        )
                    });
                self
            }
            pub fn resource_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::Address>>,
                T::Error: std::fmt::Display,
            {
                self.resource_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_address: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<ResourceHoldersRequest>
        for super::ResourceHoldersRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ResourceHoldersRequest,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    cursor: value.cursor?,
                    limit_per_page: value.limit_per_page?,
                    resource_address: value.resource_address?,
                })
            }
        }
        impl From<super::ResourceHoldersRequest> for ResourceHoldersRequest {
            fn from(value: super::ResourceHoldersRequest) -> Self {
                Self {
                    cursor: Ok(value.cursor),
                    limit_per_page: Ok(value.limit_per_page),
                    resource_address: Ok(value.resource_address),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ResultSetCursorMixin {
            next_cursor: Result<Option<String>, String>,
            total_count: Result<Option<i64>, String>,
        }
        impl Default for ResultSetCursorMixin {
            fn default() -> Self {
                Self {
                    next_cursor: Ok(Default::default()),
                    total_count: Ok(Default::default()),
                }
            }
        }
        impl ResultSetCursorMixin {
            pub fn next_cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for next_cursor: {}", e)
                    });
                self
            }
            pub fn total_count<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.total_count = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for total_count: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<ResultSetCursorMixin>
        for super::ResultSetCursorMixin {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ResultSetCursorMixin,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    next_cursor: value.next_cursor?,
                    total_count: value.total_count?,
                })
            }
        }
        impl From<super::ResultSetCursorMixin> for ResultSetCursorMixin {
            fn from(value: super::ResultSetCursorMixin) -> Self {
                Self {
                    next_cursor: Ok(value.next_cursor),
                    total_count: Ok(value.total_count),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct RoleKey {
            module: Result<super::ObjectModuleId, String>,
            name: Result<String, String>,
        }
        impl Default for RoleKey {
            fn default() -> Self {
                Self {
                    module: Err("no value supplied for module".to_string()),
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }
        impl RoleKey {
            pub fn module<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ObjectModuleId>,
                T::Error: std::fmt::Display,
            {
                self.module = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for module: {}", e)
                    });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for name: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<RoleKey> for super::RoleKey {
            type Error = super::error::ConversionError;
            fn try_from(value: RoleKey) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    module: value.module?,
                    name: value.name?,
                })
            }
        }
        impl From<super::RoleKey> for RoleKey {
            fn from(value: super::RoleKey) -> Self {
                Self {
                    module: Ok(value.module),
                    name: Ok(value.name),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct RoyaltyAmount {
            amount: Result<super::BigDecimal, String>,
            unit: Result<super::RoyaltyAmountUnit, String>,
        }
        impl Default for RoyaltyAmount {
            fn default() -> Self {
                Self {
                    amount: Err("no value supplied for amount".to_string()),
                    unit: Err("no value supplied for unit".to_string()),
                }
            }
        }
        impl RoyaltyAmount {
            pub fn amount<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::BigDecimal>,
                T::Error: std::fmt::Display,
            {
                self.amount = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for amount: {}", e)
                    });
                self
            }
            pub fn unit<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::RoyaltyAmountUnit>,
                T::Error: std::fmt::Display,
            {
                self.unit = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for unit: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<RoyaltyAmount> for super::RoyaltyAmount {
            type Error = super::error::ConversionError;
            fn try_from(
                value: RoyaltyAmount,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    amount: value.amount?,
                    unit: value.unit?,
                })
            }
        }
        impl From<super::RoyaltyAmount> for RoyaltyAmount {
            fn from(value: super::RoyaltyAmount) -> Self {
                Self {
                    amount: Ok(value.amount),
                    unit: Ok(value.unit),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SborData {
            hex: Result<super::HexString, String>,
            programmatic_json: Result<::serde_json::Value, String>,
        }
        impl Default for SborData {
            fn default() -> Self {
                Self {
                    hex: Err("no value supplied for hex".to_string()),
                    programmatic_json: Err(
                        "no value supplied for programmatic_json".to_string(),
                    ),
                }
            }
        }
        impl SborData {
            pub fn hex<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::HexString>,
                T::Error: std::fmt::Display,
            {
                self.hex = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for hex: {}", e)
                    });
                self
            }
            pub fn programmatic_json<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<::serde_json::Value>,
                T::Error: std::fmt::Display,
            {
                self.programmatic_json = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for programmatic_json: {}",
                            e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<SborData> for super::SborData {
            type Error = super::error::ConversionError;
            fn try_from(value: SborData) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    hex: value.hex?,
                    programmatic_json: value.programmatic_json?,
                })
            }
        }
        impl From<super::SborData> for SborData {
            fn from(value: super::SborData) -> Self {
                Self {
                    hex: Ok(value.hex),
                    programmatic_json: Ok(value.programmatic_json),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ScryptoSborValue {
            programmatic_json: Result<super::ProgrammaticScryptoSborValue, String>,
            raw_hex: Result<super::HexString, String>,
        }
        impl Default for ScryptoSborValue {
            fn default() -> Self {
                Self {
                    programmatic_json: Err(
                        "no value supplied for programmatic_json".to_string(),
                    ),
                    raw_hex: Err("no value supplied for raw_hex".to_string()),
                }
            }
        }
        impl ScryptoSborValue {
            pub fn programmatic_json<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ProgrammaticScryptoSborValue>,
                T::Error: std::fmt::Display,
            {
                self.programmatic_json = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for programmatic_json: {}",
                            e
                        )
                    });
                self
            }
            pub fn raw_hex<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::HexString>,
                T::Error: std::fmt::Display,
            {
                self.raw_hex = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for raw_hex: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<ScryptoSborValue> for super::ScryptoSborValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ScryptoSborValue,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    programmatic_json: value.programmatic_json?,
                    raw_hex: value.raw_hex?,
                })
            }
        }
        impl From<super::ScryptoSborValue> for ScryptoSborValue {
            fn from(value: super::ScryptoSborValue) -> Self {
                Self {
                    programmatic_json: Ok(value.programmatic_json),
                    raw_hex: Ok(value.raw_hex),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateAccountAuthorizedDepositorsPageRequest {
            account_address: Result<super::Address, String>,
            at_ledger_state: Result<Option<super::LedgerStateSelector>, String>,
            cursor: Result<Option<String>, String>,
            limit_per_page: Result<Option<i64>, String>,
        }
        impl Default for StateAccountAuthorizedDepositorsPageRequest {
            fn default() -> Self {
                Self {
                    account_address: Err(
                        "no value supplied for account_address".to_string(),
                    ),
                    at_ledger_state: Ok(Default::default()),
                    cursor: Ok(Default::default()),
                    limit_per_page: Ok(Default::default()),
                }
            }
        }
        impl StateAccountAuthorizedDepositorsPageRequest {
            pub fn account_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.account_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for account_address: {}", e
                        )
                    });
                self
            }
            pub fn at_ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::LedgerStateSelector>>,
                T::Error: std::fmt::Display,
            {
                self.at_ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for at_ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for cursor: {}", e)
                    });
                self
            }
            pub fn limit_per_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.limit_per_page = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for limit_per_page: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateAccountAuthorizedDepositorsPageRequest>
        for super::StateAccountAuthorizedDepositorsPageRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateAccountAuthorizedDepositorsPageRequest,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    account_address: value.account_address?,
                    at_ledger_state: value.at_ledger_state?,
                    cursor: value.cursor?,
                    limit_per_page: value.limit_per_page?,
                })
            }
        }
        impl From<super::StateAccountAuthorizedDepositorsPageRequest>
        for StateAccountAuthorizedDepositorsPageRequest {
            fn from(value: super::StateAccountAuthorizedDepositorsPageRequest) -> Self {
                Self {
                    account_address: Ok(value.account_address),
                    at_ledger_state: Ok(value.at_ledger_state),
                    cursor: Ok(value.cursor),
                    limit_per_page: Ok(value.limit_per_page),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateAccountAuthorizedDepositorsPageResponse {
            account_address: Result<super::Address, String>,
            items: Result<Vec<super::AccountAuthorizedDepositorsResponseItem>, String>,
            ledger_state: Result<super::LedgerState, String>,
            next_cursor: Result<Option<String>, String>,
            total_count: Result<Option<i64>, String>,
        }
        impl Default for StateAccountAuthorizedDepositorsPageResponse {
            fn default() -> Self {
                Self {
                    account_address: Err(
                        "no value supplied for account_address".to_string(),
                    ),
                    items: Err("no value supplied for items".to_string()),
                    ledger_state: Err("no value supplied for ledger_state".to_string()),
                    next_cursor: Ok(Default::default()),
                    total_count: Ok(Default::default()),
                }
            }
        }
        impl StateAccountAuthorizedDepositorsPageResponse {
            pub fn account_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.account_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for account_address: {}", e
                        )
                    });
                self
            }
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    Vec<super::AccountAuthorizedDepositorsResponseItem>,
                >,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {}", e)
                    });
                self
            }
            pub fn ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::LedgerState>,
                T::Error: std::fmt::Display,
            {
                self.ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn next_cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for next_cursor: {}", e)
                    });
                self
            }
            pub fn total_count<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.total_count = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for total_count: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateAccountAuthorizedDepositorsPageResponse>
        for super::StateAccountAuthorizedDepositorsPageResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateAccountAuthorizedDepositorsPageResponse,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    account_address: value.account_address?,
                    items: value.items?,
                    ledger_state: value.ledger_state?,
                    next_cursor: value.next_cursor?,
                    total_count: value.total_count?,
                })
            }
        }
        impl From<super::StateAccountAuthorizedDepositorsPageResponse>
        for StateAccountAuthorizedDepositorsPageResponse {
            fn from(value: super::StateAccountAuthorizedDepositorsPageResponse) -> Self {
                Self {
                    account_address: Ok(value.account_address),
                    items: Ok(value.items),
                    ledger_state: Ok(value.ledger_state),
                    next_cursor: Ok(value.next_cursor),
                    total_count: Ok(value.total_count),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateAccountLockerPageVaultsRequest {
            account_address: Result<super::Address, String>,
            at_ledger_state: Result<Option<super::LedgerStateSelector>, String>,
            cursor: Result<Option<String>, String>,
            limit_per_page: Result<Option<i64>, String>,
            locker_address: Result<super::Address, String>,
        }
        impl Default for StateAccountLockerPageVaultsRequest {
            fn default() -> Self {
                Self {
                    account_address: Err(
                        "no value supplied for account_address".to_string(),
                    ),
                    at_ledger_state: Ok(Default::default()),
                    cursor: Ok(Default::default()),
                    limit_per_page: Ok(Default::default()),
                    locker_address: Err(
                        "no value supplied for locker_address".to_string(),
                    ),
                }
            }
        }
        impl StateAccountLockerPageVaultsRequest {
            pub fn account_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.account_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for account_address: {}", e
                        )
                    });
                self
            }
            pub fn at_ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::LedgerStateSelector>>,
                T::Error: std::fmt::Display,
            {
                self.at_ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for at_ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for cursor: {}", e)
                    });
                self
            }
            pub fn limit_per_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.limit_per_page = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for limit_per_page: {}", e
                        )
                    });
                self
            }
            pub fn locker_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.locker_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for locker_address: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateAccountLockerPageVaultsRequest>
        for super::StateAccountLockerPageVaultsRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateAccountLockerPageVaultsRequest,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    account_address: value.account_address?,
                    at_ledger_state: value.at_ledger_state?,
                    cursor: value.cursor?,
                    limit_per_page: value.limit_per_page?,
                    locker_address: value.locker_address?,
                })
            }
        }
        impl From<super::StateAccountLockerPageVaultsRequest>
        for StateAccountLockerPageVaultsRequest {
            fn from(value: super::StateAccountLockerPageVaultsRequest) -> Self {
                Self {
                    account_address: Ok(value.account_address),
                    at_ledger_state: Ok(value.at_ledger_state),
                    cursor: Ok(value.cursor),
                    limit_per_page: Ok(value.limit_per_page),
                    locker_address: Ok(value.locker_address),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateAccountLockerPageVaultsResponse {
            account_address: Result<super::Address, String>,
            items: Result<Vec<super::AccountLockerVaultCollectionItem>, String>,
            ledger_state: Result<super::LedgerState, String>,
            locker_address: Result<super::Address, String>,
            next_cursor: Result<Option<String>, String>,
            total_count: Result<Option<i64>, String>,
        }
        impl Default for StateAccountLockerPageVaultsResponse {
            fn default() -> Self {
                Self {
                    account_address: Err(
                        "no value supplied for account_address".to_string(),
                    ),
                    items: Err("no value supplied for items".to_string()),
                    ledger_state: Err("no value supplied for ledger_state".to_string()),
                    locker_address: Err(
                        "no value supplied for locker_address".to_string(),
                    ),
                    next_cursor: Ok(Default::default()),
                    total_count: Ok(Default::default()),
                }
            }
        }
        impl StateAccountLockerPageVaultsResponse {
            pub fn account_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.account_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for account_address: {}", e
                        )
                    });
                self
            }
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::AccountLockerVaultCollectionItem>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {}", e)
                    });
                self
            }
            pub fn ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::LedgerState>,
                T::Error: std::fmt::Display,
            {
                self.ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn locker_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.locker_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for locker_address: {}", e
                        )
                    });
                self
            }
            pub fn next_cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for next_cursor: {}", e)
                    });
                self
            }
            pub fn total_count<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.total_count = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for total_count: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateAccountLockerPageVaultsResponse>
        for super::StateAccountLockerPageVaultsResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateAccountLockerPageVaultsResponse,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    account_address: value.account_address?,
                    items: value.items?,
                    ledger_state: value.ledger_state?,
                    locker_address: value.locker_address?,
                    next_cursor: value.next_cursor?,
                    total_count: value.total_count?,
                })
            }
        }
        impl From<super::StateAccountLockerPageVaultsResponse>
        for StateAccountLockerPageVaultsResponse {
            fn from(value: super::StateAccountLockerPageVaultsResponse) -> Self {
                Self {
                    account_address: Ok(value.account_address),
                    items: Ok(value.items),
                    ledger_state: Ok(value.ledger_state),
                    locker_address: Ok(value.locker_address),
                    next_cursor: Ok(value.next_cursor),
                    total_count: Ok(value.total_count),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateAccountLockersTouchedAtRequest {
            account_lockers: Result<Vec<super::AccountLockerAddress>, String>,
            at_ledger_state: Result<Option<super::LedgerStateSelector>, String>,
        }
        impl Default for StateAccountLockersTouchedAtRequest {
            fn default() -> Self {
                Self {
                    account_lockers: Err(
                        "no value supplied for account_lockers".to_string(),
                    ),
                    at_ledger_state: Ok(Default::default()),
                }
            }
        }
        impl StateAccountLockersTouchedAtRequest {
            pub fn account_lockers<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::AccountLockerAddress>>,
                T::Error: std::fmt::Display,
            {
                self.account_lockers = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for account_lockers: {}", e
                        )
                    });
                self
            }
            pub fn at_ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::LedgerStateSelector>>,
                T::Error: std::fmt::Display,
            {
                self.at_ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for at_ledger_state: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateAccountLockersTouchedAtRequest>
        for super::StateAccountLockersTouchedAtRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateAccountLockersTouchedAtRequest,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    account_lockers: value.account_lockers?,
                    at_ledger_state: value.at_ledger_state?,
                })
            }
        }
        impl From<super::StateAccountLockersTouchedAtRequest>
        for StateAccountLockersTouchedAtRequest {
            fn from(value: super::StateAccountLockersTouchedAtRequest) -> Self {
                Self {
                    account_lockers: Ok(value.account_lockers),
                    at_ledger_state: Ok(value.at_ledger_state),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateAccountLockersTouchedAtResponse {
            items: Result<Vec<super::StateAccountLockersTouchedAtResponseItem>, String>,
            ledger_state: Result<super::LedgerState, String>,
        }
        impl Default for StateAccountLockersTouchedAtResponse {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    ledger_state: Err("no value supplied for ledger_state".to_string()),
                }
            }
        }
        impl StateAccountLockersTouchedAtResponse {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    Vec<super::StateAccountLockersTouchedAtResponseItem>,
                >,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {}", e)
                    });
                self
            }
            pub fn ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::LedgerState>,
                T::Error: std::fmt::Display,
            {
                self.ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for ledger_state: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateAccountLockersTouchedAtResponse>
        for super::StateAccountLockersTouchedAtResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateAccountLockersTouchedAtResponse,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    ledger_state: value.ledger_state?,
                })
            }
        }
        impl From<super::StateAccountLockersTouchedAtResponse>
        for StateAccountLockersTouchedAtResponse {
            fn from(value: super::StateAccountLockersTouchedAtResponse) -> Self {
                Self {
                    items: Ok(value.items),
                    ledger_state: Ok(value.ledger_state),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateAccountLockersTouchedAtResponseItem {
            account_address: Result<super::Address, String>,
            last_touched_at_state_version: Result<
                super::LastUpdatedAtStateVersion,
                String,
            >,
            locker_address: Result<super::Address, String>,
        }
        impl Default for StateAccountLockersTouchedAtResponseItem {
            fn default() -> Self {
                Self {
                    account_address: Err(
                        "no value supplied for account_address".to_string(),
                    ),
                    last_touched_at_state_version: Err(
                        "no value supplied for last_touched_at_state_version".to_string(),
                    ),
                    locker_address: Err(
                        "no value supplied for locker_address".to_string(),
                    ),
                }
            }
        }
        impl StateAccountLockersTouchedAtResponseItem {
            pub fn account_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.account_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for account_address: {}", e
                        )
                    });
                self
            }
            pub fn last_touched_at_state_version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::LastUpdatedAtStateVersion>,
                T::Error: std::fmt::Display,
            {
                self.last_touched_at_state_version = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for last_touched_at_state_version: {}",
                            e
                        )
                    });
                self
            }
            pub fn locker_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.locker_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for locker_address: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateAccountLockersTouchedAtResponseItem>
        for super::StateAccountLockersTouchedAtResponseItem {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateAccountLockersTouchedAtResponseItem,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    account_address: value.account_address?,
                    last_touched_at_state_version: value.last_touched_at_state_version?,
                    locker_address: value.locker_address?,
                })
            }
        }
        impl From<super::StateAccountLockersTouchedAtResponseItem>
        for StateAccountLockersTouchedAtResponseItem {
            fn from(value: super::StateAccountLockersTouchedAtResponseItem) -> Self {
                Self {
                    account_address: Ok(value.account_address),
                    last_touched_at_state_version: Ok(
                        value.last_touched_at_state_version,
                    ),
                    locker_address: Ok(value.locker_address),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateAccountResourcePreferencesPageRequest {
            account_address: Result<super::Address, String>,
            at_ledger_state: Result<Option<super::LedgerStateSelector>, String>,
            cursor: Result<Option<String>, String>,
            limit_per_page: Result<Option<i64>, String>,
        }
        impl Default for StateAccountResourcePreferencesPageRequest {
            fn default() -> Self {
                Self {
                    account_address: Err(
                        "no value supplied for account_address".to_string(),
                    ),
                    at_ledger_state: Ok(Default::default()),
                    cursor: Ok(Default::default()),
                    limit_per_page: Ok(Default::default()),
                }
            }
        }
        impl StateAccountResourcePreferencesPageRequest {
            pub fn account_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.account_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for account_address: {}", e
                        )
                    });
                self
            }
            pub fn at_ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::LedgerStateSelector>>,
                T::Error: std::fmt::Display,
            {
                self.at_ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for at_ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for cursor: {}", e)
                    });
                self
            }
            pub fn limit_per_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.limit_per_page = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for limit_per_page: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateAccountResourcePreferencesPageRequest>
        for super::StateAccountResourcePreferencesPageRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateAccountResourcePreferencesPageRequest,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    account_address: value.account_address?,
                    at_ledger_state: value.at_ledger_state?,
                    cursor: value.cursor?,
                    limit_per_page: value.limit_per_page?,
                })
            }
        }
        impl From<super::StateAccountResourcePreferencesPageRequest>
        for StateAccountResourcePreferencesPageRequest {
            fn from(value: super::StateAccountResourcePreferencesPageRequest) -> Self {
                Self {
                    account_address: Ok(value.account_address),
                    at_ledger_state: Ok(value.at_ledger_state),
                    cursor: Ok(value.cursor),
                    limit_per_page: Ok(value.limit_per_page),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateAccountResourcePreferencesPageResponse {
            account_address: Result<super::Address, String>,
            items: Result<Vec<super::AccountResourcePreferencesResponseItem>, String>,
            ledger_state: Result<super::LedgerState, String>,
            next_cursor: Result<Option<String>, String>,
            total_count: Result<Option<i64>, String>,
        }
        impl Default for StateAccountResourcePreferencesPageResponse {
            fn default() -> Self {
                Self {
                    account_address: Err(
                        "no value supplied for account_address".to_string(),
                    ),
                    items: Err("no value supplied for items".to_string()),
                    ledger_state: Err("no value supplied for ledger_state".to_string()),
                    next_cursor: Ok(Default::default()),
                    total_count: Ok(Default::default()),
                }
            }
        }
        impl StateAccountResourcePreferencesPageResponse {
            pub fn account_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.account_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for account_address: {}", e
                        )
                    });
                self
            }
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    Vec<super::AccountResourcePreferencesResponseItem>,
                >,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {}", e)
                    });
                self
            }
            pub fn ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::LedgerState>,
                T::Error: std::fmt::Display,
            {
                self.ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn next_cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for next_cursor: {}", e)
                    });
                self
            }
            pub fn total_count<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.total_count = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for total_count: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateAccountResourcePreferencesPageResponse>
        for super::StateAccountResourcePreferencesPageResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateAccountResourcePreferencesPageResponse,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    account_address: value.account_address?,
                    items: value.items?,
                    ledger_state: value.ledger_state?,
                    next_cursor: value.next_cursor?,
                    total_count: value.total_count?,
                })
            }
        }
        impl From<super::StateAccountResourcePreferencesPageResponse>
        for StateAccountResourcePreferencesPageResponse {
            fn from(value: super::StateAccountResourcePreferencesPageResponse) -> Self {
                Self {
                    account_address: Ok(value.account_address),
                    items: Ok(value.items),
                    ledger_state: Ok(value.ledger_state),
                    next_cursor: Ok(value.next_cursor),
                    total_count: Ok(value.total_count),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateEntityDetailsOptIns {
            ancestor_identities: Result<bool, String>,
            component_royalty_config: Result<bool, String>,
            component_royalty_vault_balance: Result<bool, String>,
            dapp_two_way_links: Result<bool, String>,
            explicit_metadata: Result<Vec<String>, String>,
            native_resource_details: Result<bool, String>,
            non_fungible_include_nfids: Result<bool, String>,
            package_royalty_vault_balance: Result<bool, String>,
        }
        impl Default for StateEntityDetailsOptIns {
            fn default() -> Self {
                Self {
                    ancestor_identities: Ok(Default::default()),
                    component_royalty_config: Ok(Default::default()),
                    component_royalty_vault_balance: Ok(Default::default()),
                    dapp_two_way_links: Ok(Default::default()),
                    explicit_metadata: Ok(Default::default()),
                    native_resource_details: Ok(Default::default()),
                    non_fungible_include_nfids: Ok(Default::default()),
                    package_royalty_vault_balance: Ok(Default::default()),
                }
            }
        }
        impl StateEntityDetailsOptIns {
            pub fn ancestor_identities<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.ancestor_identities = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for ancestor_identities: {}",
                            e
                        )
                    });
                self
            }
            pub fn component_royalty_config<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.component_royalty_config = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for component_royalty_config: {}",
                            e
                        )
                    });
                self
            }
            pub fn component_royalty_vault_balance<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.component_royalty_vault_balance = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for component_royalty_vault_balance: {}",
                            e
                        )
                    });
                self
            }
            pub fn dapp_two_way_links<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.dapp_two_way_links = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for dapp_two_way_links: {}",
                            e
                        )
                    });
                self
            }
            pub fn explicit_metadata<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<String>>,
                T::Error: std::fmt::Display,
            {
                self.explicit_metadata = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for explicit_metadata: {}",
                            e
                        )
                    });
                self
            }
            pub fn native_resource_details<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.native_resource_details = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for native_resource_details: {}",
                            e
                        )
                    });
                self
            }
            pub fn non_fungible_include_nfids<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.non_fungible_include_nfids = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for non_fungible_include_nfids: {}",
                            e
                        )
                    });
                self
            }
            pub fn package_royalty_vault_balance<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.package_royalty_vault_balance = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for package_royalty_vault_balance: {}",
                            e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateEntityDetailsOptIns>
        for super::StateEntityDetailsOptIns {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateEntityDetailsOptIns,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    ancestor_identities: value.ancestor_identities?,
                    component_royalty_config: value.component_royalty_config?,
                    component_royalty_vault_balance: value
                        .component_royalty_vault_balance?,
                    dapp_two_way_links: value.dapp_two_way_links?,
                    explicit_metadata: value.explicit_metadata?,
                    native_resource_details: value.native_resource_details?,
                    non_fungible_include_nfids: value.non_fungible_include_nfids?,
                    package_royalty_vault_balance: value.package_royalty_vault_balance?,
                })
            }
        }
        impl From<super::StateEntityDetailsOptIns> for StateEntityDetailsOptIns {
            fn from(value: super::StateEntityDetailsOptIns) -> Self {
                Self {
                    ancestor_identities: Ok(value.ancestor_identities),
                    component_royalty_config: Ok(value.component_royalty_config),
                    component_royalty_vault_balance: Ok(
                        value.component_royalty_vault_balance,
                    ),
                    dapp_two_way_links: Ok(value.dapp_two_way_links),
                    explicit_metadata: Ok(value.explicit_metadata),
                    native_resource_details: Ok(value.native_resource_details),
                    non_fungible_include_nfids: Ok(value.non_fungible_include_nfids),
                    package_royalty_vault_balance: Ok(
                        value.package_royalty_vault_balance,
                    ),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateEntityDetailsRequest {
            addresses: Result<Vec<super::Address>, String>,
            aggregation_level: Result<Option<super::ResourceAggregationLevel>, String>,
            at_ledger_state: Result<Option<super::LedgerStateSelector>, String>,
            opt_ins: Result<Option<super::StateEntityDetailsOptIns>, String>,
        }
        impl Default for StateEntityDetailsRequest {
            fn default() -> Self {
                Self {
                    addresses: Err("no value supplied for addresses".to_string()),
                    aggregation_level: Ok(Default::default()),
                    at_ledger_state: Ok(Default::default()),
                    opt_ins: Ok(Default::default()),
                }
            }
        }
        impl StateEntityDetailsRequest {
            pub fn addresses<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Address>>,
                T::Error: std::fmt::Display,
            {
                self.addresses = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for addresses: {}", e)
                    });
                self
            }
            pub fn aggregation_level<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::ResourceAggregationLevel>>,
                T::Error: std::fmt::Display,
            {
                self.aggregation_level = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for aggregation_level: {}",
                            e
                        )
                    });
                self
            }
            pub fn at_ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::LedgerStateSelector>>,
                T::Error: std::fmt::Display,
            {
                self.at_ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for at_ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn opt_ins<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::StateEntityDetailsOptIns>>,
                T::Error: std::fmt::Display,
            {
                self.opt_ins = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for opt_ins: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateEntityDetailsRequest>
        for super::StateEntityDetailsRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateEntityDetailsRequest,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    addresses: value.addresses?,
                    aggregation_level: value.aggregation_level?,
                    at_ledger_state: value.at_ledger_state?,
                    opt_ins: value.opt_ins?,
                })
            }
        }
        impl From<super::StateEntityDetailsRequest> for StateEntityDetailsRequest {
            fn from(value: super::StateEntityDetailsRequest) -> Self {
                Self {
                    addresses: Ok(value.addresses),
                    aggregation_level: Ok(value.aggregation_level),
                    at_ledger_state: Ok(value.at_ledger_state),
                    opt_ins: Ok(value.opt_ins),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateEntityDetailsResponse {
            items: Result<Vec<super::StateEntityDetailsResponseItem>, String>,
            ledger_state: Result<super::LedgerState, String>,
        }
        impl Default for StateEntityDetailsResponse {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    ledger_state: Err("no value supplied for ledger_state".to_string()),
                }
            }
        }
        impl StateEntityDetailsResponse {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::StateEntityDetailsResponseItem>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {}", e)
                    });
                self
            }
            pub fn ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::LedgerState>,
                T::Error: std::fmt::Display,
            {
                self.ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for ledger_state: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateEntityDetailsResponse>
        for super::StateEntityDetailsResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateEntityDetailsResponse,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    ledger_state: value.ledger_state?,
                })
            }
        }
        impl From<super::StateEntityDetailsResponse> for StateEntityDetailsResponse {
            fn from(value: super::StateEntityDetailsResponse) -> Self {
                Self {
                    items: Ok(value.items),
                    ledger_state: Ok(value.ledger_state),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateEntityDetailsResponseComponentDetails {
            blueprint_name: Result<String, String>,
            blueprint_version: Result<String, String>,
            native_resource_details: Result<
                Option<super::NativeResourceDetails>,
                String,
            >,
            package_address: Result<Option<super::Address>, String>,
            role_assignments: Result<
                Option<super::ComponentEntityRoleAssignments>,
                String,
            >,
            royalty_config: Result<Option<super::ComponentRoyaltyConfig>, String>,
            royalty_vault_balance: Result<Option<super::BigDecimal>, String>,
            state: Result<::serde_json::Map<String, ::serde_json::Value>, String>,
            two_way_linked_dapp_address: Result<Option<super::Address>, String>,
            two_way_linked_dapp_details: Result<
                Option<super::TwoWayLinkedDappOnLedgerDetails>,
                String,
            >,
            type_: Result<super::StateEntityDetailsResponseComponentDetailsType, String>,
        }
        impl Default for StateEntityDetailsResponseComponentDetails {
            fn default() -> Self {
                Self {
                    blueprint_name: Err(
                        "no value supplied for blueprint_name".to_string(),
                    ),
                    blueprint_version: Err(
                        "no value supplied for blueprint_version".to_string(),
                    ),
                    native_resource_details: Ok(Default::default()),
                    package_address: Ok(Default::default()),
                    role_assignments: Ok(Default::default()),
                    royalty_config: Ok(Default::default()),
                    royalty_vault_balance: Ok(Default::default()),
                    state: Ok(Default::default()),
                    two_way_linked_dapp_address: Ok(Default::default()),
                    two_way_linked_dapp_details: Ok(Default::default()),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl StateEntityDetailsResponseComponentDetails {
            pub fn blueprint_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.blueprint_name = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for blueprint_name: {}", e
                        )
                    });
                self
            }
            pub fn blueprint_version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.blueprint_version = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for blueprint_version: {}",
                            e
                        )
                    });
                self
            }
            pub fn native_resource_details<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::NativeResourceDetails>>,
                T::Error: std::fmt::Display,
            {
                self.native_resource_details = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for native_resource_details: {}",
                            e
                        )
                    });
                self
            }
            pub fn package_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::Address>>,
                T::Error: std::fmt::Display,
            {
                self.package_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for package_address: {}", e
                        )
                    });
                self
            }
            pub fn role_assignments<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::ComponentEntityRoleAssignments>>,
                T::Error: std::fmt::Display,
            {
                self.role_assignments = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for role_assignments: {}", e
                        )
                    });
                self
            }
            pub fn royalty_config<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::ComponentRoyaltyConfig>>,
                T::Error: std::fmt::Display,
            {
                self.royalty_config = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for royalty_config: {}", e
                        )
                    });
                self
            }
            pub fn royalty_vault_balance<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::BigDecimal>>,
                T::Error: std::fmt::Display,
            {
                self.royalty_vault_balance = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for royalty_vault_balance: {}",
                            e
                        )
                    });
                self
            }
            pub fn state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<::serde_json::Map<String, ::serde_json::Value>>,
                T::Error: std::fmt::Display,
            {
                self.state = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for state: {}", e)
                    });
                self
            }
            pub fn two_way_linked_dapp_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::Address>>,
                T::Error: std::fmt::Display,
            {
                self.two_way_linked_dapp_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for two_way_linked_dapp_address: {}",
                            e
                        )
                    });
                self
            }
            pub fn two_way_linked_dapp_details<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::TwoWayLinkedDappOnLedgerDetails>>,
                T::Error: std::fmt::Display,
            {
                self.two_way_linked_dapp_details = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for two_way_linked_dapp_details: {}",
                            e
                        )
                    });
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::StateEntityDetailsResponseComponentDetailsType,
                >,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateEntityDetailsResponseComponentDetails>
        for super::StateEntityDetailsResponseComponentDetails {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateEntityDetailsResponseComponentDetails,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    blueprint_name: value.blueprint_name?,
                    blueprint_version: value.blueprint_version?,
                    native_resource_details: value.native_resource_details?,
                    package_address: value.package_address?,
                    role_assignments: value.role_assignments?,
                    royalty_config: value.royalty_config?,
                    royalty_vault_balance: value.royalty_vault_balance?,
                    state: value.state?,
                    two_way_linked_dapp_address: value.two_way_linked_dapp_address?,
                    two_way_linked_dapp_details: value.two_way_linked_dapp_details?,
                    type_: value.type_?,
                })
            }
        }
        impl From<super::StateEntityDetailsResponseComponentDetails>
        for StateEntityDetailsResponseComponentDetails {
            fn from(value: super::StateEntityDetailsResponseComponentDetails) -> Self {
                Self {
                    blueprint_name: Ok(value.blueprint_name),
                    blueprint_version: Ok(value.blueprint_version),
                    native_resource_details: Ok(value.native_resource_details),
                    package_address: Ok(value.package_address),
                    role_assignments: Ok(value.role_assignments),
                    royalty_config: Ok(value.royalty_config),
                    royalty_vault_balance: Ok(value.royalty_vault_balance),
                    state: Ok(value.state),
                    two_way_linked_dapp_address: Ok(value.two_way_linked_dapp_address),
                    two_way_linked_dapp_details: Ok(value.two_way_linked_dapp_details),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateEntityDetailsResponseFungibleResourceDetails {
            divisibility: Result<u64, String>,
            native_resource_details: Result<
                Option<super::NativeResourceDetails>,
                String,
            >,
            role_assignments: Result<super::ComponentEntityRoleAssignments, String>,
            total_burned: Result<super::BigDecimal, String>,
            total_minted: Result<super::BigDecimal, String>,
            total_supply: Result<super::BigDecimal, String>,
            two_way_linked_dapps: Result<
                Option<super::TwoWayLinkedDappsCollection>,
                String,
            >,
            type_: Result<
                super::StateEntityDetailsResponseFungibleResourceDetailsType,
                String,
            >,
        }
        impl Default for StateEntityDetailsResponseFungibleResourceDetails {
            fn default() -> Self {
                Self {
                    divisibility: Err("no value supplied for divisibility".to_string()),
                    native_resource_details: Ok(Default::default()),
                    role_assignments: Err(
                        "no value supplied for role_assignments".to_string(),
                    ),
                    total_burned: Err("no value supplied for total_burned".to_string()),
                    total_minted: Err("no value supplied for total_minted".to_string()),
                    total_supply: Err("no value supplied for total_supply".to_string()),
                    two_way_linked_dapps: Ok(Default::default()),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl StateEntityDetailsResponseFungibleResourceDetails {
            pub fn divisibility<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<u64>,
                T::Error: std::fmt::Display,
            {
                self.divisibility = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for divisibility: {}", e
                        )
                    });
                self
            }
            pub fn native_resource_details<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::NativeResourceDetails>>,
                T::Error: std::fmt::Display,
            {
                self.native_resource_details = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for native_resource_details: {}",
                            e
                        )
                    });
                self
            }
            pub fn role_assignments<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ComponentEntityRoleAssignments>,
                T::Error: std::fmt::Display,
            {
                self.role_assignments = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for role_assignments: {}", e
                        )
                    });
                self
            }
            pub fn total_burned<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::BigDecimal>,
                T::Error: std::fmt::Display,
            {
                self.total_burned = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for total_burned: {}", e
                        )
                    });
                self
            }
            pub fn total_minted<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::BigDecimal>,
                T::Error: std::fmt::Display,
            {
                self.total_minted = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for total_minted: {}", e
                        )
                    });
                self
            }
            pub fn total_supply<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::BigDecimal>,
                T::Error: std::fmt::Display,
            {
                self.total_supply = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for total_supply: {}", e
                        )
                    });
                self
            }
            pub fn two_way_linked_dapps<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::TwoWayLinkedDappsCollection>>,
                T::Error: std::fmt::Display,
            {
                self.two_way_linked_dapps = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for two_way_linked_dapps: {}",
                            e
                        )
                    });
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::StateEntityDetailsResponseFungibleResourceDetailsType,
                >,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateEntityDetailsResponseFungibleResourceDetails>
        for super::StateEntityDetailsResponseFungibleResourceDetails {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateEntityDetailsResponseFungibleResourceDetails,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    divisibility: value.divisibility?,
                    native_resource_details: value.native_resource_details?,
                    role_assignments: value.role_assignments?,
                    total_burned: value.total_burned?,
                    total_minted: value.total_minted?,
                    total_supply: value.total_supply?,
                    two_way_linked_dapps: value.two_way_linked_dapps?,
                    type_: value.type_?,
                })
            }
        }
        impl From<super::StateEntityDetailsResponseFungibleResourceDetails>
        for StateEntityDetailsResponseFungibleResourceDetails {
            fn from(
                value: super::StateEntityDetailsResponseFungibleResourceDetails,
            ) -> Self {
                Self {
                    divisibility: Ok(value.divisibility),
                    native_resource_details: Ok(value.native_resource_details),
                    role_assignments: Ok(value.role_assignments),
                    total_burned: Ok(value.total_burned),
                    total_minted: Ok(value.total_minted),
                    total_supply: Ok(value.total_supply),
                    two_way_linked_dapps: Ok(value.two_way_linked_dapps),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateEntityDetailsResponseFungibleVaultDetails {
            balance: Result<
                super::FungibleResourcesCollectionItemVaultAggregatedVaultItem,
                String,
            >,
            resource_address: Result<super::Address, String>,
            type_: Result<
                super::StateEntityDetailsResponseFungibleVaultDetailsType,
                String,
            >,
        }
        impl Default for StateEntityDetailsResponseFungibleVaultDetails {
            fn default() -> Self {
                Self {
                    balance: Err("no value supplied for balance".to_string()),
                    resource_address: Err(
                        "no value supplied for resource_address".to_string(),
                    ),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl StateEntityDetailsResponseFungibleVaultDetails {
            pub fn balance<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::FungibleResourcesCollectionItemVaultAggregatedVaultItem,
                >,
                T::Error: std::fmt::Display,
            {
                self.balance = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for balance: {}", e)
                    });
                self
            }
            pub fn resource_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.resource_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_address: {}", e
                        )
                    });
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::StateEntityDetailsResponseFungibleVaultDetailsType,
                >,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateEntityDetailsResponseFungibleVaultDetails>
        for super::StateEntityDetailsResponseFungibleVaultDetails {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateEntityDetailsResponseFungibleVaultDetails,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    balance: value.balance?,
                    resource_address: value.resource_address?,
                    type_: value.type_?,
                })
            }
        }
        impl From<super::StateEntityDetailsResponseFungibleVaultDetails>
        for StateEntityDetailsResponseFungibleVaultDetails {
            fn from(
                value: super::StateEntityDetailsResponseFungibleVaultDetails,
            ) -> Self {
                Self {
                    balance: Ok(value.balance),
                    resource_address: Ok(value.resource_address),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateEntityDetailsResponseItem {
            address: Result<super::Address, String>,
            ancestor_identities: Result<
                Option<super::StateEntityDetailsResponseItemAncestorIdentities>,
                String,
            >,
            details: Result<
                Option<super::StateEntityDetailsResponseItemDetails>,
                String,
            >,
            explicit_metadata: Result<Option<super::EntityMetadataCollection>, String>,
            fungible_resources: Result<
                Option<super::FungibleResourcesCollection>,
                String,
            >,
            metadata: Result<super::EntityMetadataCollection, String>,
            non_fungible_resources: Result<
                Option<super::NonFungibleResourcesCollection>,
                String,
            >,
        }
        impl Default for StateEntityDetailsResponseItem {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    ancestor_identities: Ok(Default::default()),
                    details: Ok(Default::default()),
                    explicit_metadata: Ok(Default::default()),
                    fungible_resources: Ok(Default::default()),
                    metadata: Err("no value supplied for metadata".to_string()),
                    non_fungible_resources: Ok(Default::default()),
                }
            }
        }
        impl StateEntityDetailsResponseItem {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for address: {}", e)
                    });
                self
            }
            pub fn ancestor_identities<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    Option<super::StateEntityDetailsResponseItemAncestorIdentities>,
                >,
                T::Error: std::fmt::Display,
            {
                self.ancestor_identities = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for ancestor_identities: {}",
                            e
                        )
                    });
                self
            }
            pub fn details<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    Option<super::StateEntityDetailsResponseItemDetails>,
                >,
                T::Error: std::fmt::Display,
            {
                self.details = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for details: {}", e)
                    });
                self
            }
            pub fn explicit_metadata<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::EntityMetadataCollection>>,
                T::Error: std::fmt::Display,
            {
                self.explicit_metadata = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for explicit_metadata: {}",
                            e
                        )
                    });
                self
            }
            pub fn fungible_resources<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::FungibleResourcesCollection>>,
                T::Error: std::fmt::Display,
            {
                self.fungible_resources = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for fungible_resources: {}",
                            e
                        )
                    });
                self
            }
            pub fn metadata<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::EntityMetadataCollection>,
                T::Error: std::fmt::Display,
            {
                self.metadata = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for metadata: {}", e)
                    });
                self
            }
            pub fn non_fungible_resources<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::NonFungibleResourcesCollection>>,
                T::Error: std::fmt::Display,
            {
                self.non_fungible_resources = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for non_fungible_resources: {}",
                            e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateEntityDetailsResponseItem>
        for super::StateEntityDetailsResponseItem {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateEntityDetailsResponseItem,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    ancestor_identities: value.ancestor_identities?,
                    details: value.details?,
                    explicit_metadata: value.explicit_metadata?,
                    fungible_resources: value.fungible_resources?,
                    metadata: value.metadata?,
                    non_fungible_resources: value.non_fungible_resources?,
                })
            }
        }
        impl From<super::StateEntityDetailsResponseItem>
        for StateEntityDetailsResponseItem {
            fn from(value: super::StateEntityDetailsResponseItem) -> Self {
                Self {
                    address: Ok(value.address),
                    ancestor_identities: Ok(value.ancestor_identities),
                    details: Ok(value.details),
                    explicit_metadata: Ok(value.explicit_metadata),
                    fungible_resources: Ok(value.fungible_resources),
                    metadata: Ok(value.metadata),
                    non_fungible_resources: Ok(value.non_fungible_resources),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateEntityDetailsResponseItemAncestorIdentities {
            global_address: Result<Option<super::Address>, String>,
            owner_address: Result<Option<super::Address>, String>,
            parent_address: Result<Option<super::Address>, String>,
        }
        impl Default for StateEntityDetailsResponseItemAncestorIdentities {
            fn default() -> Self {
                Self {
                    global_address: Ok(Default::default()),
                    owner_address: Ok(Default::default()),
                    parent_address: Ok(Default::default()),
                }
            }
        }
        impl StateEntityDetailsResponseItemAncestorIdentities {
            pub fn global_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::Address>>,
                T::Error: std::fmt::Display,
            {
                self.global_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for global_address: {}", e
                        )
                    });
                self
            }
            pub fn owner_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::Address>>,
                T::Error: std::fmt::Display,
            {
                self.owner_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for owner_address: {}", e
                        )
                    });
                self
            }
            pub fn parent_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::Address>>,
                T::Error: std::fmt::Display,
            {
                self.parent_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for parent_address: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateEntityDetailsResponseItemAncestorIdentities>
        for super::StateEntityDetailsResponseItemAncestorIdentities {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateEntityDetailsResponseItemAncestorIdentities,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    global_address: value.global_address?,
                    owner_address: value.owner_address?,
                    parent_address: value.parent_address?,
                })
            }
        }
        impl From<super::StateEntityDetailsResponseItemAncestorIdentities>
        for StateEntityDetailsResponseItemAncestorIdentities {
            fn from(
                value: super::StateEntityDetailsResponseItemAncestorIdentities,
            ) -> Self {
                Self {
                    global_address: Ok(value.global_address),
                    owner_address: Ok(value.owner_address),
                    parent_address: Ok(value.parent_address),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateEntityDetailsResponseItemDetailsBase {
            type_: Result<super::StateEntityDetailsResponseItemDetailsType, String>,
        }
        impl Default for StateEntityDetailsResponseItemDetailsBase {
            fn default() -> Self {
                Self {
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl StateEntityDetailsResponseItemDetailsBase {
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::StateEntityDetailsResponseItemDetailsType,
                >,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateEntityDetailsResponseItemDetailsBase>
        for super::StateEntityDetailsResponseItemDetailsBase {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateEntityDetailsResponseItemDetailsBase,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self { type_: value.type_? })
            }
        }
        impl From<super::StateEntityDetailsResponseItemDetailsBase>
        for StateEntityDetailsResponseItemDetailsBase {
            fn from(value: super::StateEntityDetailsResponseItemDetailsBase) -> Self {
                Self { type_: Ok(value.type_) }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateEntityDetailsResponseNonFungibleResourceDetails {
            native_resource_details: Result<
                Option<super::NativeResourceDetails>,
                String,
            >,
            non_fungible_data_mutable_fields: Result<Vec<String>, String>,
            non_fungible_id_type: Result<super::NonFungibleIdType, String>,
            role_assignments: Result<super::ComponentEntityRoleAssignments, String>,
            total_burned: Result<super::BigDecimal, String>,
            total_minted: Result<super::BigDecimal, String>,
            total_supply: Result<super::BigDecimal, String>,
            two_way_linked_dapps: Result<
                Option<super::TwoWayLinkedDappsCollection>,
                String,
            >,
            type_: Result<
                super::StateEntityDetailsResponseNonFungibleResourceDetailsType,
                String,
            >,
        }
        impl Default for StateEntityDetailsResponseNonFungibleResourceDetails {
            fn default() -> Self {
                Self {
                    native_resource_details: Ok(Default::default()),
                    non_fungible_data_mutable_fields: Err(
                        "no value supplied for non_fungible_data_mutable_fields"
                            .to_string(),
                    ),
                    non_fungible_id_type: Err(
                        "no value supplied for non_fungible_id_type".to_string(),
                    ),
                    role_assignments: Err(
                        "no value supplied for role_assignments".to_string(),
                    ),
                    total_burned: Err("no value supplied for total_burned".to_string()),
                    total_minted: Err("no value supplied for total_minted".to_string()),
                    total_supply: Err("no value supplied for total_supply".to_string()),
                    two_way_linked_dapps: Ok(Default::default()),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl StateEntityDetailsResponseNonFungibleResourceDetails {
            pub fn native_resource_details<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::NativeResourceDetails>>,
                T::Error: std::fmt::Display,
            {
                self.native_resource_details = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for native_resource_details: {}",
                            e
                        )
                    });
                self
            }
            pub fn non_fungible_data_mutable_fields<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<String>>,
                T::Error: std::fmt::Display,
            {
                self.non_fungible_data_mutable_fields = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for non_fungible_data_mutable_fields: {}",
                            e
                        )
                    });
                self
            }
            pub fn non_fungible_id_type<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::NonFungibleIdType>,
                T::Error: std::fmt::Display,
            {
                self.non_fungible_id_type = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for non_fungible_id_type: {}",
                            e
                        )
                    });
                self
            }
            pub fn role_assignments<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ComponentEntityRoleAssignments>,
                T::Error: std::fmt::Display,
            {
                self.role_assignments = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for role_assignments: {}", e
                        )
                    });
                self
            }
            pub fn total_burned<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::BigDecimal>,
                T::Error: std::fmt::Display,
            {
                self.total_burned = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for total_burned: {}", e
                        )
                    });
                self
            }
            pub fn total_minted<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::BigDecimal>,
                T::Error: std::fmt::Display,
            {
                self.total_minted = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for total_minted: {}", e
                        )
                    });
                self
            }
            pub fn total_supply<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::BigDecimal>,
                T::Error: std::fmt::Display,
            {
                self.total_supply = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for total_supply: {}", e
                        )
                    });
                self
            }
            pub fn two_way_linked_dapps<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::TwoWayLinkedDappsCollection>>,
                T::Error: std::fmt::Display,
            {
                self.two_way_linked_dapps = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for two_way_linked_dapps: {}",
                            e
                        )
                    });
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::StateEntityDetailsResponseNonFungibleResourceDetailsType,
                >,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateEntityDetailsResponseNonFungibleResourceDetails>
        for super::StateEntityDetailsResponseNonFungibleResourceDetails {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateEntityDetailsResponseNonFungibleResourceDetails,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    native_resource_details: value.native_resource_details?,
                    non_fungible_data_mutable_fields: value
                        .non_fungible_data_mutable_fields?,
                    non_fungible_id_type: value.non_fungible_id_type?,
                    role_assignments: value.role_assignments?,
                    total_burned: value.total_burned?,
                    total_minted: value.total_minted?,
                    total_supply: value.total_supply?,
                    two_way_linked_dapps: value.two_way_linked_dapps?,
                    type_: value.type_?,
                })
            }
        }
        impl From<super::StateEntityDetailsResponseNonFungibleResourceDetails>
        for StateEntityDetailsResponseNonFungibleResourceDetails {
            fn from(
                value: super::StateEntityDetailsResponseNonFungibleResourceDetails,
            ) -> Self {
                Self {
                    native_resource_details: Ok(value.native_resource_details),
                    non_fungible_data_mutable_fields: Ok(
                        value.non_fungible_data_mutable_fields,
                    ),
                    non_fungible_id_type: Ok(value.non_fungible_id_type),
                    role_assignments: Ok(value.role_assignments),
                    total_burned: Ok(value.total_burned),
                    total_minted: Ok(value.total_minted),
                    total_supply: Ok(value.total_supply),
                    two_way_linked_dapps: Ok(value.two_way_linked_dapps),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateEntityDetailsResponseNonFungibleVaultDetails {
            balance: Result<
                super::NonFungibleResourcesCollectionItemVaultAggregatedVaultItem,
                String,
            >,
            resource_address: Result<super::Address, String>,
            type_: Result<
                super::StateEntityDetailsResponseNonFungibleVaultDetailsType,
                String,
            >,
        }
        impl Default for StateEntityDetailsResponseNonFungibleVaultDetails {
            fn default() -> Self {
                Self {
                    balance: Err("no value supplied for balance".to_string()),
                    resource_address: Err(
                        "no value supplied for resource_address".to_string(),
                    ),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl StateEntityDetailsResponseNonFungibleVaultDetails {
            pub fn balance<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::NonFungibleResourcesCollectionItemVaultAggregatedVaultItem,
                >,
                T::Error: std::fmt::Display,
            {
                self.balance = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for balance: {}", e)
                    });
                self
            }
            pub fn resource_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.resource_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_address: {}", e
                        )
                    });
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::StateEntityDetailsResponseNonFungibleVaultDetailsType,
                >,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateEntityDetailsResponseNonFungibleVaultDetails>
        for super::StateEntityDetailsResponseNonFungibleVaultDetails {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateEntityDetailsResponseNonFungibleVaultDetails,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    balance: value.balance?,
                    resource_address: value.resource_address?,
                    type_: value.type_?,
                })
            }
        }
        impl From<super::StateEntityDetailsResponseNonFungibleVaultDetails>
        for StateEntityDetailsResponseNonFungibleVaultDetails {
            fn from(
                value: super::StateEntityDetailsResponseNonFungibleVaultDetails,
            ) -> Self {
                Self {
                    balance: Ok(value.balance),
                    resource_address: Ok(value.resource_address),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateEntityDetailsResponsePackageDetails {
            blueprints: Result<Option<super::PackageBlueprintCollection>, String>,
            code_hash_hex: Result<super::HexString, String>,
            code_hex: Result<super::HexString, String>,
            codes: Result<super::PackageCodeCollection, String>,
            role_assignments: Result<
                Option<super::ComponentEntityRoleAssignments>,
                String,
            >,
            royalty_vault_balance: Result<Option<super::BigDecimal>, String>,
            schemas: Result<Option<super::EntitySchemaCollection>, String>,
            two_way_linked_dapp_address: Result<Option<super::Address>, String>,
            type_: Result<super::StateEntityDetailsResponsePackageDetailsType, String>,
            vm_type: Result<super::PackageVmType, String>,
        }
        impl Default for StateEntityDetailsResponsePackageDetails {
            fn default() -> Self {
                Self {
                    blueprints: Ok(Default::default()),
                    code_hash_hex: Err(
                        "no value supplied for code_hash_hex".to_string(),
                    ),
                    code_hex: Err("no value supplied for code_hex".to_string()),
                    codes: Err("no value supplied for codes".to_string()),
                    role_assignments: Ok(Default::default()),
                    royalty_vault_balance: Ok(Default::default()),
                    schemas: Ok(Default::default()),
                    two_way_linked_dapp_address: Ok(Default::default()),
                    type_: Err("no value supplied for type_".to_string()),
                    vm_type: Err("no value supplied for vm_type".to_string()),
                }
            }
        }
        impl StateEntityDetailsResponsePackageDetails {
            pub fn blueprints<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::PackageBlueprintCollection>>,
                T::Error: std::fmt::Display,
            {
                self.blueprints = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for blueprints: {}", e)
                    });
                self
            }
            pub fn code_hash_hex<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::HexString>,
                T::Error: std::fmt::Display,
            {
                self.code_hash_hex = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for code_hash_hex: {}", e
                        )
                    });
                self
            }
            pub fn code_hex<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::HexString>,
                T::Error: std::fmt::Display,
            {
                self.code_hex = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for code_hex: {}", e)
                    });
                self
            }
            pub fn codes<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::PackageCodeCollection>,
                T::Error: std::fmt::Display,
            {
                self.codes = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for codes: {}", e)
                    });
                self
            }
            pub fn role_assignments<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::ComponentEntityRoleAssignments>>,
                T::Error: std::fmt::Display,
            {
                self.role_assignments = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for role_assignments: {}", e
                        )
                    });
                self
            }
            pub fn royalty_vault_balance<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::BigDecimal>>,
                T::Error: std::fmt::Display,
            {
                self.royalty_vault_balance = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for royalty_vault_balance: {}",
                            e
                        )
                    });
                self
            }
            pub fn schemas<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::EntitySchemaCollection>>,
                T::Error: std::fmt::Display,
            {
                self.schemas = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for schemas: {}", e)
                    });
                self
            }
            pub fn two_way_linked_dapp_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::Address>>,
                T::Error: std::fmt::Display,
            {
                self.two_way_linked_dapp_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for two_way_linked_dapp_address: {}",
                            e
                        )
                    });
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::StateEntityDetailsResponsePackageDetailsType,
                >,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
            pub fn vm_type<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::PackageVmType>,
                T::Error: std::fmt::Display,
            {
                self.vm_type = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for vm_type: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateEntityDetailsResponsePackageDetails>
        for super::StateEntityDetailsResponsePackageDetails {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateEntityDetailsResponsePackageDetails,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    blueprints: value.blueprints?,
                    code_hash_hex: value.code_hash_hex?,
                    code_hex: value.code_hex?,
                    codes: value.codes?,
                    role_assignments: value.role_assignments?,
                    royalty_vault_balance: value.royalty_vault_balance?,
                    schemas: value.schemas?,
                    two_way_linked_dapp_address: value.two_way_linked_dapp_address?,
                    type_: value.type_?,
                    vm_type: value.vm_type?,
                })
            }
        }
        impl From<super::StateEntityDetailsResponsePackageDetails>
        for StateEntityDetailsResponsePackageDetails {
            fn from(value: super::StateEntityDetailsResponsePackageDetails) -> Self {
                Self {
                    blueprints: Ok(value.blueprints),
                    code_hash_hex: Ok(value.code_hash_hex),
                    code_hex: Ok(value.code_hex),
                    codes: Ok(value.codes),
                    role_assignments: Ok(value.role_assignments),
                    royalty_vault_balance: Ok(value.royalty_vault_balance),
                    schemas: Ok(value.schemas),
                    two_way_linked_dapp_address: Ok(value.two_way_linked_dapp_address),
                    type_: Ok(value.type_),
                    vm_type: Ok(value.vm_type),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateEntityFungibleResourceVaultsPageRequest {
            address: Result<super::Address, String>,
            at_ledger_state: Result<Option<super::LedgerStateSelector>, String>,
            cursor: Result<Option<String>, String>,
            limit_per_page: Result<Option<i64>, String>,
            resource_address: Result<super::Address, String>,
        }
        impl Default for StateEntityFungibleResourceVaultsPageRequest {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    at_ledger_state: Ok(Default::default()),
                    cursor: Ok(Default::default()),
                    limit_per_page: Ok(Default::default()),
                    resource_address: Err(
                        "no value supplied for resource_address".to_string(),
                    ),
                }
            }
        }
        impl StateEntityFungibleResourceVaultsPageRequest {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for address: {}", e)
                    });
                self
            }
            pub fn at_ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::LedgerStateSelector>>,
                T::Error: std::fmt::Display,
            {
                self.at_ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for at_ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for cursor: {}", e)
                    });
                self
            }
            pub fn limit_per_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.limit_per_page = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for limit_per_page: {}", e
                        )
                    });
                self
            }
            pub fn resource_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.resource_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_address: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateEntityFungibleResourceVaultsPageRequest>
        for super::StateEntityFungibleResourceVaultsPageRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateEntityFungibleResourceVaultsPageRequest,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    at_ledger_state: value.at_ledger_state?,
                    cursor: value.cursor?,
                    limit_per_page: value.limit_per_page?,
                    resource_address: value.resource_address?,
                })
            }
        }
        impl From<super::StateEntityFungibleResourceVaultsPageRequest>
        for StateEntityFungibleResourceVaultsPageRequest {
            fn from(value: super::StateEntityFungibleResourceVaultsPageRequest) -> Self {
                Self {
                    address: Ok(value.address),
                    at_ledger_state: Ok(value.at_ledger_state),
                    cursor: Ok(value.cursor),
                    limit_per_page: Ok(value.limit_per_page),
                    resource_address: Ok(value.resource_address),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateEntityFungibleResourceVaultsPageResponse {
            address: Result<super::Address, String>,
            items: Result<
                Vec<super::FungibleResourcesCollectionItemVaultAggregatedVaultItem>,
                String,
            >,
            ledger_state: Result<super::LedgerState, String>,
            next_cursor: Result<Option<String>, String>,
            resource_address: Result<super::Address, String>,
            total_count: Result<Option<i64>, String>,
        }
        impl Default for StateEntityFungibleResourceVaultsPageResponse {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    items: Err("no value supplied for items".to_string()),
                    ledger_state: Err("no value supplied for ledger_state".to_string()),
                    next_cursor: Ok(Default::default()),
                    resource_address: Err(
                        "no value supplied for resource_address".to_string(),
                    ),
                    total_count: Ok(Default::default()),
                }
            }
        }
        impl StateEntityFungibleResourceVaultsPageResponse {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for address: {}", e)
                    });
                self
            }
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    Vec<super::FungibleResourcesCollectionItemVaultAggregatedVaultItem>,
                >,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {}", e)
                    });
                self
            }
            pub fn ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::LedgerState>,
                T::Error: std::fmt::Display,
            {
                self.ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn next_cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for next_cursor: {}", e)
                    });
                self
            }
            pub fn resource_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.resource_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_address: {}", e
                        )
                    });
                self
            }
            pub fn total_count<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.total_count = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for total_count: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateEntityFungibleResourceVaultsPageResponse>
        for super::StateEntityFungibleResourceVaultsPageResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateEntityFungibleResourceVaultsPageResponse,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    items: value.items?,
                    ledger_state: value.ledger_state?,
                    next_cursor: value.next_cursor?,
                    resource_address: value.resource_address?,
                    total_count: value.total_count?,
                })
            }
        }
        impl From<super::StateEntityFungibleResourceVaultsPageResponse>
        for StateEntityFungibleResourceVaultsPageResponse {
            fn from(
                value: super::StateEntityFungibleResourceVaultsPageResponse,
            ) -> Self {
                Self {
                    address: Ok(value.address),
                    items: Ok(value.items),
                    ledger_state: Ok(value.ledger_state),
                    next_cursor: Ok(value.next_cursor),
                    resource_address: Ok(value.resource_address),
                    total_count: Ok(value.total_count),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateEntityFungiblesPageRequest {
            address: Result<super::Address, String>,
            aggregation_level: Result<Option<super::ResourceAggregationLevel>, String>,
            at_ledger_state: Result<Option<super::LedgerStateSelector>, String>,
            cursor: Result<Option<String>, String>,
            limit_per_page: Result<Option<i64>, String>,
            opt_ins: Result<
                Option<super::StateEntityFungiblesPageRequestOptIns>,
                String,
            >,
        }
        impl Default for StateEntityFungiblesPageRequest {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    aggregation_level: Ok(Default::default()),
                    at_ledger_state: Ok(Default::default()),
                    cursor: Ok(Default::default()),
                    limit_per_page: Ok(Default::default()),
                    opt_ins: Ok(Default::default()),
                }
            }
        }
        impl StateEntityFungiblesPageRequest {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for address: {}", e)
                    });
                self
            }
            pub fn aggregation_level<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::ResourceAggregationLevel>>,
                T::Error: std::fmt::Display,
            {
                self.aggregation_level = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for aggregation_level: {}",
                            e
                        )
                    });
                self
            }
            pub fn at_ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::LedgerStateSelector>>,
                T::Error: std::fmt::Display,
            {
                self.at_ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for at_ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for cursor: {}", e)
                    });
                self
            }
            pub fn limit_per_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.limit_per_page = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for limit_per_page: {}", e
                        )
                    });
                self
            }
            pub fn opt_ins<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    Option<super::StateEntityFungiblesPageRequestOptIns>,
                >,
                T::Error: std::fmt::Display,
            {
                self.opt_ins = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for opt_ins: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateEntityFungiblesPageRequest>
        for super::StateEntityFungiblesPageRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateEntityFungiblesPageRequest,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    aggregation_level: value.aggregation_level?,
                    at_ledger_state: value.at_ledger_state?,
                    cursor: value.cursor?,
                    limit_per_page: value.limit_per_page?,
                    opt_ins: value.opt_ins?,
                })
            }
        }
        impl From<super::StateEntityFungiblesPageRequest>
        for StateEntityFungiblesPageRequest {
            fn from(value: super::StateEntityFungiblesPageRequest) -> Self {
                Self {
                    address: Ok(value.address),
                    aggregation_level: Ok(value.aggregation_level),
                    at_ledger_state: Ok(value.at_ledger_state),
                    cursor: Ok(value.cursor),
                    limit_per_page: Ok(value.limit_per_page),
                    opt_ins: Ok(value.opt_ins),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateEntityFungiblesPageRequestOptIns {
            explicit_metadata: Result<Vec<String>, String>,
        }
        impl Default for StateEntityFungiblesPageRequestOptIns {
            fn default() -> Self {
                Self {
                    explicit_metadata: Ok(Default::default()),
                }
            }
        }
        impl StateEntityFungiblesPageRequestOptIns {
            pub fn explicit_metadata<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<String>>,
                T::Error: std::fmt::Display,
            {
                self.explicit_metadata = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for explicit_metadata: {}",
                            e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateEntityFungiblesPageRequestOptIns>
        for super::StateEntityFungiblesPageRequestOptIns {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateEntityFungiblesPageRequestOptIns,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    explicit_metadata: value.explicit_metadata?,
                })
            }
        }
        impl From<super::StateEntityFungiblesPageRequestOptIns>
        for StateEntityFungiblesPageRequestOptIns {
            fn from(value: super::StateEntityFungiblesPageRequestOptIns) -> Self {
                Self {
                    explicit_metadata: Ok(value.explicit_metadata),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateEntityFungiblesPageResponse {
            address: Result<super::Address, String>,
            items: Result<Vec<super::FungibleResourcesCollectionItem>, String>,
            ledger_state: Result<super::LedgerState, String>,
            next_cursor: Result<Option<String>, String>,
            total_count: Result<Option<i64>, String>,
        }
        impl Default for StateEntityFungiblesPageResponse {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    items: Err("no value supplied for items".to_string()),
                    ledger_state: Err("no value supplied for ledger_state".to_string()),
                    next_cursor: Ok(Default::default()),
                    total_count: Ok(Default::default()),
                }
            }
        }
        impl StateEntityFungiblesPageResponse {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for address: {}", e)
                    });
                self
            }
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::FungibleResourcesCollectionItem>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {}", e)
                    });
                self
            }
            pub fn ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::LedgerState>,
                T::Error: std::fmt::Display,
            {
                self.ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn next_cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for next_cursor: {}", e)
                    });
                self
            }
            pub fn total_count<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.total_count = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for total_count: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateEntityFungiblesPageResponse>
        for super::StateEntityFungiblesPageResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateEntityFungiblesPageResponse,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    items: value.items?,
                    ledger_state: value.ledger_state?,
                    next_cursor: value.next_cursor?,
                    total_count: value.total_count?,
                })
            }
        }
        impl From<super::StateEntityFungiblesPageResponse>
        for StateEntityFungiblesPageResponse {
            fn from(value: super::StateEntityFungiblesPageResponse) -> Self {
                Self {
                    address: Ok(value.address),
                    items: Ok(value.items),
                    ledger_state: Ok(value.ledger_state),
                    next_cursor: Ok(value.next_cursor),
                    total_count: Ok(value.total_count),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateEntityMetadataPageRequest {
            address: Result<super::Address, String>,
            at_ledger_state: Result<Option<super::LedgerStateSelector>, String>,
            cursor: Result<Option<String>, String>,
            limit_per_page: Result<Option<i64>, String>,
        }
        impl Default for StateEntityMetadataPageRequest {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    at_ledger_state: Ok(Default::default()),
                    cursor: Ok(Default::default()),
                    limit_per_page: Ok(Default::default()),
                }
            }
        }
        impl StateEntityMetadataPageRequest {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for address: {}", e)
                    });
                self
            }
            pub fn at_ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::LedgerStateSelector>>,
                T::Error: std::fmt::Display,
            {
                self.at_ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for at_ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for cursor: {}", e)
                    });
                self
            }
            pub fn limit_per_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.limit_per_page = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for limit_per_page: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateEntityMetadataPageRequest>
        for super::StateEntityMetadataPageRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateEntityMetadataPageRequest,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    at_ledger_state: value.at_ledger_state?,
                    cursor: value.cursor?,
                    limit_per_page: value.limit_per_page?,
                })
            }
        }
        impl From<super::StateEntityMetadataPageRequest>
        for StateEntityMetadataPageRequest {
            fn from(value: super::StateEntityMetadataPageRequest) -> Self {
                Self {
                    address: Ok(value.address),
                    at_ledger_state: Ok(value.at_ledger_state),
                    cursor: Ok(value.cursor),
                    limit_per_page: Ok(value.limit_per_page),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateEntityMetadataPageResponse {
            address: Result<super::Address, String>,
            items: Result<Vec<super::EntityMetadataItem>, String>,
            ledger_state: Result<super::LedgerState, String>,
            next_cursor: Result<Option<String>, String>,
            total_count: Result<Option<i64>, String>,
        }
        impl Default for StateEntityMetadataPageResponse {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    items: Err("no value supplied for items".to_string()),
                    ledger_state: Err("no value supplied for ledger_state".to_string()),
                    next_cursor: Ok(Default::default()),
                    total_count: Ok(Default::default()),
                }
            }
        }
        impl StateEntityMetadataPageResponse {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for address: {}", e)
                    });
                self
            }
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::EntityMetadataItem>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {}", e)
                    });
                self
            }
            pub fn ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::LedgerState>,
                T::Error: std::fmt::Display,
            {
                self.ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn next_cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for next_cursor: {}", e)
                    });
                self
            }
            pub fn total_count<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.total_count = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for total_count: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateEntityMetadataPageResponse>
        for super::StateEntityMetadataPageResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateEntityMetadataPageResponse,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    items: value.items?,
                    ledger_state: value.ledger_state?,
                    next_cursor: value.next_cursor?,
                    total_count: value.total_count?,
                })
            }
        }
        impl From<super::StateEntityMetadataPageResponse>
        for StateEntityMetadataPageResponse {
            fn from(value: super::StateEntityMetadataPageResponse) -> Self {
                Self {
                    address: Ok(value.address),
                    items: Ok(value.items),
                    ledger_state: Ok(value.ledger_state),
                    next_cursor: Ok(value.next_cursor),
                    total_count: Ok(value.total_count),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateEntityNonFungibleIdsPageRequest {
            address: Result<super::Address, String>,
            at_ledger_state: Result<Option<super::LedgerStateSelector>, String>,
            cursor: Result<Option<String>, String>,
            limit_per_page: Result<Option<i64>, String>,
            resource_address: Result<super::Address, String>,
            vault_address: Result<super::Address, String>,
        }
        impl Default for StateEntityNonFungibleIdsPageRequest {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    at_ledger_state: Ok(Default::default()),
                    cursor: Ok(Default::default()),
                    limit_per_page: Ok(Default::default()),
                    resource_address: Err(
                        "no value supplied for resource_address".to_string(),
                    ),
                    vault_address: Err("no value supplied for vault_address".to_string()),
                }
            }
        }
        impl StateEntityNonFungibleIdsPageRequest {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for address: {}", e)
                    });
                self
            }
            pub fn at_ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::LedgerStateSelector>>,
                T::Error: std::fmt::Display,
            {
                self.at_ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for at_ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for cursor: {}", e)
                    });
                self
            }
            pub fn limit_per_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.limit_per_page = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for limit_per_page: {}", e
                        )
                    });
                self
            }
            pub fn resource_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.resource_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_address: {}", e
                        )
                    });
                self
            }
            pub fn vault_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.vault_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for vault_address: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateEntityNonFungibleIdsPageRequest>
        for super::StateEntityNonFungibleIdsPageRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateEntityNonFungibleIdsPageRequest,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    at_ledger_state: value.at_ledger_state?,
                    cursor: value.cursor?,
                    limit_per_page: value.limit_per_page?,
                    resource_address: value.resource_address?,
                    vault_address: value.vault_address?,
                })
            }
        }
        impl From<super::StateEntityNonFungibleIdsPageRequest>
        for StateEntityNonFungibleIdsPageRequest {
            fn from(value: super::StateEntityNonFungibleIdsPageRequest) -> Self {
                Self {
                    address: Ok(value.address),
                    at_ledger_state: Ok(value.at_ledger_state),
                    cursor: Ok(value.cursor),
                    limit_per_page: Ok(value.limit_per_page),
                    resource_address: Ok(value.resource_address),
                    vault_address: Ok(value.vault_address),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateEntityNonFungibleIdsPageResponse {
            address: Result<super::Address, String>,
            items: Result<Vec<super::NonFungibleId>, String>,
            ledger_state: Result<super::LedgerState, String>,
            next_cursor: Result<Option<String>, String>,
            resource_address: Result<super::Address, String>,
            total_count: Result<Option<i64>, String>,
        }
        impl Default for StateEntityNonFungibleIdsPageResponse {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    items: Err("no value supplied for items".to_string()),
                    ledger_state: Err("no value supplied for ledger_state".to_string()),
                    next_cursor: Ok(Default::default()),
                    resource_address: Err(
                        "no value supplied for resource_address".to_string(),
                    ),
                    total_count: Ok(Default::default()),
                }
            }
        }
        impl StateEntityNonFungibleIdsPageResponse {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for address: {}", e)
                    });
                self
            }
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::NonFungibleId>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {}", e)
                    });
                self
            }
            pub fn ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::LedgerState>,
                T::Error: std::fmt::Display,
            {
                self.ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn next_cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for next_cursor: {}", e)
                    });
                self
            }
            pub fn resource_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.resource_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_address: {}", e
                        )
                    });
                self
            }
            pub fn total_count<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.total_count = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for total_count: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateEntityNonFungibleIdsPageResponse>
        for super::StateEntityNonFungibleIdsPageResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateEntityNonFungibleIdsPageResponse,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    items: value.items?,
                    ledger_state: value.ledger_state?,
                    next_cursor: value.next_cursor?,
                    resource_address: value.resource_address?,
                    total_count: value.total_count?,
                })
            }
        }
        impl From<super::StateEntityNonFungibleIdsPageResponse>
        for StateEntityNonFungibleIdsPageResponse {
            fn from(value: super::StateEntityNonFungibleIdsPageResponse) -> Self {
                Self {
                    address: Ok(value.address),
                    items: Ok(value.items),
                    ledger_state: Ok(value.ledger_state),
                    next_cursor: Ok(value.next_cursor),
                    resource_address: Ok(value.resource_address),
                    total_count: Ok(value.total_count),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateEntityNonFungibleResourceVaultsPageOptIns {
            non_fungible_include_nfids: Result<Option<bool>, String>,
        }
        impl Default for StateEntityNonFungibleResourceVaultsPageOptIns {
            fn default() -> Self {
                Self {
                    non_fungible_include_nfids: Ok(Default::default()),
                }
            }
        }
        impl StateEntityNonFungibleResourceVaultsPageOptIns {
            pub fn non_fungible_include_nfids<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<bool>>,
                T::Error: std::fmt::Display,
            {
                self.non_fungible_include_nfids = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for non_fungible_include_nfids: {}",
                            e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateEntityNonFungibleResourceVaultsPageOptIns>
        for super::StateEntityNonFungibleResourceVaultsPageOptIns {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateEntityNonFungibleResourceVaultsPageOptIns,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    non_fungible_include_nfids: value.non_fungible_include_nfids?,
                })
            }
        }
        impl From<super::StateEntityNonFungibleResourceVaultsPageOptIns>
        for StateEntityNonFungibleResourceVaultsPageOptIns {
            fn from(
                value: super::StateEntityNonFungibleResourceVaultsPageOptIns,
            ) -> Self {
                Self {
                    non_fungible_include_nfids: Ok(value.non_fungible_include_nfids),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateEntityNonFungibleResourceVaultsPageRequest {
            address: Result<super::Address, String>,
            at_ledger_state: Result<Option<super::LedgerStateSelector>, String>,
            cursor: Result<Option<String>, String>,
            limit_per_page: Result<Option<i64>, String>,
            opt_ins: Result<
                Option<super::StateEntityNonFungibleResourceVaultsPageOptIns>,
                String,
            >,
            resource_address: Result<super::Address, String>,
        }
        impl Default for StateEntityNonFungibleResourceVaultsPageRequest {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    at_ledger_state: Ok(Default::default()),
                    cursor: Ok(Default::default()),
                    limit_per_page: Ok(Default::default()),
                    opt_ins: Ok(Default::default()),
                    resource_address: Err(
                        "no value supplied for resource_address".to_string(),
                    ),
                }
            }
        }
        impl StateEntityNonFungibleResourceVaultsPageRequest {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for address: {}", e)
                    });
                self
            }
            pub fn at_ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::LedgerStateSelector>>,
                T::Error: std::fmt::Display,
            {
                self.at_ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for at_ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for cursor: {}", e)
                    });
                self
            }
            pub fn limit_per_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.limit_per_page = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for limit_per_page: {}", e
                        )
                    });
                self
            }
            pub fn opt_ins<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    Option<super::StateEntityNonFungibleResourceVaultsPageOptIns>,
                >,
                T::Error: std::fmt::Display,
            {
                self.opt_ins = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for opt_ins: {}", e)
                    });
                self
            }
            pub fn resource_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.resource_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_address: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateEntityNonFungibleResourceVaultsPageRequest>
        for super::StateEntityNonFungibleResourceVaultsPageRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateEntityNonFungibleResourceVaultsPageRequest,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    at_ledger_state: value.at_ledger_state?,
                    cursor: value.cursor?,
                    limit_per_page: value.limit_per_page?,
                    opt_ins: value.opt_ins?,
                    resource_address: value.resource_address?,
                })
            }
        }
        impl From<super::StateEntityNonFungibleResourceVaultsPageRequest>
        for StateEntityNonFungibleResourceVaultsPageRequest {
            fn from(
                value: super::StateEntityNonFungibleResourceVaultsPageRequest,
            ) -> Self {
                Self {
                    address: Ok(value.address),
                    at_ledger_state: Ok(value.at_ledger_state),
                    cursor: Ok(value.cursor),
                    limit_per_page: Ok(value.limit_per_page),
                    opt_ins: Ok(value.opt_ins),
                    resource_address: Ok(value.resource_address),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateEntityNonFungibleResourceVaultsPageResponse {
            address: Result<super::Address, String>,
            items: Result<
                Vec<super::NonFungibleResourcesCollectionItemVaultAggregatedVaultItem>,
                String,
            >,
            ledger_state: Result<super::LedgerState, String>,
            next_cursor: Result<Option<String>, String>,
            resource_address: Result<super::Address, String>,
            total_count: Result<Option<i64>, String>,
        }
        impl Default for StateEntityNonFungibleResourceVaultsPageResponse {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    items: Err("no value supplied for items".to_string()),
                    ledger_state: Err("no value supplied for ledger_state".to_string()),
                    next_cursor: Ok(Default::default()),
                    resource_address: Err(
                        "no value supplied for resource_address".to_string(),
                    ),
                    total_count: Ok(Default::default()),
                }
            }
        }
        impl StateEntityNonFungibleResourceVaultsPageResponse {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for address: {}", e)
                    });
                self
            }
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    Vec<
                        super::NonFungibleResourcesCollectionItemVaultAggregatedVaultItem,
                    >,
                >,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {}", e)
                    });
                self
            }
            pub fn ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::LedgerState>,
                T::Error: std::fmt::Display,
            {
                self.ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn next_cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for next_cursor: {}", e)
                    });
                self
            }
            pub fn resource_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.resource_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_address: {}", e
                        )
                    });
                self
            }
            pub fn total_count<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.total_count = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for total_count: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateEntityNonFungibleResourceVaultsPageResponse>
        for super::StateEntityNonFungibleResourceVaultsPageResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateEntityNonFungibleResourceVaultsPageResponse,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    items: value.items?,
                    ledger_state: value.ledger_state?,
                    next_cursor: value.next_cursor?,
                    resource_address: value.resource_address?,
                    total_count: value.total_count?,
                })
            }
        }
        impl From<super::StateEntityNonFungibleResourceVaultsPageResponse>
        for StateEntityNonFungibleResourceVaultsPageResponse {
            fn from(
                value: super::StateEntityNonFungibleResourceVaultsPageResponse,
            ) -> Self {
                Self {
                    address: Ok(value.address),
                    items: Ok(value.items),
                    ledger_state: Ok(value.ledger_state),
                    next_cursor: Ok(value.next_cursor),
                    resource_address: Ok(value.resource_address),
                    total_count: Ok(value.total_count),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateEntityNonFungiblesPageRequest {
            address: Result<super::Address, String>,
            aggregation_level: Result<Option<super::ResourceAggregationLevel>, String>,
            at_ledger_state: Result<Option<super::LedgerStateSelector>, String>,
            cursor: Result<Option<String>, String>,
            limit_per_page: Result<Option<i64>, String>,
            opt_ins: Result<
                Option<super::StateEntityNonFungiblesPageRequestOptIns>,
                String,
            >,
        }
        impl Default for StateEntityNonFungiblesPageRequest {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    aggregation_level: Ok(Default::default()),
                    at_ledger_state: Ok(Default::default()),
                    cursor: Ok(Default::default()),
                    limit_per_page: Ok(Default::default()),
                    opt_ins: Ok(Default::default()),
                }
            }
        }
        impl StateEntityNonFungiblesPageRequest {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for address: {}", e)
                    });
                self
            }
            pub fn aggregation_level<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::ResourceAggregationLevel>>,
                T::Error: std::fmt::Display,
            {
                self.aggregation_level = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for aggregation_level: {}",
                            e
                        )
                    });
                self
            }
            pub fn at_ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::LedgerStateSelector>>,
                T::Error: std::fmt::Display,
            {
                self.at_ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for at_ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for cursor: {}", e)
                    });
                self
            }
            pub fn limit_per_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.limit_per_page = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for limit_per_page: {}", e
                        )
                    });
                self
            }
            pub fn opt_ins<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    Option<super::StateEntityNonFungiblesPageRequestOptIns>,
                >,
                T::Error: std::fmt::Display,
            {
                self.opt_ins = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for opt_ins: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateEntityNonFungiblesPageRequest>
        for super::StateEntityNonFungiblesPageRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateEntityNonFungiblesPageRequest,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    aggregation_level: value.aggregation_level?,
                    at_ledger_state: value.at_ledger_state?,
                    cursor: value.cursor?,
                    limit_per_page: value.limit_per_page?,
                    opt_ins: value.opt_ins?,
                })
            }
        }
        impl From<super::StateEntityNonFungiblesPageRequest>
        for StateEntityNonFungiblesPageRequest {
            fn from(value: super::StateEntityNonFungiblesPageRequest) -> Self {
                Self {
                    address: Ok(value.address),
                    aggregation_level: Ok(value.aggregation_level),
                    at_ledger_state: Ok(value.at_ledger_state),
                    cursor: Ok(value.cursor),
                    limit_per_page: Ok(value.limit_per_page),
                    opt_ins: Ok(value.opt_ins),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateEntityNonFungiblesPageRequestOptIns {
            explicit_metadata: Result<Vec<String>, String>,
            non_fungible_include_nfids: Result<bool, String>,
        }
        impl Default for StateEntityNonFungiblesPageRequestOptIns {
            fn default() -> Self {
                Self {
                    explicit_metadata: Ok(Default::default()),
                    non_fungible_include_nfids: Ok(Default::default()),
                }
            }
        }
        impl StateEntityNonFungiblesPageRequestOptIns {
            pub fn explicit_metadata<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<String>>,
                T::Error: std::fmt::Display,
            {
                self.explicit_metadata = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for explicit_metadata: {}",
                            e
                        )
                    });
                self
            }
            pub fn non_fungible_include_nfids<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.non_fungible_include_nfids = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for non_fungible_include_nfids: {}",
                            e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateEntityNonFungiblesPageRequestOptIns>
        for super::StateEntityNonFungiblesPageRequestOptIns {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateEntityNonFungiblesPageRequestOptIns,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    explicit_metadata: value.explicit_metadata?,
                    non_fungible_include_nfids: value.non_fungible_include_nfids?,
                })
            }
        }
        impl From<super::StateEntityNonFungiblesPageRequestOptIns>
        for StateEntityNonFungiblesPageRequestOptIns {
            fn from(value: super::StateEntityNonFungiblesPageRequestOptIns) -> Self {
                Self {
                    explicit_metadata: Ok(value.explicit_metadata),
                    non_fungible_include_nfids: Ok(value.non_fungible_include_nfids),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateEntityNonFungiblesPageResponse {
            address: Result<super::Address, String>,
            items: Result<Vec<super::NonFungibleResourcesCollectionItem>, String>,
            ledger_state: Result<super::LedgerState, String>,
            next_cursor: Result<Option<String>, String>,
            total_count: Result<Option<i64>, String>,
        }
        impl Default for StateEntityNonFungiblesPageResponse {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    items: Err("no value supplied for items".to_string()),
                    ledger_state: Err("no value supplied for ledger_state".to_string()),
                    next_cursor: Ok(Default::default()),
                    total_count: Ok(Default::default()),
                }
            }
        }
        impl StateEntityNonFungiblesPageResponse {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for address: {}", e)
                    });
                self
            }
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::NonFungibleResourcesCollectionItem>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {}", e)
                    });
                self
            }
            pub fn ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::LedgerState>,
                T::Error: std::fmt::Display,
            {
                self.ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn next_cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for next_cursor: {}", e)
                    });
                self
            }
            pub fn total_count<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.total_count = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for total_count: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateEntityNonFungiblesPageResponse>
        for super::StateEntityNonFungiblesPageResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateEntityNonFungiblesPageResponse,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    items: value.items?,
                    ledger_state: value.ledger_state?,
                    next_cursor: value.next_cursor?,
                    total_count: value.total_count?,
                })
            }
        }
        impl From<super::StateEntityNonFungiblesPageResponse>
        for StateEntityNonFungiblesPageResponse {
            fn from(value: super::StateEntityNonFungiblesPageResponse) -> Self {
                Self {
                    address: Ok(value.address),
                    items: Ok(value.items),
                    ledger_state: Ok(value.ledger_state),
                    next_cursor: Ok(value.next_cursor),
                    total_count: Ok(value.total_count),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateEntitySchemaPageRequest {
            address: Result<super::Address, String>,
            at_ledger_state: Result<Option<super::LedgerStateSelector>, String>,
            cursor: Result<Option<String>, String>,
            limit_per_page: Result<Option<i64>, String>,
        }
        impl Default for StateEntitySchemaPageRequest {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    at_ledger_state: Ok(Default::default()),
                    cursor: Ok(Default::default()),
                    limit_per_page: Ok(Default::default()),
                }
            }
        }
        impl StateEntitySchemaPageRequest {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for address: {}", e)
                    });
                self
            }
            pub fn at_ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::LedgerStateSelector>>,
                T::Error: std::fmt::Display,
            {
                self.at_ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for at_ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for cursor: {}", e)
                    });
                self
            }
            pub fn limit_per_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.limit_per_page = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for limit_per_page: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateEntitySchemaPageRequest>
        for super::StateEntitySchemaPageRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateEntitySchemaPageRequest,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    at_ledger_state: value.at_ledger_state?,
                    cursor: value.cursor?,
                    limit_per_page: value.limit_per_page?,
                })
            }
        }
        impl From<super::StateEntitySchemaPageRequest> for StateEntitySchemaPageRequest {
            fn from(value: super::StateEntitySchemaPageRequest) -> Self {
                Self {
                    address: Ok(value.address),
                    at_ledger_state: Ok(value.at_ledger_state),
                    cursor: Ok(value.cursor),
                    limit_per_page: Ok(value.limit_per_page),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateEntitySchemaPageResponse {
            address: Result<super::Address, String>,
            items: Result<Vec<super::EntitySchemaCollectionItem>, String>,
            ledger_state: Result<super::LedgerState, String>,
            next_cursor: Result<Option<String>, String>,
            total_count: Result<Option<i64>, String>,
        }
        impl Default for StateEntitySchemaPageResponse {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    items: Err("no value supplied for items".to_string()),
                    ledger_state: Err("no value supplied for ledger_state".to_string()),
                    next_cursor: Ok(Default::default()),
                    total_count: Ok(Default::default()),
                }
            }
        }
        impl StateEntitySchemaPageResponse {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for address: {}", e)
                    });
                self
            }
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::EntitySchemaCollectionItem>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {}", e)
                    });
                self
            }
            pub fn ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::LedgerState>,
                T::Error: std::fmt::Display,
            {
                self.ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn next_cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for next_cursor: {}", e)
                    });
                self
            }
            pub fn total_count<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.total_count = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for total_count: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateEntitySchemaPageResponse>
        for super::StateEntitySchemaPageResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateEntitySchemaPageResponse,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    items: value.items?,
                    ledger_state: value.ledger_state?,
                    next_cursor: value.next_cursor?,
                    total_count: value.total_count?,
                })
            }
        }
        impl From<super::StateEntitySchemaPageResponse>
        for StateEntitySchemaPageResponse {
            fn from(value: super::StateEntitySchemaPageResponse) -> Self {
                Self {
                    address: Ok(value.address),
                    items: Ok(value.items),
                    ledger_state: Ok(value.ledger_state),
                    next_cursor: Ok(value.next_cursor),
                    total_count: Ok(value.total_count),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateKeyValueStoreDataRequest {
            at_ledger_state: Result<Option<super::LedgerStateSelector>, String>,
            key_value_store_address: Result<super::Address, String>,
            keys: Result<Vec<super::StateKeyValueStoreDataRequestKeyItem>, String>,
        }
        impl Default for StateKeyValueStoreDataRequest {
            fn default() -> Self {
                Self {
                    at_ledger_state: Ok(Default::default()),
                    key_value_store_address: Err(
                        "no value supplied for key_value_store_address".to_string(),
                    ),
                    keys: Err("no value supplied for keys".to_string()),
                }
            }
        }
        impl StateKeyValueStoreDataRequest {
            pub fn at_ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::LedgerStateSelector>>,
                T::Error: std::fmt::Display,
            {
                self.at_ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for at_ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn key_value_store_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.key_value_store_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for key_value_store_address: {}",
                            e
                        )
                    });
                self
            }
            pub fn keys<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    Vec<super::StateKeyValueStoreDataRequestKeyItem>,
                >,
                T::Error: std::fmt::Display,
            {
                self.keys = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for keys: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateKeyValueStoreDataRequest>
        for super::StateKeyValueStoreDataRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateKeyValueStoreDataRequest,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    at_ledger_state: value.at_ledger_state?,
                    key_value_store_address: value.key_value_store_address?,
                    keys: value.keys?,
                })
            }
        }
        impl From<super::StateKeyValueStoreDataRequest>
        for StateKeyValueStoreDataRequest {
            fn from(value: super::StateKeyValueStoreDataRequest) -> Self {
                Self {
                    at_ledger_state: Ok(value.at_ledger_state),
                    key_value_store_address: Ok(value.key_value_store_address),
                    keys: Ok(value.keys),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateKeyValueStoreDataRequestKeyItem {
            key_hex: Result<Option<super::HexString>, String>,
            key_json: Result<Option<super::ProgrammaticScryptoSborValue>, String>,
        }
        impl Default for StateKeyValueStoreDataRequestKeyItem {
            fn default() -> Self {
                Self {
                    key_hex: Ok(Default::default()),
                    key_json: Ok(Default::default()),
                }
            }
        }
        impl StateKeyValueStoreDataRequestKeyItem {
            pub fn key_hex<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::HexString>>,
                T::Error: std::fmt::Display,
            {
                self.key_hex = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for key_hex: {}", e)
                    });
                self
            }
            pub fn key_json<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::ProgrammaticScryptoSborValue>>,
                T::Error: std::fmt::Display,
            {
                self.key_json = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for key_json: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateKeyValueStoreDataRequestKeyItem>
        for super::StateKeyValueStoreDataRequestKeyItem {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateKeyValueStoreDataRequestKeyItem,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    key_hex: value.key_hex?,
                    key_json: value.key_json?,
                })
            }
        }
        impl From<super::StateKeyValueStoreDataRequestKeyItem>
        for StateKeyValueStoreDataRequestKeyItem {
            fn from(value: super::StateKeyValueStoreDataRequestKeyItem) -> Self {
                Self {
                    key_hex: Ok(value.key_hex),
                    key_json: Ok(value.key_json),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateKeyValueStoreDataResponse {
            entries: Result<Vec<super::StateKeyValueStoreDataResponseItem>, String>,
            key_value_store_address: Result<super::Address, String>,
            ledger_state: Result<super::LedgerState, String>,
        }
        impl Default for StateKeyValueStoreDataResponse {
            fn default() -> Self {
                Self {
                    entries: Err("no value supplied for entries".to_string()),
                    key_value_store_address: Err(
                        "no value supplied for key_value_store_address".to_string(),
                    ),
                    ledger_state: Err("no value supplied for ledger_state".to_string()),
                }
            }
        }
        impl StateKeyValueStoreDataResponse {
            pub fn entries<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::StateKeyValueStoreDataResponseItem>>,
                T::Error: std::fmt::Display,
            {
                self.entries = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for entries: {}", e)
                    });
                self
            }
            pub fn key_value_store_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.key_value_store_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for key_value_store_address: {}",
                            e
                        )
                    });
                self
            }
            pub fn ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::LedgerState>,
                T::Error: std::fmt::Display,
            {
                self.ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for ledger_state: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateKeyValueStoreDataResponse>
        for super::StateKeyValueStoreDataResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateKeyValueStoreDataResponse,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    entries: value.entries?,
                    key_value_store_address: value.key_value_store_address?,
                    ledger_state: value.ledger_state?,
                })
            }
        }
        impl From<super::StateKeyValueStoreDataResponse>
        for StateKeyValueStoreDataResponse {
            fn from(value: super::StateKeyValueStoreDataResponse) -> Self {
                Self {
                    entries: Ok(value.entries),
                    key_value_store_address: Ok(value.key_value_store_address),
                    ledger_state: Ok(value.ledger_state),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateKeyValueStoreDataResponseItem {
            is_locked: Result<bool, String>,
            key: Result<super::ScryptoSborValue, String>,
            last_updated_at_state_version: Result<
                super::LastUpdatedAtStateVersion,
                String,
            >,
            value: Result<super::ScryptoSborValue, String>,
        }
        impl Default for StateKeyValueStoreDataResponseItem {
            fn default() -> Self {
                Self {
                    is_locked: Err("no value supplied for is_locked".to_string()),
                    key: Err("no value supplied for key".to_string()),
                    last_updated_at_state_version: Err(
                        "no value supplied for last_updated_at_state_version".to_string(),
                    ),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl StateKeyValueStoreDataResponseItem {
            pub fn is_locked<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.is_locked = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for is_locked: {}", e)
                    });
                self
            }
            pub fn key<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ScryptoSborValue>,
                T::Error: std::fmt::Display,
            {
                self.key = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for key: {}", e)
                    });
                self
            }
            pub fn last_updated_at_state_version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::LastUpdatedAtStateVersion>,
                T::Error: std::fmt::Display,
            {
                self.last_updated_at_state_version = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for last_updated_at_state_version: {}",
                            e
                        )
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ScryptoSborValue>,
                T::Error: std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateKeyValueStoreDataResponseItem>
        for super::StateKeyValueStoreDataResponseItem {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateKeyValueStoreDataResponseItem,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    is_locked: value.is_locked?,
                    key: value.key?,
                    last_updated_at_state_version: value.last_updated_at_state_version?,
                    value: value.value?,
                })
            }
        }
        impl From<super::StateKeyValueStoreDataResponseItem>
        for StateKeyValueStoreDataResponseItem {
            fn from(value: super::StateKeyValueStoreDataResponseItem) -> Self {
                Self {
                    is_locked: Ok(value.is_locked),
                    key: Ok(value.key),
                    last_updated_at_state_version: Ok(
                        value.last_updated_at_state_version,
                    ),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateKeyValueStoreKeysCollection {
            items: Result<Vec<super::StateKeyValueStoreKeysResponseItem>, String>,
            next_cursor: Result<Option<String>, String>,
            total_count: Result<Option<i64>, String>,
        }
        impl Default for StateKeyValueStoreKeysCollection {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_cursor: Ok(Default::default()),
                    total_count: Ok(Default::default()),
                }
            }
        }
        impl StateKeyValueStoreKeysCollection {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::StateKeyValueStoreKeysResponseItem>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {}", e)
                    });
                self
            }
            pub fn next_cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for next_cursor: {}", e)
                    });
                self
            }
            pub fn total_count<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.total_count = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for total_count: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateKeyValueStoreKeysCollection>
        for super::StateKeyValueStoreKeysCollection {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateKeyValueStoreKeysCollection,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_cursor: value.next_cursor?,
                    total_count: value.total_count?,
                })
            }
        }
        impl From<super::StateKeyValueStoreKeysCollection>
        for StateKeyValueStoreKeysCollection {
            fn from(value: super::StateKeyValueStoreKeysCollection) -> Self {
                Self {
                    items: Ok(value.items),
                    next_cursor: Ok(value.next_cursor),
                    total_count: Ok(value.total_count),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateKeyValueStoreKeysRequest {
            at_ledger_state: Result<Option<super::LedgerStateSelector>, String>,
            cursor: Result<Option<String>, String>,
            key_value_store_address: Result<super::Address, String>,
            limit_per_page: Result<Option<i64>, String>,
        }
        impl Default for StateKeyValueStoreKeysRequest {
            fn default() -> Self {
                Self {
                    at_ledger_state: Ok(Default::default()),
                    cursor: Ok(Default::default()),
                    key_value_store_address: Err(
                        "no value supplied for key_value_store_address".to_string(),
                    ),
                    limit_per_page: Ok(Default::default()),
                }
            }
        }
        impl StateKeyValueStoreKeysRequest {
            pub fn at_ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::LedgerStateSelector>>,
                T::Error: std::fmt::Display,
            {
                self.at_ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for at_ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for cursor: {}", e)
                    });
                self
            }
            pub fn key_value_store_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.key_value_store_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for key_value_store_address: {}",
                            e
                        )
                    });
                self
            }
            pub fn limit_per_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.limit_per_page = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for limit_per_page: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateKeyValueStoreKeysRequest>
        for super::StateKeyValueStoreKeysRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateKeyValueStoreKeysRequest,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    at_ledger_state: value.at_ledger_state?,
                    cursor: value.cursor?,
                    key_value_store_address: value.key_value_store_address?,
                    limit_per_page: value.limit_per_page?,
                })
            }
        }
        impl From<super::StateKeyValueStoreKeysRequest>
        for StateKeyValueStoreKeysRequest {
            fn from(value: super::StateKeyValueStoreKeysRequest) -> Self {
                Self {
                    at_ledger_state: Ok(value.at_ledger_state),
                    cursor: Ok(value.cursor),
                    key_value_store_address: Ok(value.key_value_store_address),
                    limit_per_page: Ok(value.limit_per_page),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateKeyValueStoreKeysResponse {
            items: Result<Vec<super::StateKeyValueStoreKeysResponseItem>, String>,
            key_value_store_address: Result<super::Address, String>,
            ledger_state: Result<super::LedgerState, String>,
            next_cursor: Result<Option<String>, String>,
            total_count: Result<Option<i64>, String>,
        }
        impl Default for StateKeyValueStoreKeysResponse {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    key_value_store_address: Err(
                        "no value supplied for key_value_store_address".to_string(),
                    ),
                    ledger_state: Err("no value supplied for ledger_state".to_string()),
                    next_cursor: Ok(Default::default()),
                    total_count: Ok(Default::default()),
                }
            }
        }
        impl StateKeyValueStoreKeysResponse {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::StateKeyValueStoreKeysResponseItem>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {}", e)
                    });
                self
            }
            pub fn key_value_store_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.key_value_store_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for key_value_store_address: {}",
                            e
                        )
                    });
                self
            }
            pub fn ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::LedgerState>,
                T::Error: std::fmt::Display,
            {
                self.ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn next_cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for next_cursor: {}", e)
                    });
                self
            }
            pub fn total_count<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.total_count = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for total_count: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateKeyValueStoreKeysResponse>
        for super::StateKeyValueStoreKeysResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateKeyValueStoreKeysResponse,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    key_value_store_address: value.key_value_store_address?,
                    ledger_state: value.ledger_state?,
                    next_cursor: value.next_cursor?,
                    total_count: value.total_count?,
                })
            }
        }
        impl From<super::StateKeyValueStoreKeysResponse>
        for StateKeyValueStoreKeysResponse {
            fn from(value: super::StateKeyValueStoreKeysResponse) -> Self {
                Self {
                    items: Ok(value.items),
                    key_value_store_address: Ok(value.key_value_store_address),
                    ledger_state: Ok(value.ledger_state),
                    next_cursor: Ok(value.next_cursor),
                    total_count: Ok(value.total_count),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateKeyValueStoreKeysResponseItem {
            key: Result<super::ScryptoSborValue, String>,
            last_updated_at_state_version: Result<
                super::LastUpdatedAtStateVersion,
                String,
            >,
        }
        impl Default for StateKeyValueStoreKeysResponseItem {
            fn default() -> Self {
                Self {
                    key: Err("no value supplied for key".to_string()),
                    last_updated_at_state_version: Err(
                        "no value supplied for last_updated_at_state_version".to_string(),
                    ),
                }
            }
        }
        impl StateKeyValueStoreKeysResponseItem {
            pub fn key<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ScryptoSborValue>,
                T::Error: std::fmt::Display,
            {
                self.key = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for key: {}", e)
                    });
                self
            }
            pub fn last_updated_at_state_version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::LastUpdatedAtStateVersion>,
                T::Error: std::fmt::Display,
            {
                self.last_updated_at_state_version = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for last_updated_at_state_version: {}",
                            e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateKeyValueStoreKeysResponseItem>
        for super::StateKeyValueStoreKeysResponseItem {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateKeyValueStoreKeysResponseItem,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    key: value.key?,
                    last_updated_at_state_version: value.last_updated_at_state_version?,
                })
            }
        }
        impl From<super::StateKeyValueStoreKeysResponseItem>
        for StateKeyValueStoreKeysResponseItem {
            fn from(value: super::StateKeyValueStoreKeysResponseItem) -> Self {
                Self {
                    key: Ok(value.key),
                    last_updated_at_state_version: Ok(
                        value.last_updated_at_state_version,
                    ),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateNonFungibleDataRequest {
            at_ledger_state: Result<Option<super::LedgerStateSelector>, String>,
            non_fungible_ids: Result<Vec<super::NonFungibleId>, String>,
            resource_address: Result<super::Address, String>,
        }
        impl Default for StateNonFungibleDataRequest {
            fn default() -> Self {
                Self {
                    at_ledger_state: Ok(Default::default()),
                    non_fungible_ids: Err(
                        "no value supplied for non_fungible_ids".to_string(),
                    ),
                    resource_address: Err(
                        "no value supplied for resource_address".to_string(),
                    ),
                }
            }
        }
        impl StateNonFungibleDataRequest {
            pub fn at_ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::LedgerStateSelector>>,
                T::Error: std::fmt::Display,
            {
                self.at_ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for at_ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn non_fungible_ids<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::NonFungibleId>>,
                T::Error: std::fmt::Display,
            {
                self.non_fungible_ids = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for non_fungible_ids: {}", e
                        )
                    });
                self
            }
            pub fn resource_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.resource_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_address: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateNonFungibleDataRequest>
        for super::StateNonFungibleDataRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateNonFungibleDataRequest,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    at_ledger_state: value.at_ledger_state?,
                    non_fungible_ids: value.non_fungible_ids?,
                    resource_address: value.resource_address?,
                })
            }
        }
        impl From<super::StateNonFungibleDataRequest> for StateNonFungibleDataRequest {
            fn from(value: super::StateNonFungibleDataRequest) -> Self {
                Self {
                    at_ledger_state: Ok(value.at_ledger_state),
                    non_fungible_ids: Ok(value.non_fungible_ids),
                    resource_address: Ok(value.resource_address),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateNonFungibleDataResponse {
            ledger_state: Result<super::LedgerState, String>,
            non_fungible_id_type: Result<super::NonFungibleIdType, String>,
            non_fungible_ids: Result<
                Vec<super::StateNonFungibleDetailsResponseItem>,
                String,
            >,
            resource_address: Result<super::Address, String>,
        }
        impl Default for StateNonFungibleDataResponse {
            fn default() -> Self {
                Self {
                    ledger_state: Err("no value supplied for ledger_state".to_string()),
                    non_fungible_id_type: Err(
                        "no value supplied for non_fungible_id_type".to_string(),
                    ),
                    non_fungible_ids: Err(
                        "no value supplied for non_fungible_ids".to_string(),
                    ),
                    resource_address: Err(
                        "no value supplied for resource_address".to_string(),
                    ),
                }
            }
        }
        impl StateNonFungibleDataResponse {
            pub fn ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::LedgerState>,
                T::Error: std::fmt::Display,
            {
                self.ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn non_fungible_id_type<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::NonFungibleIdType>,
                T::Error: std::fmt::Display,
            {
                self.non_fungible_id_type = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for non_fungible_id_type: {}",
                            e
                        )
                    });
                self
            }
            pub fn non_fungible_ids<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    Vec<super::StateNonFungibleDetailsResponseItem>,
                >,
                T::Error: std::fmt::Display,
            {
                self.non_fungible_ids = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for non_fungible_ids: {}", e
                        )
                    });
                self
            }
            pub fn resource_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.resource_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_address: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateNonFungibleDataResponse>
        for super::StateNonFungibleDataResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateNonFungibleDataResponse,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    ledger_state: value.ledger_state?,
                    non_fungible_id_type: value.non_fungible_id_type?,
                    non_fungible_ids: value.non_fungible_ids?,
                    resource_address: value.resource_address?,
                })
            }
        }
        impl From<super::StateNonFungibleDataResponse> for StateNonFungibleDataResponse {
            fn from(value: super::StateNonFungibleDataResponse) -> Self {
                Self {
                    ledger_state: Ok(value.ledger_state),
                    non_fungible_id_type: Ok(value.non_fungible_id_type),
                    non_fungible_ids: Ok(value.non_fungible_ids),
                    resource_address: Ok(value.resource_address),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateNonFungibleDetailsResponseItem {
            data: Result<Option<super::ScryptoSborValue>, String>,
            is_burned: Result<bool, String>,
            last_updated_at_state_version: Result<
                super::LastUpdatedAtStateVersion,
                String,
            >,
            non_fungible_id: Result<super::NonFungibleId, String>,
        }
        impl Default for StateNonFungibleDetailsResponseItem {
            fn default() -> Self {
                Self {
                    data: Ok(Default::default()),
                    is_burned: Err("no value supplied for is_burned".to_string()),
                    last_updated_at_state_version: Err(
                        "no value supplied for last_updated_at_state_version".to_string(),
                    ),
                    non_fungible_id: Err(
                        "no value supplied for non_fungible_id".to_string(),
                    ),
                }
            }
        }
        impl StateNonFungibleDetailsResponseItem {
            pub fn data<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::ScryptoSborValue>>,
                T::Error: std::fmt::Display,
            {
                self.data = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for data: {}", e)
                    });
                self
            }
            pub fn is_burned<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.is_burned = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for is_burned: {}", e)
                    });
                self
            }
            pub fn last_updated_at_state_version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::LastUpdatedAtStateVersion>,
                T::Error: std::fmt::Display,
            {
                self.last_updated_at_state_version = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for last_updated_at_state_version: {}",
                            e
                        )
                    });
                self
            }
            pub fn non_fungible_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::NonFungibleId>,
                T::Error: std::fmt::Display,
            {
                self.non_fungible_id = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for non_fungible_id: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateNonFungibleDetailsResponseItem>
        for super::StateNonFungibleDetailsResponseItem {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateNonFungibleDetailsResponseItem,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    data: value.data?,
                    is_burned: value.is_burned?,
                    last_updated_at_state_version: value.last_updated_at_state_version?,
                    non_fungible_id: value.non_fungible_id?,
                })
            }
        }
        impl From<super::StateNonFungibleDetailsResponseItem>
        for StateNonFungibleDetailsResponseItem {
            fn from(value: super::StateNonFungibleDetailsResponseItem) -> Self {
                Self {
                    data: Ok(value.data),
                    is_burned: Ok(value.is_burned),
                    last_updated_at_state_version: Ok(
                        value.last_updated_at_state_version,
                    ),
                    non_fungible_id: Ok(value.non_fungible_id),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateNonFungibleIdsRequest {
            at_ledger_state: Result<Option<super::LedgerStateSelector>, String>,
            cursor: Result<Option<String>, String>,
            limit_per_page: Result<Option<i64>, String>,
            resource_address: Result<super::Address, String>,
        }
        impl Default for StateNonFungibleIdsRequest {
            fn default() -> Self {
                Self {
                    at_ledger_state: Ok(Default::default()),
                    cursor: Ok(Default::default()),
                    limit_per_page: Ok(Default::default()),
                    resource_address: Err(
                        "no value supplied for resource_address".to_string(),
                    ),
                }
            }
        }
        impl StateNonFungibleIdsRequest {
            pub fn at_ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::LedgerStateSelector>>,
                T::Error: std::fmt::Display,
            {
                self.at_ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for at_ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for cursor: {}", e)
                    });
                self
            }
            pub fn limit_per_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.limit_per_page = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for limit_per_page: {}", e
                        )
                    });
                self
            }
            pub fn resource_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.resource_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_address: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateNonFungibleIdsRequest>
        for super::StateNonFungibleIdsRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateNonFungibleIdsRequest,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    at_ledger_state: value.at_ledger_state?,
                    cursor: value.cursor?,
                    limit_per_page: value.limit_per_page?,
                    resource_address: value.resource_address?,
                })
            }
        }
        impl From<super::StateNonFungibleIdsRequest> for StateNonFungibleIdsRequest {
            fn from(value: super::StateNonFungibleIdsRequest) -> Self {
                Self {
                    at_ledger_state: Ok(value.at_ledger_state),
                    cursor: Ok(value.cursor),
                    limit_per_page: Ok(value.limit_per_page),
                    resource_address: Ok(value.resource_address),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateNonFungibleIdsResponse {
            ledger_state: Result<super::LedgerState, String>,
            non_fungible_ids: Result<super::NonFungibleIdsCollection, String>,
            resource_address: Result<super::Address, String>,
        }
        impl Default for StateNonFungibleIdsResponse {
            fn default() -> Self {
                Self {
                    ledger_state: Err("no value supplied for ledger_state".to_string()),
                    non_fungible_ids: Err(
                        "no value supplied for non_fungible_ids".to_string(),
                    ),
                    resource_address: Err(
                        "no value supplied for resource_address".to_string(),
                    ),
                }
            }
        }
        impl StateNonFungibleIdsResponse {
            pub fn ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::LedgerState>,
                T::Error: std::fmt::Display,
            {
                self.ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn non_fungible_ids<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::NonFungibleIdsCollection>,
                T::Error: std::fmt::Display,
            {
                self.non_fungible_ids = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for non_fungible_ids: {}", e
                        )
                    });
                self
            }
            pub fn resource_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.resource_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_address: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateNonFungibleIdsResponse>
        for super::StateNonFungibleIdsResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateNonFungibleIdsResponse,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    ledger_state: value.ledger_state?,
                    non_fungible_ids: value.non_fungible_ids?,
                    resource_address: value.resource_address?,
                })
            }
        }
        impl From<super::StateNonFungibleIdsResponse> for StateNonFungibleIdsResponse {
            fn from(value: super::StateNonFungibleIdsResponse) -> Self {
                Self {
                    ledger_state: Ok(value.ledger_state),
                    non_fungible_ids: Ok(value.non_fungible_ids),
                    resource_address: Ok(value.resource_address),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateNonFungibleLocationRequest {
            at_ledger_state: Result<Option<super::LedgerStateSelector>, String>,
            non_fungible_ids: Result<Vec<super::NonFungibleId>, String>,
            resource_address: Result<super::Address, String>,
        }
        impl Default for StateNonFungibleLocationRequest {
            fn default() -> Self {
                Self {
                    at_ledger_state: Ok(Default::default()),
                    non_fungible_ids: Err(
                        "no value supplied for non_fungible_ids".to_string(),
                    ),
                    resource_address: Err(
                        "no value supplied for resource_address".to_string(),
                    ),
                }
            }
        }
        impl StateNonFungibleLocationRequest {
            pub fn at_ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::LedgerStateSelector>>,
                T::Error: std::fmt::Display,
            {
                self.at_ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for at_ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn non_fungible_ids<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::NonFungibleId>>,
                T::Error: std::fmt::Display,
            {
                self.non_fungible_ids = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for non_fungible_ids: {}", e
                        )
                    });
                self
            }
            pub fn resource_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.resource_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_address: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateNonFungibleLocationRequest>
        for super::StateNonFungibleLocationRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateNonFungibleLocationRequest,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    at_ledger_state: value.at_ledger_state?,
                    non_fungible_ids: value.non_fungible_ids?,
                    resource_address: value.resource_address?,
                })
            }
        }
        impl From<super::StateNonFungibleLocationRequest>
        for StateNonFungibleLocationRequest {
            fn from(value: super::StateNonFungibleLocationRequest) -> Self {
                Self {
                    at_ledger_state: Ok(value.at_ledger_state),
                    non_fungible_ids: Ok(value.non_fungible_ids),
                    resource_address: Ok(value.resource_address),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateNonFungibleLocationResponse {
            ledger_state: Result<super::LedgerState, String>,
            non_fungible_ids: Result<
                Vec<super::StateNonFungibleLocationResponseItem>,
                String,
            >,
            resource_address: Result<super::Address, String>,
        }
        impl Default for StateNonFungibleLocationResponse {
            fn default() -> Self {
                Self {
                    ledger_state: Err("no value supplied for ledger_state".to_string()),
                    non_fungible_ids: Err(
                        "no value supplied for non_fungible_ids".to_string(),
                    ),
                    resource_address: Err(
                        "no value supplied for resource_address".to_string(),
                    ),
                }
            }
        }
        impl StateNonFungibleLocationResponse {
            pub fn ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::LedgerState>,
                T::Error: std::fmt::Display,
            {
                self.ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn non_fungible_ids<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    Vec<super::StateNonFungibleLocationResponseItem>,
                >,
                T::Error: std::fmt::Display,
            {
                self.non_fungible_ids = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for non_fungible_ids: {}", e
                        )
                    });
                self
            }
            pub fn resource_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.resource_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_address: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateNonFungibleLocationResponse>
        for super::StateNonFungibleLocationResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateNonFungibleLocationResponse,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    ledger_state: value.ledger_state?,
                    non_fungible_ids: value.non_fungible_ids?,
                    resource_address: value.resource_address?,
                })
            }
        }
        impl From<super::StateNonFungibleLocationResponse>
        for StateNonFungibleLocationResponse {
            fn from(value: super::StateNonFungibleLocationResponse) -> Self {
                Self {
                    ledger_state: Ok(value.ledger_state),
                    non_fungible_ids: Ok(value.non_fungible_ids),
                    resource_address: Ok(value.resource_address),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateNonFungibleLocationResponseItem {
            is_burned: Result<bool, String>,
            last_updated_at_state_version: Result<
                super::LastUpdatedAtStateVersion,
                String,
            >,
            non_fungible_id: Result<super::NonFungibleId, String>,
            owning_vault_address: Result<Option<super::Address>, String>,
            owning_vault_global_ancestor_address: Result<Option<super::Address>, String>,
            owning_vault_parent_ancestor_address: Result<Option<super::Address>, String>,
        }
        impl Default for StateNonFungibleLocationResponseItem {
            fn default() -> Self {
                Self {
                    is_burned: Err("no value supplied for is_burned".to_string()),
                    last_updated_at_state_version: Err(
                        "no value supplied for last_updated_at_state_version".to_string(),
                    ),
                    non_fungible_id: Err(
                        "no value supplied for non_fungible_id".to_string(),
                    ),
                    owning_vault_address: Ok(Default::default()),
                    owning_vault_global_ancestor_address: Ok(Default::default()),
                    owning_vault_parent_ancestor_address: Ok(Default::default()),
                }
            }
        }
        impl StateNonFungibleLocationResponseItem {
            pub fn is_burned<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.is_burned = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for is_burned: {}", e)
                    });
                self
            }
            pub fn last_updated_at_state_version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::LastUpdatedAtStateVersion>,
                T::Error: std::fmt::Display,
            {
                self.last_updated_at_state_version = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for last_updated_at_state_version: {}",
                            e
                        )
                    });
                self
            }
            pub fn non_fungible_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::NonFungibleId>,
                T::Error: std::fmt::Display,
            {
                self.non_fungible_id = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for non_fungible_id: {}", e
                        )
                    });
                self
            }
            pub fn owning_vault_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::Address>>,
                T::Error: std::fmt::Display,
            {
                self.owning_vault_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for owning_vault_address: {}",
                            e
                        )
                    });
                self
            }
            pub fn owning_vault_global_ancestor_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::Address>>,
                T::Error: std::fmt::Display,
            {
                self.owning_vault_global_ancestor_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for owning_vault_global_ancestor_address: {}",
                            e
                        )
                    });
                self
            }
            pub fn owning_vault_parent_ancestor_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::Address>>,
                T::Error: std::fmt::Display,
            {
                self.owning_vault_parent_ancestor_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for owning_vault_parent_ancestor_address: {}",
                            e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateNonFungibleLocationResponseItem>
        for super::StateNonFungibleLocationResponseItem {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateNonFungibleLocationResponseItem,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    is_burned: value.is_burned?,
                    last_updated_at_state_version: value.last_updated_at_state_version?,
                    non_fungible_id: value.non_fungible_id?,
                    owning_vault_address: value.owning_vault_address?,
                    owning_vault_global_ancestor_address: value
                        .owning_vault_global_ancestor_address?,
                    owning_vault_parent_ancestor_address: value
                        .owning_vault_parent_ancestor_address?,
                })
            }
        }
        impl From<super::StateNonFungibleLocationResponseItem>
        for StateNonFungibleLocationResponseItem {
            fn from(value: super::StateNonFungibleLocationResponseItem) -> Self {
                Self {
                    is_burned: Ok(value.is_burned),
                    last_updated_at_state_version: Ok(
                        value.last_updated_at_state_version,
                    ),
                    non_fungible_id: Ok(value.non_fungible_id),
                    owning_vault_address: Ok(value.owning_vault_address),
                    owning_vault_global_ancestor_address: Ok(
                        value.owning_vault_global_ancestor_address,
                    ),
                    owning_vault_parent_ancestor_address: Ok(
                        value.owning_vault_parent_ancestor_address,
                    ),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StatePackageBlueprintPageRequest {
            at_ledger_state: Result<Option<super::LedgerStateSelector>, String>,
            cursor: Result<Option<String>, String>,
            limit_per_page: Result<Option<i64>, String>,
            package_address: Result<super::Address, String>,
        }
        impl Default for StatePackageBlueprintPageRequest {
            fn default() -> Self {
                Self {
                    at_ledger_state: Ok(Default::default()),
                    cursor: Ok(Default::default()),
                    limit_per_page: Ok(Default::default()),
                    package_address: Err(
                        "no value supplied for package_address".to_string(),
                    ),
                }
            }
        }
        impl StatePackageBlueprintPageRequest {
            pub fn at_ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::LedgerStateSelector>>,
                T::Error: std::fmt::Display,
            {
                self.at_ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for at_ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for cursor: {}", e)
                    });
                self
            }
            pub fn limit_per_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.limit_per_page = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for limit_per_page: {}", e
                        )
                    });
                self
            }
            pub fn package_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.package_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for package_address: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<StatePackageBlueprintPageRequest>
        for super::StatePackageBlueprintPageRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StatePackageBlueprintPageRequest,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    at_ledger_state: value.at_ledger_state?,
                    cursor: value.cursor?,
                    limit_per_page: value.limit_per_page?,
                    package_address: value.package_address?,
                })
            }
        }
        impl From<super::StatePackageBlueprintPageRequest>
        for StatePackageBlueprintPageRequest {
            fn from(value: super::StatePackageBlueprintPageRequest) -> Self {
                Self {
                    at_ledger_state: Ok(value.at_ledger_state),
                    cursor: Ok(value.cursor),
                    limit_per_page: Ok(value.limit_per_page),
                    package_address: Ok(value.package_address),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StatePackageBlueprintPageResponse {
            items: Result<Vec<super::PackageBlueprintCollectionItem>, String>,
            ledger_state: Result<super::LedgerState, String>,
            next_cursor: Result<Option<String>, String>,
            package_address: Result<super::Address, String>,
            total_count: Result<Option<i64>, String>,
        }
        impl Default for StatePackageBlueprintPageResponse {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    ledger_state: Err("no value supplied for ledger_state".to_string()),
                    next_cursor: Ok(Default::default()),
                    package_address: Err(
                        "no value supplied for package_address".to_string(),
                    ),
                    total_count: Ok(Default::default()),
                }
            }
        }
        impl StatePackageBlueprintPageResponse {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::PackageBlueprintCollectionItem>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {}", e)
                    });
                self
            }
            pub fn ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::LedgerState>,
                T::Error: std::fmt::Display,
            {
                self.ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn next_cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for next_cursor: {}", e)
                    });
                self
            }
            pub fn package_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.package_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for package_address: {}", e
                        )
                    });
                self
            }
            pub fn total_count<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.total_count = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for total_count: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<StatePackageBlueprintPageResponse>
        for super::StatePackageBlueprintPageResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StatePackageBlueprintPageResponse,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    ledger_state: value.ledger_state?,
                    next_cursor: value.next_cursor?,
                    package_address: value.package_address?,
                    total_count: value.total_count?,
                })
            }
        }
        impl From<super::StatePackageBlueprintPageResponse>
        for StatePackageBlueprintPageResponse {
            fn from(value: super::StatePackageBlueprintPageResponse) -> Self {
                Self {
                    items: Ok(value.items),
                    ledger_state: Ok(value.ledger_state),
                    next_cursor: Ok(value.next_cursor),
                    package_address: Ok(value.package_address),
                    total_count: Ok(value.total_count),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StatePackageCodePageRequest {
            at_ledger_state: Result<Option<super::LedgerStateSelector>, String>,
            cursor: Result<Option<String>, String>,
            limit_per_page: Result<Option<i64>, String>,
            package_address: Result<super::Address, String>,
        }
        impl Default for StatePackageCodePageRequest {
            fn default() -> Self {
                Self {
                    at_ledger_state: Ok(Default::default()),
                    cursor: Ok(Default::default()),
                    limit_per_page: Ok(Default::default()),
                    package_address: Err(
                        "no value supplied for package_address".to_string(),
                    ),
                }
            }
        }
        impl StatePackageCodePageRequest {
            pub fn at_ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::LedgerStateSelector>>,
                T::Error: std::fmt::Display,
            {
                self.at_ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for at_ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for cursor: {}", e)
                    });
                self
            }
            pub fn limit_per_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.limit_per_page = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for limit_per_page: {}", e
                        )
                    });
                self
            }
            pub fn package_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.package_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for package_address: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<StatePackageCodePageRequest>
        for super::StatePackageCodePageRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StatePackageCodePageRequest,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    at_ledger_state: value.at_ledger_state?,
                    cursor: value.cursor?,
                    limit_per_page: value.limit_per_page?,
                    package_address: value.package_address?,
                })
            }
        }
        impl From<super::StatePackageCodePageRequest> for StatePackageCodePageRequest {
            fn from(value: super::StatePackageCodePageRequest) -> Self {
                Self {
                    at_ledger_state: Ok(value.at_ledger_state),
                    cursor: Ok(value.cursor),
                    limit_per_page: Ok(value.limit_per_page),
                    package_address: Ok(value.package_address),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StatePackageCodePageResponse {
            items: Result<Vec<super::PackageCodeCollectionItem>, String>,
            ledger_state: Result<super::LedgerState, String>,
            next_cursor: Result<Option<String>, String>,
            package_address: Result<super::Address, String>,
            total_count: Result<Option<i64>, String>,
        }
        impl Default for StatePackageCodePageResponse {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    ledger_state: Err("no value supplied for ledger_state".to_string()),
                    next_cursor: Ok(Default::default()),
                    package_address: Err(
                        "no value supplied for package_address".to_string(),
                    ),
                    total_count: Ok(Default::default()),
                }
            }
        }
        impl StatePackageCodePageResponse {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::PackageCodeCollectionItem>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {}", e)
                    });
                self
            }
            pub fn ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::LedgerState>,
                T::Error: std::fmt::Display,
            {
                self.ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn next_cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for next_cursor: {}", e)
                    });
                self
            }
            pub fn package_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.package_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for package_address: {}", e
                        )
                    });
                self
            }
            pub fn total_count<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.total_count = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for total_count: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<StatePackageCodePageResponse>
        for super::StatePackageCodePageResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StatePackageCodePageResponse,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    ledger_state: value.ledger_state?,
                    next_cursor: value.next_cursor?,
                    package_address: value.package_address?,
                    total_count: value.total_count?,
                })
            }
        }
        impl From<super::StatePackageCodePageResponse> for StatePackageCodePageResponse {
            fn from(value: super::StatePackageCodePageResponse) -> Self {
                Self {
                    items: Ok(value.items),
                    ledger_state: Ok(value.ledger_state),
                    next_cursor: Ok(value.next_cursor),
                    package_address: Ok(value.package_address),
                    total_count: Ok(value.total_count),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateValidatorsListRequest {
            at_ledger_state: Result<Option<super::LedgerStateSelector>, String>,
            cursor: Result<Option<String>, String>,
        }
        impl Default for StateValidatorsListRequest {
            fn default() -> Self {
                Self {
                    at_ledger_state: Ok(Default::default()),
                    cursor: Ok(Default::default()),
                }
            }
        }
        impl StateValidatorsListRequest {
            pub fn at_ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::LedgerStateSelector>>,
                T::Error: std::fmt::Display,
            {
                self.at_ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for at_ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for cursor: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateValidatorsListRequest>
        for super::StateValidatorsListRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateValidatorsListRequest,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    at_ledger_state: value.at_ledger_state?,
                    cursor: value.cursor?,
                })
            }
        }
        impl From<super::StateValidatorsListRequest> for StateValidatorsListRequest {
            fn from(value: super::StateValidatorsListRequest) -> Self {
                Self {
                    at_ledger_state: Ok(value.at_ledger_state),
                    cursor: Ok(value.cursor),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateValidatorsListResponse {
            ledger_state: Result<super::LedgerState, String>,
            validators: Result<super::ValidatorCollection, String>,
        }
        impl Default for StateValidatorsListResponse {
            fn default() -> Self {
                Self {
                    ledger_state: Err("no value supplied for ledger_state".to_string()),
                    validators: Err("no value supplied for validators".to_string()),
                }
            }
        }
        impl StateValidatorsListResponse {
            pub fn ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::LedgerState>,
                T::Error: std::fmt::Display,
            {
                self.ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn validators<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ValidatorCollection>,
                T::Error: std::fmt::Display,
            {
                self.validators = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for validators: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<StateValidatorsListResponse>
        for super::StateValidatorsListResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateValidatorsListResponse,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    ledger_state: value.ledger_state?,
                    validators: value.validators?,
                })
            }
        }
        impl From<super::StateValidatorsListResponse> for StateValidatorsListResponse {
            fn from(value: super::StateValidatorsListResponse) -> Self {
                Self {
                    ledger_state: Ok(value.ledger_state),
                    validators: Ok(value.validators),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StreamTransactionsRequest {
            accounts_with_manifest_owner_method_calls: Result<
                Vec<super::Address>,
                String,
            >,
            accounts_without_manifest_owner_method_calls: Result<
                Vec<super::Address>,
                String,
            >,
            affected_global_entities_filter: Result<Vec<super::Address>, String>,
            at_ledger_state: Result<Option<super::LedgerStateSelector>, String>,
            cursor: Result<Option<String>, String>,
            event_global_emitters_filter: Result<Vec<super::Address>, String>,
            events_filter: Result<
                Vec<super::StreamTransactionsRequestEventFilterItem>,
                String,
            >,
            from_ledger_state: Result<Option<super::LedgerStateSelector>, String>,
            kind_filter: Result<
                Option<super::StreamTransactionsRequestKindFilter>,
                String,
            >,
            limit_per_page: Result<Option<i64>, String>,
            manifest_accounts_deposited_into_filter: Result<Vec<super::Address>, String>,
            manifest_accounts_withdrawn_from_filter: Result<Vec<super::Address>, String>,
            manifest_badges_presented_filter: Result<Vec<super::Address>, String>,
            manifest_class_filter: Result<
                Option<super::StreamTransactionsRequestManifestClassFilter>,
                String,
            >,
            manifest_resources_filter: Result<Vec<super::Address>, String>,
            opt_ins: Result<Option<super::TransactionDetailsOptIns>, String>,
            order: Result<Option<super::StreamTransactionsRequestOrder>, String>,
        }
        impl Default for StreamTransactionsRequest {
            fn default() -> Self {
                Self {
                    accounts_with_manifest_owner_method_calls: Ok(Default::default()),
                    accounts_without_manifest_owner_method_calls: Ok(Default::default()),
                    affected_global_entities_filter: Ok(Default::default()),
                    at_ledger_state: Ok(Default::default()),
                    cursor: Ok(Default::default()),
                    event_global_emitters_filter: Ok(Default::default()),
                    events_filter: Ok(Default::default()),
                    from_ledger_state: Ok(Default::default()),
                    kind_filter: Ok(Default::default()),
                    limit_per_page: Ok(Default::default()),
                    manifest_accounts_deposited_into_filter: Ok(Default::default()),
                    manifest_accounts_withdrawn_from_filter: Ok(Default::default()),
                    manifest_badges_presented_filter: Ok(Default::default()),
                    manifest_class_filter: Ok(Default::default()),
                    manifest_resources_filter: Ok(Default::default()),
                    opt_ins: Ok(Default::default()),
                    order: Ok(Default::default()),
                }
            }
        }
        impl StreamTransactionsRequest {
            pub fn accounts_with_manifest_owner_method_calls<T>(
                mut self,
                value: T,
            ) -> Self
            where
                T: std::convert::TryInto<Vec<super::Address>>,
                T::Error: std::fmt::Display,
            {
                self.accounts_with_manifest_owner_method_calls = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for accounts_with_manifest_owner_method_calls: {}",
                            e
                        )
                    });
                self
            }
            pub fn accounts_without_manifest_owner_method_calls<T>(
                mut self,
                value: T,
            ) -> Self
            where
                T: std::convert::TryInto<Vec<super::Address>>,
                T::Error: std::fmt::Display,
            {
                self.accounts_without_manifest_owner_method_calls = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for accounts_without_manifest_owner_method_calls: {}",
                            e
                        )
                    });
                self
            }
            pub fn affected_global_entities_filter<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Address>>,
                T::Error: std::fmt::Display,
            {
                self.affected_global_entities_filter = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for affected_global_entities_filter: {}",
                            e
                        )
                    });
                self
            }
            pub fn at_ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::LedgerStateSelector>>,
                T::Error: std::fmt::Display,
            {
                self.at_ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for at_ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for cursor: {}", e)
                    });
                self
            }
            pub fn event_global_emitters_filter<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Address>>,
                T::Error: std::fmt::Display,
            {
                self.event_global_emitters_filter = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for event_global_emitters_filter: {}",
                            e
                        )
                    });
                self
            }
            pub fn events_filter<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    Vec<super::StreamTransactionsRequestEventFilterItem>,
                >,
                T::Error: std::fmt::Display,
            {
                self.events_filter = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for events_filter: {}", e
                        )
                    });
                self
            }
            pub fn from_ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::LedgerStateSelector>>,
                T::Error: std::fmt::Display,
            {
                self.from_ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for from_ledger_state: {}",
                            e
                        )
                    });
                self
            }
            pub fn kind_filter<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    Option<super::StreamTransactionsRequestKindFilter>,
                >,
                T::Error: std::fmt::Display,
            {
                self.kind_filter = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for kind_filter: {}", e)
                    });
                self
            }
            pub fn limit_per_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.limit_per_page = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for limit_per_page: {}", e
                        )
                    });
                self
            }
            pub fn manifest_accounts_deposited_into_filter<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Address>>,
                T::Error: std::fmt::Display,
            {
                self.manifest_accounts_deposited_into_filter = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for manifest_accounts_deposited_into_filter: {}",
                            e
                        )
                    });
                self
            }
            pub fn manifest_accounts_withdrawn_from_filter<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Address>>,
                T::Error: std::fmt::Display,
            {
                self.manifest_accounts_withdrawn_from_filter = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for manifest_accounts_withdrawn_from_filter: {}",
                            e
                        )
                    });
                self
            }
            pub fn manifest_badges_presented_filter<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Address>>,
                T::Error: std::fmt::Display,
            {
                self.manifest_badges_presented_filter = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for manifest_badges_presented_filter: {}",
                            e
                        )
                    });
                self
            }
            pub fn manifest_class_filter<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    Option<super::StreamTransactionsRequestManifestClassFilter>,
                >,
                T::Error: std::fmt::Display,
            {
                self.manifest_class_filter = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for manifest_class_filter: {}",
                            e
                        )
                    });
                self
            }
            pub fn manifest_resources_filter<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Address>>,
                T::Error: std::fmt::Display,
            {
                self.manifest_resources_filter = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for manifest_resources_filter: {}",
                            e
                        )
                    });
                self
            }
            pub fn opt_ins<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::TransactionDetailsOptIns>>,
                T::Error: std::fmt::Display,
            {
                self.opt_ins = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for opt_ins: {}", e)
                    });
                self
            }
            pub fn order<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::StreamTransactionsRequestOrder>>,
                T::Error: std::fmt::Display,
            {
                self.order = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for order: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<StreamTransactionsRequest>
        for super::StreamTransactionsRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StreamTransactionsRequest,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    accounts_with_manifest_owner_method_calls: value
                        .accounts_with_manifest_owner_method_calls?,
                    accounts_without_manifest_owner_method_calls: value
                        .accounts_without_manifest_owner_method_calls?,
                    affected_global_entities_filter: value
                        .affected_global_entities_filter?,
                    at_ledger_state: value.at_ledger_state?,
                    cursor: value.cursor?,
                    event_global_emitters_filter: value.event_global_emitters_filter?,
                    events_filter: value.events_filter?,
                    from_ledger_state: value.from_ledger_state?,
                    kind_filter: value.kind_filter?,
                    limit_per_page: value.limit_per_page?,
                    manifest_accounts_deposited_into_filter: value
                        .manifest_accounts_deposited_into_filter?,
                    manifest_accounts_withdrawn_from_filter: value
                        .manifest_accounts_withdrawn_from_filter?,
                    manifest_badges_presented_filter: value
                        .manifest_badges_presented_filter?,
                    manifest_class_filter: value.manifest_class_filter?,
                    manifest_resources_filter: value.manifest_resources_filter?,
                    opt_ins: value.opt_ins?,
                    order: value.order?,
                })
            }
        }
        impl From<super::StreamTransactionsRequest> for StreamTransactionsRequest {
            fn from(value: super::StreamTransactionsRequest) -> Self {
                Self {
                    accounts_with_manifest_owner_method_calls: Ok(
                        value.accounts_with_manifest_owner_method_calls,
                    ),
                    accounts_without_manifest_owner_method_calls: Ok(
                        value.accounts_without_manifest_owner_method_calls,
                    ),
                    affected_global_entities_filter: Ok(
                        value.affected_global_entities_filter,
                    ),
                    at_ledger_state: Ok(value.at_ledger_state),
                    cursor: Ok(value.cursor),
                    event_global_emitters_filter: Ok(value.event_global_emitters_filter),
                    events_filter: Ok(value.events_filter),
                    from_ledger_state: Ok(value.from_ledger_state),
                    kind_filter: Ok(value.kind_filter),
                    limit_per_page: Ok(value.limit_per_page),
                    manifest_accounts_deposited_into_filter: Ok(
                        value.manifest_accounts_deposited_into_filter,
                    ),
                    manifest_accounts_withdrawn_from_filter: Ok(
                        value.manifest_accounts_withdrawn_from_filter,
                    ),
                    manifest_badges_presented_filter: Ok(
                        value.manifest_badges_presented_filter,
                    ),
                    manifest_class_filter: Ok(value.manifest_class_filter),
                    manifest_resources_filter: Ok(value.manifest_resources_filter),
                    opt_ins: Ok(value.opt_ins),
                    order: Ok(value.order),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StreamTransactionsRequestEventFilterItem {
            emitter_address: Result<Option<super::Address>, String>,
            event: Result<super::StreamTransactionsRequestEventFilterItemEvent, String>,
            resource_address: Result<Option<super::Address>, String>,
        }
        impl Default for StreamTransactionsRequestEventFilterItem {
            fn default() -> Self {
                Self {
                    emitter_address: Ok(Default::default()),
                    event: Err("no value supplied for event".to_string()),
                    resource_address: Ok(Default::default()),
                }
            }
        }
        impl StreamTransactionsRequestEventFilterItem {
            pub fn emitter_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::Address>>,
                T::Error: std::fmt::Display,
            {
                self.emitter_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for emitter_address: {}", e
                        )
                    });
                self
            }
            pub fn event<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::StreamTransactionsRequestEventFilterItemEvent,
                >,
                T::Error: std::fmt::Display,
            {
                self.event = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for event: {}", e)
                    });
                self
            }
            pub fn resource_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::Address>>,
                T::Error: std::fmt::Display,
            {
                self.resource_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_address: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<StreamTransactionsRequestEventFilterItem>
        for super::StreamTransactionsRequestEventFilterItem {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StreamTransactionsRequestEventFilterItem,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    emitter_address: value.emitter_address?,
                    event: value.event?,
                    resource_address: value.resource_address?,
                })
            }
        }
        impl From<super::StreamTransactionsRequestEventFilterItem>
        for StreamTransactionsRequestEventFilterItem {
            fn from(value: super::StreamTransactionsRequestEventFilterItem) -> Self {
                Self {
                    emitter_address: Ok(value.emitter_address),
                    event: Ok(value.event),
                    resource_address: Ok(value.resource_address),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StreamTransactionsRequestManifestClassFilter {
            class: Result<super::ManifestClass, String>,
            match_only_most_specific: Result<bool, String>,
        }
        impl Default for StreamTransactionsRequestManifestClassFilter {
            fn default() -> Self {
                Self {
                    class: Err("no value supplied for class".to_string()),
                    match_only_most_specific: Ok(Default::default()),
                }
            }
        }
        impl StreamTransactionsRequestManifestClassFilter {
            pub fn class<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ManifestClass>,
                T::Error: std::fmt::Display,
            {
                self.class = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for class: {}", e)
                    });
                self
            }
            pub fn match_only_most_specific<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.match_only_most_specific = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for match_only_most_specific: {}",
                            e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<StreamTransactionsRequestManifestClassFilter>
        for super::StreamTransactionsRequestManifestClassFilter {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StreamTransactionsRequestManifestClassFilter,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    class: value.class?,
                    match_only_most_specific: value.match_only_most_specific?,
                })
            }
        }
        impl From<super::StreamTransactionsRequestManifestClassFilter>
        for StreamTransactionsRequestManifestClassFilter {
            fn from(value: super::StreamTransactionsRequestManifestClassFilter) -> Self {
                Self {
                    class: Ok(value.class),
                    match_only_most_specific: Ok(value.match_only_most_specific),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StreamTransactionsResponse {
            items: Result<Vec<super::CommittedTransactionInfo>, String>,
            ledger_state: Result<super::LedgerState, String>,
            next_cursor: Result<Option<String>, String>,
        }
        impl Default for StreamTransactionsResponse {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    ledger_state: Err("no value supplied for ledger_state".to_string()),
                    next_cursor: Ok(Default::default()),
                }
            }
        }
        impl StreamTransactionsResponse {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::CommittedTransactionInfo>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {}", e)
                    });
                self
            }
            pub fn ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::LedgerState>,
                T::Error: std::fmt::Display,
            {
                self.ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn next_cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for next_cursor: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<StreamTransactionsResponse>
        for super::StreamTransactionsResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StreamTransactionsResponse,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    ledger_state: value.ledger_state?,
                    next_cursor: value.next_cursor?,
                })
            }
        }
        impl From<super::StreamTransactionsResponse> for StreamTransactionsResponse {
            fn from(value: super::StreamTransactionsResponse) -> Self {
                Self {
                    items: Ok(value.items),
                    ledger_state: Ok(value.ledger_state),
                    next_cursor: Ok(value.next_cursor),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TransactionAccountDepositPreValidationAuthorizedDepositorBadgeBase {
            badge_type: Result<super::AccountAuthorizedDepositorBadgeType, String>,
            resource_address: Result<super::Address, String>,
        }
        impl Default
        for TransactionAccountDepositPreValidationAuthorizedDepositorBadgeBase {
            fn default() -> Self {
                Self {
                    badge_type: Err("no value supplied for badge_type".to_string()),
                    resource_address: Err(
                        "no value supplied for resource_address".to_string(),
                    ),
                }
            }
        }
        impl TransactionAccountDepositPreValidationAuthorizedDepositorBadgeBase {
            pub fn badge_type<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::AccountAuthorizedDepositorBadgeType>,
                T::Error: std::fmt::Display,
            {
                self.badge_type = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for badge_type: {}", e)
                    });
                self
            }
            pub fn resource_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.resource_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_address: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<
            TransactionAccountDepositPreValidationAuthorizedDepositorBadgeBase,
        > for super::TransactionAccountDepositPreValidationAuthorizedDepositorBadgeBase {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TransactionAccountDepositPreValidationAuthorizedDepositorBadgeBase,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    badge_type: value.badge_type?,
                    resource_address: value.resource_address?,
                })
            }
        }
        impl From<
            super::TransactionAccountDepositPreValidationAuthorizedDepositorBadgeBase,
        > for TransactionAccountDepositPreValidationAuthorizedDepositorBadgeBase {
            fn from(
                value: super::TransactionAccountDepositPreValidationAuthorizedDepositorBadgeBase,
            ) -> Self {
                Self {
                    badge_type: Ok(value.badge_type),
                    resource_address: Ok(value.resource_address),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TransactionBalanceChangesInner {
            fungible_balance_changes: Result<
                Vec<super::TransactionFungibleBalanceChanges>,
                String,
            >,
            fungible_fee_balance_changes: Result<
                Vec<super::TransactionFungibleFeeBalanceChanges>,
                String,
            >,
            non_fungible_balance_changes: Result<
                Vec<super::TransactionNonFungibleBalanceChanges>,
                String,
            >,
        }
        impl Default for TransactionBalanceChangesInner {
            fn default() -> Self {
                Self {
                    fungible_balance_changes: Err(
                        "no value supplied for fungible_balance_changes".to_string(),
                    ),
                    fungible_fee_balance_changes: Err(
                        "no value supplied for fungible_fee_balance_changes".to_string(),
                    ),
                    non_fungible_balance_changes: Err(
                        "no value supplied for non_fungible_balance_changes".to_string(),
                    ),
                }
            }
        }
        impl TransactionBalanceChangesInner {
            pub fn fungible_balance_changes<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::TransactionFungibleBalanceChanges>>,
                T::Error: std::fmt::Display,
            {
                self.fungible_balance_changes = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for fungible_balance_changes: {}",
                            e
                        )
                    });
                self
            }
            pub fn fungible_fee_balance_changes<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    Vec<super::TransactionFungibleFeeBalanceChanges>,
                >,
                T::Error: std::fmt::Display,
            {
                self.fungible_fee_balance_changes = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for fungible_fee_balance_changes: {}",
                            e
                        )
                    });
                self
            }
            pub fn non_fungible_balance_changes<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    Vec<super::TransactionNonFungibleBalanceChanges>,
                >,
                T::Error: std::fmt::Display,
            {
                self.non_fungible_balance_changes = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for non_fungible_balance_changes: {}",
                            e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<TransactionBalanceChangesInner>
        for super::TransactionBalanceChangesInner {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TransactionBalanceChangesInner,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    fungible_balance_changes: value.fungible_balance_changes?,
                    fungible_fee_balance_changes: value.fungible_fee_balance_changes?,
                    non_fungible_balance_changes: value.non_fungible_balance_changes?,
                })
            }
        }
        impl From<super::TransactionBalanceChangesInner>
        for TransactionBalanceChangesInner {
            fn from(value: super::TransactionBalanceChangesInner) -> Self {
                Self {
                    fungible_balance_changes: Ok(value.fungible_balance_changes),
                    fungible_fee_balance_changes: Ok(value.fungible_fee_balance_changes),
                    non_fungible_balance_changes: Ok(value.non_fungible_balance_changes),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TransactionCommittedDetailsRequest {
            at_ledger_state: Result<Option<super::LedgerStateSelector>, String>,
            intent_hash: Result<super::HashBech32mString, String>,
            opt_ins: Result<Option<super::TransactionDetailsOptIns>, String>,
        }
        impl Default for TransactionCommittedDetailsRequest {
            fn default() -> Self {
                Self {
                    at_ledger_state: Ok(Default::default()),
                    intent_hash: Err("no value supplied for intent_hash".to_string()),
                    opt_ins: Ok(Default::default()),
                }
            }
        }
        impl TransactionCommittedDetailsRequest {
            pub fn at_ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::LedgerStateSelector>>,
                T::Error: std::fmt::Display,
            {
                self.at_ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for at_ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn intent_hash<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::HashBech32mString>,
                T::Error: std::fmt::Display,
            {
                self.intent_hash = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for intent_hash: {}", e)
                    });
                self
            }
            pub fn opt_ins<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::TransactionDetailsOptIns>>,
                T::Error: std::fmt::Display,
            {
                self.opt_ins = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for opt_ins: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<TransactionCommittedDetailsRequest>
        for super::TransactionCommittedDetailsRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TransactionCommittedDetailsRequest,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    at_ledger_state: value.at_ledger_state?,
                    intent_hash: value.intent_hash?,
                    opt_ins: value.opt_ins?,
                })
            }
        }
        impl From<super::TransactionCommittedDetailsRequest>
        for TransactionCommittedDetailsRequest {
            fn from(value: super::TransactionCommittedDetailsRequest) -> Self {
                Self {
                    at_ledger_state: Ok(value.at_ledger_state),
                    intent_hash: Ok(value.intent_hash),
                    opt_ins: Ok(value.opt_ins),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TransactionCommittedDetailsResponse {
            ledger_state: Result<super::LedgerState, String>,
            transaction: Result<super::CommittedTransactionInfo, String>,
        }
        impl Default for TransactionCommittedDetailsResponse {
            fn default() -> Self {
                Self {
                    ledger_state: Err("no value supplied for ledger_state".to_string()),
                    transaction: Err("no value supplied for transaction".to_string()),
                }
            }
        }
        impl TransactionCommittedDetailsResponse {
            pub fn ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::LedgerState>,
                T::Error: std::fmt::Display,
            {
                self.ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn transaction<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::CommittedTransactionInfo>,
                T::Error: std::fmt::Display,
            {
                self.transaction = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for transaction: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<TransactionCommittedDetailsResponse>
        for super::TransactionCommittedDetailsResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TransactionCommittedDetailsResponse,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    ledger_state: value.ledger_state?,
                    transaction: value.transaction?,
                })
            }
        }
        impl From<super::TransactionCommittedDetailsResponse>
        for TransactionCommittedDetailsResponse {
            fn from(value: super::TransactionCommittedDetailsResponse) -> Self {
                Self {
                    ledger_state: Ok(value.ledger_state),
                    transaction: Ok(value.transaction),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TransactionDetailsOptIns {
            affected_global_entities: Result<bool, String>,
            balance_changes: Result<bool, String>,
            manifest_instructions: Result<bool, String>,
            raw_hex: Result<bool, String>,
            receipt_costing_parameters: Result<bool, String>,
            receipt_events: Result<bool, String>,
            receipt_fee_destination: Result<bool, String>,
            receipt_fee_source: Result<bool, String>,
            receipt_fee_summary: Result<bool, String>,
            receipt_output: Result<bool, String>,
            receipt_state_changes: Result<bool, String>,
        }
        impl Default for TransactionDetailsOptIns {
            fn default() -> Self {
                Self {
                    affected_global_entities: Ok(Default::default()),
                    balance_changes: Ok(Default::default()),
                    manifest_instructions: Ok(Default::default()),
                    raw_hex: Ok(Default::default()),
                    receipt_costing_parameters: Ok(Default::default()),
                    receipt_events: Ok(Default::default()),
                    receipt_fee_destination: Ok(Default::default()),
                    receipt_fee_source: Ok(Default::default()),
                    receipt_fee_summary: Ok(Default::default()),
                    receipt_output: Ok(super::defaults::default_bool::<true>()),
                    receipt_state_changes: Ok(Default::default()),
                }
            }
        }
        impl TransactionDetailsOptIns {
            pub fn affected_global_entities<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.affected_global_entities = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for affected_global_entities: {}",
                            e
                        )
                    });
                self
            }
            pub fn balance_changes<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.balance_changes = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for balance_changes: {}", e
                        )
                    });
                self
            }
            pub fn manifest_instructions<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.manifest_instructions = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for manifest_instructions: {}",
                            e
                        )
                    });
                self
            }
            pub fn raw_hex<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.raw_hex = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for raw_hex: {}", e)
                    });
                self
            }
            pub fn receipt_costing_parameters<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.receipt_costing_parameters = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for receipt_costing_parameters: {}",
                            e
                        )
                    });
                self
            }
            pub fn receipt_events<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.receipt_events = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for receipt_events: {}", e
                        )
                    });
                self
            }
            pub fn receipt_fee_destination<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.receipt_fee_destination = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for receipt_fee_destination: {}",
                            e
                        )
                    });
                self
            }
            pub fn receipt_fee_source<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.receipt_fee_source = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for receipt_fee_source: {}",
                            e
                        )
                    });
                self
            }
            pub fn receipt_fee_summary<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.receipt_fee_summary = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for receipt_fee_summary: {}",
                            e
                        )
                    });
                self
            }
            pub fn receipt_output<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.receipt_output = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for receipt_output: {}", e
                        )
                    });
                self
            }
            pub fn receipt_state_changes<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.receipt_state_changes = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for receipt_state_changes: {}",
                            e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<TransactionDetailsOptIns>
        for super::TransactionDetailsOptIns {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TransactionDetailsOptIns,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    affected_global_entities: value.affected_global_entities?,
                    balance_changes: value.balance_changes?,
                    manifest_instructions: value.manifest_instructions?,
                    raw_hex: value.raw_hex?,
                    receipt_costing_parameters: value.receipt_costing_parameters?,
                    receipt_events: value.receipt_events?,
                    receipt_fee_destination: value.receipt_fee_destination?,
                    receipt_fee_source: value.receipt_fee_source?,
                    receipt_fee_summary: value.receipt_fee_summary?,
                    receipt_output: value.receipt_output?,
                    receipt_state_changes: value.receipt_state_changes?,
                })
            }
        }
        impl From<super::TransactionDetailsOptIns> for TransactionDetailsOptIns {
            fn from(value: super::TransactionDetailsOptIns) -> Self {
                Self {
                    affected_global_entities: Ok(value.affected_global_entities),
                    balance_changes: Ok(value.balance_changes),
                    manifest_instructions: Ok(value.manifest_instructions),
                    raw_hex: Ok(value.raw_hex),
                    receipt_costing_parameters: Ok(value.receipt_costing_parameters),
                    receipt_events: Ok(value.receipt_events),
                    receipt_fee_destination: Ok(value.receipt_fee_destination),
                    receipt_fee_source: Ok(value.receipt_fee_source),
                    receipt_fee_summary: Ok(value.receipt_fee_summary),
                    receipt_output: Ok(value.receipt_output),
                    receipt_state_changes: Ok(value.receipt_state_changes),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TransactionFungibleBalanceChanges {
            balance_change: Result<String, String>,
            entity_address: Result<super::Address, String>,
            resource_address: Result<super::Address, String>,
        }
        impl Default for TransactionFungibleBalanceChanges {
            fn default() -> Self {
                Self {
                    balance_change: Err(
                        "no value supplied for balance_change".to_string(),
                    ),
                    entity_address: Err(
                        "no value supplied for entity_address".to_string(),
                    ),
                    resource_address: Err(
                        "no value supplied for resource_address".to_string(),
                    ),
                }
            }
        }
        impl TransactionFungibleBalanceChanges {
            pub fn balance_change<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.balance_change = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for balance_change: {}", e
                        )
                    });
                self
            }
            pub fn entity_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.entity_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for entity_address: {}", e
                        )
                    });
                self
            }
            pub fn resource_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.resource_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_address: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<TransactionFungibleBalanceChanges>
        for super::TransactionFungibleBalanceChanges {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TransactionFungibleBalanceChanges,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    balance_change: value.balance_change?,
                    entity_address: value.entity_address?,
                    resource_address: value.resource_address?,
                })
            }
        }
        impl From<super::TransactionFungibleBalanceChanges>
        for TransactionFungibleBalanceChanges {
            fn from(value: super::TransactionFungibleBalanceChanges) -> Self {
                Self {
                    balance_change: Ok(value.balance_change),
                    entity_address: Ok(value.entity_address),
                    resource_address: Ok(value.resource_address),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TransactionFungibleFeeBalanceChanges {
            balance_change: Result<String, String>,
            entity_address: Result<super::Address, String>,
            resource_address: Result<super::Address, String>,
            type_: Result<super::TransactionFungibleFeeBalanceChangeType, String>,
        }
        impl Default for TransactionFungibleFeeBalanceChanges {
            fn default() -> Self {
                Self {
                    balance_change: Err(
                        "no value supplied for balance_change".to_string(),
                    ),
                    entity_address: Err(
                        "no value supplied for entity_address".to_string(),
                    ),
                    resource_address: Err(
                        "no value supplied for resource_address".to_string(),
                    ),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl TransactionFungibleFeeBalanceChanges {
            pub fn balance_change<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.balance_change = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for balance_change: {}", e
                        )
                    });
                self
            }
            pub fn entity_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.entity_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for entity_address: {}", e
                        )
                    });
                self
            }
            pub fn resource_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.resource_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_address: {}", e
                        )
                    });
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::TransactionFungibleFeeBalanceChangeType>,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<TransactionFungibleFeeBalanceChanges>
        for super::TransactionFungibleFeeBalanceChanges {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TransactionFungibleFeeBalanceChanges,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    balance_change: value.balance_change?,
                    entity_address: value.entity_address?,
                    resource_address: value.resource_address?,
                    type_: value.type_?,
                })
            }
        }
        impl From<super::TransactionFungibleFeeBalanceChanges>
        for TransactionFungibleFeeBalanceChanges {
            fn from(value: super::TransactionFungibleFeeBalanceChanges) -> Self {
                Self {
                    balance_change: Ok(value.balance_change),
                    entity_address: Ok(value.entity_address),
                    resource_address: Ok(value.resource_address),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TransactionNonFungibleBalanceChanges {
            added: Result<Vec<super::NonFungibleId>, String>,
            entity_address: Result<super::Address, String>,
            removed: Result<Vec<super::NonFungibleId>, String>,
            resource_address: Result<super::Address, String>,
        }
        impl Default for TransactionNonFungibleBalanceChanges {
            fn default() -> Self {
                Self {
                    added: Err("no value supplied for added".to_string()),
                    entity_address: Err(
                        "no value supplied for entity_address".to_string(),
                    ),
                    removed: Err("no value supplied for removed".to_string()),
                    resource_address: Err(
                        "no value supplied for resource_address".to_string(),
                    ),
                }
            }
        }
        impl TransactionNonFungibleBalanceChanges {
            pub fn added<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::NonFungibleId>>,
                T::Error: std::fmt::Display,
            {
                self.added = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for added: {}", e)
                    });
                self
            }
            pub fn entity_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.entity_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for entity_address: {}", e
                        )
                    });
                self
            }
            pub fn removed<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::NonFungibleId>>,
                T::Error: std::fmt::Display,
            {
                self.removed = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for removed: {}", e)
                    });
                self
            }
            pub fn resource_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.resource_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_address: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<TransactionNonFungibleBalanceChanges>
        for super::TransactionNonFungibleBalanceChanges {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TransactionNonFungibleBalanceChanges,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    added: value.added?,
                    entity_address: value.entity_address?,
                    removed: value.removed?,
                    resource_address: value.resource_address?,
                })
            }
        }
        impl From<super::TransactionNonFungibleBalanceChanges>
        for TransactionNonFungibleBalanceChanges {
            fn from(value: super::TransactionNonFungibleBalanceChanges) -> Self {
                Self {
                    added: Ok(value.added),
                    entity_address: Ok(value.entity_address),
                    removed: Ok(value.removed),
                    resource_address: Ok(value.resource_address),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TransactionNotFoundError {
            intent_hash: Result<super::HashBech32mString, String>,
            type_: Result<super::TransactionNotFoundErrorType, String>,
        }
        impl Default for TransactionNotFoundError {
            fn default() -> Self {
                Self {
                    intent_hash: Err("no value supplied for intent_hash".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl TransactionNotFoundError {
            pub fn intent_hash<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::HashBech32mString>,
                T::Error: std::fmt::Display,
            {
                self.intent_hash = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for intent_hash: {}", e)
                    });
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::TransactionNotFoundErrorType>,
                T::Error: std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for type_: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<TransactionNotFoundError>
        for super::TransactionNotFoundError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TransactionNotFoundError,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    intent_hash: value.intent_hash?,
                    type_: value.type_?,
                })
            }
        }
        impl From<super::TransactionNotFoundError> for TransactionNotFoundError {
            fn from(value: super::TransactionNotFoundError) -> Self {
                Self {
                    intent_hash: Ok(value.intent_hash),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TransactionPreviewOptIns {
            radix_engine_toolkit_receipt: Result<bool, String>,
        }
        impl Default for TransactionPreviewOptIns {
            fn default() -> Self {
                Self {
                    radix_engine_toolkit_receipt: Ok(Default::default()),
                }
            }
        }
        impl TransactionPreviewOptIns {
            pub fn radix_engine_toolkit_receipt<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.radix_engine_toolkit_receipt = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for radix_engine_toolkit_receipt: {}",
                            e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<TransactionPreviewOptIns>
        for super::TransactionPreviewOptIns {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TransactionPreviewOptIns,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    radix_engine_toolkit_receipt: value.radix_engine_toolkit_receipt?,
                })
            }
        }
        impl From<super::TransactionPreviewOptIns> for TransactionPreviewOptIns {
            fn from(value: super::TransactionPreviewOptIns) -> Self {
                Self {
                    radix_engine_toolkit_receipt: Ok(value.radix_engine_toolkit_receipt),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TransactionPreviewRequest {
            blobs_hex: Result<Vec<String>, String>,
            end_epoch_exclusive: Result<Option<i64>, String>,
            flags: Result<Option<super::PreviewFlags>, String>,
            manifest: Result<String, String>,
            message: Result<::serde_json::Map<String, ::serde_json::Value>, String>,
            nonce: Result<Option<i64>, String>,
            notary_is_signatory: Result<Option<bool>, String>,
            notary_public_key: Result<Option<super::PublicKey>, String>,
            opt_ins: Result<Option<super::TransactionPreviewOptIns>, String>,
            signer_public_keys: Result<Vec<super::PublicKey>, String>,
            start_epoch_inclusive: Result<Option<i64>, String>,
            tip_percentage: Result<Option<u16>, String>,
        }
        impl Default for TransactionPreviewRequest {
            fn default() -> Self {
                Self {
                    blobs_hex: Ok(Default::default()),
                    end_epoch_exclusive: Ok(Default::default()),
                    flags: Ok(Default::default()),
                    manifest: Err("no value supplied for manifest".to_string()),
                    message: Ok(Default::default()),
                    nonce: Ok(Default::default()),
                    notary_is_signatory: Ok(Default::default()),
                    notary_public_key: Ok(Default::default()),
                    opt_ins: Ok(Default::default()),
                    signer_public_keys: Ok(Default::default()),
                    start_epoch_inclusive: Ok(Default::default()),
                    tip_percentage: Ok(Default::default()),
                }
            }
        }
        impl TransactionPreviewRequest {
            pub fn blobs_hex<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<String>>,
                T::Error: std::fmt::Display,
            {
                self.blobs_hex = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for blobs_hex: {}", e)
                    });
                self
            }
            pub fn end_epoch_exclusive<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.end_epoch_exclusive = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for end_epoch_exclusive: {}",
                            e
                        )
                    });
                self
            }
            pub fn flags<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::PreviewFlags>>,
                T::Error: std::fmt::Display,
            {
                self.flags = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for flags: {}", e)
                    });
                self
            }
            pub fn manifest<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.manifest = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for manifest: {}", e)
                    });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<::serde_json::Map<String, ::serde_json::Value>>,
                T::Error: std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for message: {}", e)
                    });
                self
            }
            pub fn nonce<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.nonce = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for nonce: {}", e)
                    });
                self
            }
            pub fn notary_is_signatory<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<bool>>,
                T::Error: std::fmt::Display,
            {
                self.notary_is_signatory = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for notary_is_signatory: {}",
                            e
                        )
                    });
                self
            }
            pub fn notary_public_key<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::PublicKey>>,
                T::Error: std::fmt::Display,
            {
                self.notary_public_key = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for notary_public_key: {}",
                            e
                        )
                    });
                self
            }
            pub fn opt_ins<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::TransactionPreviewOptIns>>,
                T::Error: std::fmt::Display,
            {
                self.opt_ins = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for opt_ins: {}", e)
                    });
                self
            }
            pub fn signer_public_keys<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::PublicKey>>,
                T::Error: std::fmt::Display,
            {
                self.signer_public_keys = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for signer_public_keys: {}",
                            e
                        )
                    });
                self
            }
            pub fn start_epoch_inclusive<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.start_epoch_inclusive = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for start_epoch_inclusive: {}",
                            e
                        )
                    });
                self
            }
            pub fn tip_percentage<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<u16>>,
                T::Error: std::fmt::Display,
            {
                self.tip_percentage = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for tip_percentage: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<TransactionPreviewRequest>
        for super::TransactionPreviewRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TransactionPreviewRequest,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    blobs_hex: value.blobs_hex?,
                    end_epoch_exclusive: value.end_epoch_exclusive?,
                    flags: value.flags?,
                    manifest: value.manifest?,
                    message: value.message?,
                    nonce: value.nonce?,
                    notary_is_signatory: value.notary_is_signatory?,
                    notary_public_key: value.notary_public_key?,
                    opt_ins: value.opt_ins?,
                    signer_public_keys: value.signer_public_keys?,
                    start_epoch_inclusive: value.start_epoch_inclusive?,
                    tip_percentage: value.tip_percentage?,
                })
            }
        }
        impl From<super::TransactionPreviewRequest> for TransactionPreviewRequest {
            fn from(value: super::TransactionPreviewRequest) -> Self {
                Self {
                    blobs_hex: Ok(value.blobs_hex),
                    end_epoch_exclusive: Ok(value.end_epoch_exclusive),
                    flags: Ok(value.flags),
                    manifest: Ok(value.manifest),
                    message: Ok(value.message),
                    nonce: Ok(value.nonce),
                    notary_is_signatory: Ok(value.notary_is_signatory),
                    notary_public_key: Ok(value.notary_public_key),
                    opt_ins: Ok(value.opt_ins),
                    signer_public_keys: Ok(value.signer_public_keys),
                    start_epoch_inclusive: Ok(value.start_epoch_inclusive),
                    tip_percentage: Ok(value.tip_percentage),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TransactionPreviewResponse {
            encoded_receipt: Result<super::HexString, String>,
            logs: Result<Vec<super::TransactionPreviewResponseLogsItem>, String>,
            radix_engine_toolkit_receipt: Result<
                ::serde_json::Map<String, ::serde_json::Value>,
                String,
            >,
            receipt: Result<::serde_json::Map<String, ::serde_json::Value>, String>,
            resource_changes: Result<
                Vec<::serde_json::Map<String, ::serde_json::Value>>,
                String,
            >,
        }
        impl Default for TransactionPreviewResponse {
            fn default() -> Self {
                Self {
                    encoded_receipt: Err(
                        "no value supplied for encoded_receipt".to_string(),
                    ),
                    logs: Err("no value supplied for logs".to_string()),
                    radix_engine_toolkit_receipt: Ok(Default::default()),
                    receipt: Err("no value supplied for receipt".to_string()),
                    resource_changes: Err(
                        "no value supplied for resource_changes".to_string(),
                    ),
                }
            }
        }
        impl TransactionPreviewResponse {
            pub fn encoded_receipt<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::HexString>,
                T::Error: std::fmt::Display,
            {
                self.encoded_receipt = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for encoded_receipt: {}", e
                        )
                    });
                self
            }
            pub fn logs<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::TransactionPreviewResponseLogsItem>>,
                T::Error: std::fmt::Display,
            {
                self.logs = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for logs: {}", e)
                    });
                self
            }
            pub fn radix_engine_toolkit_receipt<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<::serde_json::Map<String, ::serde_json::Value>>,
                T::Error: std::fmt::Display,
            {
                self.radix_engine_toolkit_receipt = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for radix_engine_toolkit_receipt: {}",
                            e
                        )
                    });
                self
            }
            pub fn receipt<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<::serde_json::Map<String, ::serde_json::Value>>,
                T::Error: std::fmt::Display,
            {
                self.receipt = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for receipt: {}", e)
                    });
                self
            }
            pub fn resource_changes<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    Vec<::serde_json::Map<String, ::serde_json::Value>>,
                >,
                T::Error: std::fmt::Display,
            {
                self.resource_changes = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for resource_changes: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<TransactionPreviewResponse>
        for super::TransactionPreviewResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TransactionPreviewResponse,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    encoded_receipt: value.encoded_receipt?,
                    logs: value.logs?,
                    radix_engine_toolkit_receipt: value.radix_engine_toolkit_receipt?,
                    receipt: value.receipt?,
                    resource_changes: value.resource_changes?,
                })
            }
        }
        impl From<super::TransactionPreviewResponse> for TransactionPreviewResponse {
            fn from(value: super::TransactionPreviewResponse) -> Self {
                Self {
                    encoded_receipt: Ok(value.encoded_receipt),
                    logs: Ok(value.logs),
                    radix_engine_toolkit_receipt: Ok(value.radix_engine_toolkit_receipt),
                    receipt: Ok(value.receipt),
                    resource_changes: Ok(value.resource_changes),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TransactionPreviewResponseLogsItem {
            level: Result<String, String>,
            message: Result<String, String>,
        }
        impl Default for TransactionPreviewResponseLogsItem {
            fn default() -> Self {
                Self {
                    level: Err("no value supplied for level".to_string()),
                    message: Err("no value supplied for message".to_string()),
                }
            }
        }
        impl TransactionPreviewResponseLogsItem {
            pub fn level<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.level = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for level: {}", e)
                    });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for message: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<TransactionPreviewResponseLogsItem>
        for super::TransactionPreviewResponseLogsItem {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TransactionPreviewResponseLogsItem,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    level: value.level?,
                    message: value.message?,
                })
            }
        }
        impl From<super::TransactionPreviewResponseLogsItem>
        for TransactionPreviewResponseLogsItem {
            fn from(value: super::TransactionPreviewResponseLogsItem) -> Self {
                Self {
                    level: Ok(value.level),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TransactionPreviewV2OptIns {
            core_api_receipt: Result<bool, String>,
            logs: Result<bool, String>,
            radix_engine_toolkit_receipt: Result<bool, String>,
        }
        impl Default for TransactionPreviewV2OptIns {
            fn default() -> Self {
                Self {
                    core_api_receipt: Ok(Default::default()),
                    logs: Ok(Default::default()),
                    radix_engine_toolkit_receipt: Ok(Default::default()),
                }
            }
        }
        impl TransactionPreviewV2OptIns {
            pub fn core_api_receipt<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.core_api_receipt = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for core_api_receipt: {}", e
                        )
                    });
                self
            }
            pub fn logs<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.logs = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for logs: {}", e)
                    });
                self
            }
            pub fn radix_engine_toolkit_receipt<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.radix_engine_toolkit_receipt = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for radix_engine_toolkit_receipt: {}",
                            e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<TransactionPreviewV2OptIns>
        for super::TransactionPreviewV2OptIns {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TransactionPreviewV2OptIns,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    core_api_receipt: value.core_api_receipt?,
                    logs: value.logs?,
                    radix_engine_toolkit_receipt: value.radix_engine_toolkit_receipt?,
                })
            }
        }
        impl From<super::TransactionPreviewV2OptIns> for TransactionPreviewV2OptIns {
            fn from(value: super::TransactionPreviewV2OptIns) -> Self {
                Self {
                    core_api_receipt: Ok(value.core_api_receipt),
                    logs: Ok(value.logs),
                    radix_engine_toolkit_receipt: Ok(value.radix_engine_toolkit_receipt),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TransactionPreviewV2Request {
            flags: Result<Option<super::PreviewFlags>, String>,
            opt_ins: Result<Option<super::TransactionPreviewV2OptIns>, String>,
            preview_transaction: Result<super::PreviewTransaction, String>,
        }
        impl Default for TransactionPreviewV2Request {
            fn default() -> Self {
                Self {
                    flags: Ok(Default::default()),
                    opt_ins: Ok(Default::default()),
                    preview_transaction: Err(
                        "no value supplied for preview_transaction".to_string(),
                    ),
                }
            }
        }
        impl TransactionPreviewV2Request {
            pub fn flags<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::PreviewFlags>>,
                T::Error: std::fmt::Display,
            {
                self.flags = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for flags: {}", e)
                    });
                self
            }
            pub fn opt_ins<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::TransactionPreviewV2OptIns>>,
                T::Error: std::fmt::Display,
            {
                self.opt_ins = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for opt_ins: {}", e)
                    });
                self
            }
            pub fn preview_transaction<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::PreviewTransaction>,
                T::Error: std::fmt::Display,
            {
                self.preview_transaction = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for preview_transaction: {}",
                            e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<TransactionPreviewV2Request>
        for super::TransactionPreviewV2Request {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TransactionPreviewV2Request,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    flags: value.flags?,
                    opt_ins: value.opt_ins?,
                    preview_transaction: value.preview_transaction?,
                })
            }
        }
        impl From<super::TransactionPreviewV2Request> for TransactionPreviewV2Request {
            fn from(value: super::TransactionPreviewV2Request) -> Self {
                Self {
                    flags: Ok(value.flags),
                    opt_ins: Ok(value.opt_ins),
                    preview_transaction: Ok(value.preview_transaction),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TransactionPreviewV2Response {
            at_ledger_state_version: Result<i64, String>,
            logs: Result<Vec<super::TransactionPreviewV2ResponseLogsItem>, String>,
            radix_engine_toolkit_receipt: Result<
                ::serde_json::Map<String, ::serde_json::Value>,
                String,
            >,
            receipt: Result<::serde_json::Map<String, ::serde_json::Value>, String>,
        }
        impl Default for TransactionPreviewV2Response {
            fn default() -> Self {
                Self {
                    at_ledger_state_version: Err(
                        "no value supplied for at_ledger_state_version".to_string(),
                    ),
                    logs: Ok(Default::default()),
                    radix_engine_toolkit_receipt: Ok(Default::default()),
                    receipt: Ok(Default::default()),
                }
            }
        }
        impl TransactionPreviewV2Response {
            pub fn at_ledger_state_version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<i64>,
                T::Error: std::fmt::Display,
            {
                self.at_ledger_state_version = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for at_ledger_state_version: {}",
                            e
                        )
                    });
                self
            }
            pub fn logs<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    Vec<super::TransactionPreviewV2ResponseLogsItem>,
                >,
                T::Error: std::fmt::Display,
            {
                self.logs = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for logs: {}", e)
                    });
                self
            }
            pub fn radix_engine_toolkit_receipt<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<::serde_json::Map<String, ::serde_json::Value>>,
                T::Error: std::fmt::Display,
            {
                self.radix_engine_toolkit_receipt = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for radix_engine_toolkit_receipt: {}",
                            e
                        )
                    });
                self
            }
            pub fn receipt<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<::serde_json::Map<String, ::serde_json::Value>>,
                T::Error: std::fmt::Display,
            {
                self.receipt = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for receipt: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<TransactionPreviewV2Response>
        for super::TransactionPreviewV2Response {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TransactionPreviewV2Response,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    at_ledger_state_version: value.at_ledger_state_version?,
                    logs: value.logs?,
                    radix_engine_toolkit_receipt: value.radix_engine_toolkit_receipt?,
                    receipt: value.receipt?,
                })
            }
        }
        impl From<super::TransactionPreviewV2Response> for TransactionPreviewV2Response {
            fn from(value: super::TransactionPreviewV2Response) -> Self {
                Self {
                    at_ledger_state_version: Ok(value.at_ledger_state_version),
                    logs: Ok(value.logs),
                    radix_engine_toolkit_receipt: Ok(value.radix_engine_toolkit_receipt),
                    receipt: Ok(value.receipt),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TransactionPreviewV2ResponseLogsItem {
            level: Result<String, String>,
            message: Result<String, String>,
        }
        impl Default for TransactionPreviewV2ResponseLogsItem {
            fn default() -> Self {
                Self {
                    level: Err("no value supplied for level".to_string()),
                    message: Err("no value supplied for message".to_string()),
                }
            }
        }
        impl TransactionPreviewV2ResponseLogsItem {
            pub fn level<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.level = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for level: {}", e)
                    });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for message: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<TransactionPreviewV2ResponseLogsItem>
        for super::TransactionPreviewV2ResponseLogsItem {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TransactionPreviewV2ResponseLogsItem,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    level: value.level?,
                    message: value.message?,
                })
            }
        }
        impl From<super::TransactionPreviewV2ResponseLogsItem>
        for TransactionPreviewV2ResponseLogsItem {
            fn from(value: super::TransactionPreviewV2ResponseLogsItem) -> Self {
                Self {
                    level: Ok(value.level),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TransactionReceipt {
            costing_parameters: Result<
                ::serde_json::Map<String, ::serde_json::Value>,
                String,
            >,
            error_message: Result<Option<String>, String>,
            events: Result<Vec<super::EventsItem>, String>,
            fee_destination: Result<
                ::serde_json::Map<String, ::serde_json::Value>,
                String,
            >,
            fee_source: Result<::serde_json::Map<String, ::serde_json::Value>, String>,
            fee_summary: Result<::serde_json::Map<String, ::serde_json::Value>, String>,
            next_epoch: Result<::serde_json::Map<String, ::serde_json::Value>, String>,
            output: Result<Vec<super::SborData>, String>,
            state_updates: Result<
                ::serde_json::Map<String, ::serde_json::Value>,
                String,
            >,
            status: Result<Option<super::TransactionStatus>, String>,
        }
        impl Default for TransactionReceipt {
            fn default() -> Self {
                Self {
                    costing_parameters: Ok(Default::default()),
                    error_message: Ok(Default::default()),
                    events: Ok(Default::default()),
                    fee_destination: Ok(Default::default()),
                    fee_source: Ok(Default::default()),
                    fee_summary: Ok(Default::default()),
                    next_epoch: Ok(Default::default()),
                    output: Ok(Default::default()),
                    state_updates: Ok(Default::default()),
                    status: Ok(Default::default()),
                }
            }
        }
        impl TransactionReceipt {
            pub fn costing_parameters<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<::serde_json::Map<String, ::serde_json::Value>>,
                T::Error: std::fmt::Display,
            {
                self.costing_parameters = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for costing_parameters: {}",
                            e
                        )
                    });
                self
            }
            pub fn error_message<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.error_message = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for error_message: {}", e
                        )
                    });
                self
            }
            pub fn events<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::EventsItem>>,
                T::Error: std::fmt::Display,
            {
                self.events = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for events: {}", e)
                    });
                self
            }
            pub fn fee_destination<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<::serde_json::Map<String, ::serde_json::Value>>,
                T::Error: std::fmt::Display,
            {
                self.fee_destination = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for fee_destination: {}", e
                        )
                    });
                self
            }
            pub fn fee_source<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<::serde_json::Map<String, ::serde_json::Value>>,
                T::Error: std::fmt::Display,
            {
                self.fee_source = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for fee_source: {}", e)
                    });
                self
            }
            pub fn fee_summary<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<::serde_json::Map<String, ::serde_json::Value>>,
                T::Error: std::fmt::Display,
            {
                self.fee_summary = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for fee_summary: {}", e)
                    });
                self
            }
            pub fn next_epoch<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<::serde_json::Map<String, ::serde_json::Value>>,
                T::Error: std::fmt::Display,
            {
                self.next_epoch = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for next_epoch: {}", e)
                    });
                self
            }
            pub fn output<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::SborData>>,
                T::Error: std::fmt::Display,
            {
                self.output = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for output: {}", e)
                    });
                self
            }
            pub fn state_updates<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<::serde_json::Map<String, ::serde_json::Value>>,
                T::Error: std::fmt::Display,
            {
                self.state_updates = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for state_updates: {}", e
                        )
                    });
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::TransactionStatus>>,
                T::Error: std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for status: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<TransactionReceipt> for super::TransactionReceipt {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TransactionReceipt,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    costing_parameters: value.costing_parameters?,
                    error_message: value.error_message?,
                    events: value.events?,
                    fee_destination: value.fee_destination?,
                    fee_source: value.fee_source?,
                    fee_summary: value.fee_summary?,
                    next_epoch: value.next_epoch?,
                    output: value.output?,
                    state_updates: value.state_updates?,
                    status: value.status?,
                })
            }
        }
        impl From<super::TransactionReceipt> for TransactionReceipt {
            fn from(value: super::TransactionReceipt) -> Self {
                Self {
                    costing_parameters: Ok(value.costing_parameters),
                    error_message: Ok(value.error_message),
                    events: Ok(value.events),
                    fee_destination: Ok(value.fee_destination),
                    fee_source: Ok(value.fee_source),
                    fee_summary: Ok(value.fee_summary),
                    next_epoch: Ok(value.next_epoch),
                    output: Ok(value.output),
                    state_updates: Ok(value.state_updates),
                    status: Ok(value.status),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TransactionStatusRequest {
            intent_hash: Result<super::HashBech32mString, String>,
        }
        impl Default for TransactionStatusRequest {
            fn default() -> Self {
                Self {
                    intent_hash: Err("no value supplied for intent_hash".to_string()),
                }
            }
        }
        impl TransactionStatusRequest {
            pub fn intent_hash<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::HashBech32mString>,
                T::Error: std::fmt::Display,
            {
                self.intent_hash = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for intent_hash: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<TransactionStatusRequest>
        for super::TransactionStatusRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TransactionStatusRequest,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    intent_hash: value.intent_hash?,
                })
            }
        }
        impl From<super::TransactionStatusRequest> for TransactionStatusRequest {
            fn from(value: super::TransactionStatusRequest) -> Self {
                Self {
                    intent_hash: Ok(value.intent_hash),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TransactionStatusResponse {
            committed_state_version: Result<Option<i64>, String>,
            error_message: Result<Option<String>, String>,
            intent_status: Result<super::TransactionIntentStatus, String>,
            intent_status_description: Result<String, String>,
            known_payloads: Result<
                Vec<super::TransactionStatusResponseKnownPayloadItem>,
                String,
            >,
            ledger_state: Result<super::LedgerState, String>,
            permanently_rejects_at_epoch: Result<Option<i64>, String>,
            status: Result<super::TransactionStatus, String>,
        }
        impl Default for TransactionStatusResponse {
            fn default() -> Self {
                Self {
                    committed_state_version: Ok(Default::default()),
                    error_message: Ok(Default::default()),
                    intent_status: Err(
                        "no value supplied for intent_status".to_string(),
                    ),
                    intent_status_description: Err(
                        "no value supplied for intent_status_description".to_string(),
                    ),
                    known_payloads: Err(
                        "no value supplied for known_payloads".to_string(),
                    ),
                    ledger_state: Err("no value supplied for ledger_state".to_string()),
                    permanently_rejects_at_epoch: Ok(Default::default()),
                    status: Err("no value supplied for status".to_string()),
                }
            }
        }
        impl TransactionStatusResponse {
            pub fn committed_state_version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.committed_state_version = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for committed_state_version: {}",
                            e
                        )
                    });
                self
            }
            pub fn error_message<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.error_message = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for error_message: {}", e
                        )
                    });
                self
            }
            pub fn intent_status<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::TransactionIntentStatus>,
                T::Error: std::fmt::Display,
            {
                self.intent_status = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for intent_status: {}", e
                        )
                    });
                self
            }
            pub fn intent_status_description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.intent_status_description = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for intent_status_description: {}",
                            e
                        )
                    });
                self
            }
            pub fn known_payloads<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    Vec<super::TransactionStatusResponseKnownPayloadItem>,
                >,
                T::Error: std::fmt::Display,
            {
                self.known_payloads = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for known_payloads: {}", e
                        )
                    });
                self
            }
            pub fn ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::LedgerState>,
                T::Error: std::fmt::Display,
            {
                self.ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn permanently_rejects_at_epoch<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.permanently_rejects_at_epoch = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for permanently_rejects_at_epoch: {}",
                            e
                        )
                    });
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::TransactionStatus>,
                T::Error: std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for status: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<TransactionStatusResponse>
        for super::TransactionStatusResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TransactionStatusResponse,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    committed_state_version: value.committed_state_version?,
                    error_message: value.error_message?,
                    intent_status: value.intent_status?,
                    intent_status_description: value.intent_status_description?,
                    known_payloads: value.known_payloads?,
                    ledger_state: value.ledger_state?,
                    permanently_rejects_at_epoch: value.permanently_rejects_at_epoch?,
                    status: value.status?,
                })
            }
        }
        impl From<super::TransactionStatusResponse> for TransactionStatusResponse {
            fn from(value: super::TransactionStatusResponse) -> Self {
                Self {
                    committed_state_version: Ok(value.committed_state_version),
                    error_message: Ok(value.error_message),
                    intent_status: Ok(value.intent_status),
                    intent_status_description: Ok(value.intent_status_description),
                    known_payloads: Ok(value.known_payloads),
                    ledger_state: Ok(value.ledger_state),
                    permanently_rejects_at_epoch: Ok(value.permanently_rejects_at_epoch),
                    status: Ok(value.status),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TransactionStatusResponseKnownPayloadItem {
            error_message: Result<Option<String>, String>,
            handling_status: Result<
                Option<super::TransactionPayloadGatewayHandlingStatus>,
                String,
            >,
            handling_status_reason: Result<Option<String>, String>,
            latest_error_message: Result<Option<String>, String>,
            payload_hash: Result<super::HashBech32mString, String>,
            payload_status: Result<Option<super::TransactionPayloadStatus>, String>,
            payload_status_description: Result<Option<String>, String>,
            status: Result<super::TransactionStatus, String>,
            submission_error: Result<Option<String>, String>,
        }
        impl Default for TransactionStatusResponseKnownPayloadItem {
            fn default() -> Self {
                Self {
                    error_message: Ok(Default::default()),
                    handling_status: Ok(Default::default()),
                    handling_status_reason: Ok(Default::default()),
                    latest_error_message: Ok(Default::default()),
                    payload_hash: Err("no value supplied for payload_hash".to_string()),
                    payload_status: Ok(Default::default()),
                    payload_status_description: Ok(Default::default()),
                    status: Err("no value supplied for status".to_string()),
                    submission_error: Ok(Default::default()),
                }
            }
        }
        impl TransactionStatusResponseKnownPayloadItem {
            pub fn error_message<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.error_message = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for error_message: {}", e
                        )
                    });
                self
            }
            pub fn handling_status<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    Option<super::TransactionPayloadGatewayHandlingStatus>,
                >,
                T::Error: std::fmt::Display,
            {
                self.handling_status = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for handling_status: {}", e
                        )
                    });
                self
            }
            pub fn handling_status_reason<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.handling_status_reason = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for handling_status_reason: {}",
                            e
                        )
                    });
                self
            }
            pub fn latest_error_message<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.latest_error_message = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for latest_error_message: {}",
                            e
                        )
                    });
                self
            }
            pub fn payload_hash<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::HashBech32mString>,
                T::Error: std::fmt::Display,
            {
                self.payload_hash = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for payload_hash: {}", e
                        )
                    });
                self
            }
            pub fn payload_status<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::TransactionPayloadStatus>>,
                T::Error: std::fmt::Display,
            {
                self.payload_status = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for payload_status: {}", e
                        )
                    });
                self
            }
            pub fn payload_status_description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.payload_status_description = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for payload_status_description: {}",
                            e
                        )
                    });
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::TransactionStatus>,
                T::Error: std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for status: {}", e)
                    });
                self
            }
            pub fn submission_error<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.submission_error = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for submission_error: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<TransactionStatusResponseKnownPayloadItem>
        for super::TransactionStatusResponseKnownPayloadItem {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TransactionStatusResponseKnownPayloadItem,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    error_message: value.error_message?,
                    handling_status: value.handling_status?,
                    handling_status_reason: value.handling_status_reason?,
                    latest_error_message: value.latest_error_message?,
                    payload_hash: value.payload_hash?,
                    payload_status: value.payload_status?,
                    payload_status_description: value.payload_status_description?,
                    status: value.status?,
                    submission_error: value.submission_error?,
                })
            }
        }
        impl From<super::TransactionStatusResponseKnownPayloadItem>
        for TransactionStatusResponseKnownPayloadItem {
            fn from(value: super::TransactionStatusResponseKnownPayloadItem) -> Self {
                Self {
                    error_message: Ok(value.error_message),
                    handling_status: Ok(value.handling_status),
                    handling_status_reason: Ok(value.handling_status_reason),
                    latest_error_message: Ok(value.latest_error_message),
                    payload_hash: Ok(value.payload_hash),
                    payload_status: Ok(value.payload_status),
                    payload_status_description: Ok(value.payload_status_description),
                    status: Ok(value.status),
                    submission_error: Ok(value.submission_error),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TransactionSubintentDetails {
            child_subintent_hashes: Result<Vec<super::HashBech32mString>, String>,
            manifest_instructions: Result<Option<String>, String>,
            message: Result<::serde_json::Map<String, ::serde_json::Value>, String>,
            subintent_hash: Result<super::HashBech32mString, String>,
        }
        impl Default for TransactionSubintentDetails {
            fn default() -> Self {
                Self {
                    child_subintent_hashes: Ok(Default::default()),
                    manifest_instructions: Ok(Default::default()),
                    message: Ok(Default::default()),
                    subintent_hash: Err(
                        "no value supplied for subintent_hash".to_string(),
                    ),
                }
            }
        }
        impl TransactionSubintentDetails {
            pub fn child_subintent_hashes<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::HashBech32mString>>,
                T::Error: std::fmt::Display,
            {
                self.child_subintent_hashes = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for child_subintent_hashes: {}",
                            e
                        )
                    });
                self
            }
            pub fn manifest_instructions<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.manifest_instructions = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for manifest_instructions: {}",
                            e
                        )
                    });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<::serde_json::Map<String, ::serde_json::Value>>,
                T::Error: std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for message: {}", e)
                    });
                self
            }
            pub fn subintent_hash<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::HashBech32mString>,
                T::Error: std::fmt::Display,
            {
                self.subintent_hash = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for subintent_hash: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<TransactionSubintentDetails>
        for super::TransactionSubintentDetails {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TransactionSubintentDetails,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    child_subintent_hashes: value.child_subintent_hashes?,
                    manifest_instructions: value.manifest_instructions?,
                    message: value.message?,
                    subintent_hash: value.subintent_hash?,
                })
            }
        }
        impl From<super::TransactionSubintentDetails> for TransactionSubintentDetails {
            fn from(value: super::TransactionSubintentDetails) -> Self {
                Self {
                    child_subintent_hashes: Ok(value.child_subintent_hashes),
                    manifest_instructions: Ok(value.manifest_instructions),
                    message: Ok(value.message),
                    subintent_hash: Ok(value.subintent_hash),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TransactionSubintentStatusRequest {
            subintent_hash: Result<super::HashBech32mString, String>,
        }
        impl Default for TransactionSubintentStatusRequest {
            fn default() -> Self {
                Self {
                    subintent_hash: Err(
                        "no value supplied for subintent_hash".to_string(),
                    ),
                }
            }
        }
        impl TransactionSubintentStatusRequest {
            pub fn subintent_hash<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::HashBech32mString>,
                T::Error: std::fmt::Display,
            {
                self.subintent_hash = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for subintent_hash: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<TransactionSubintentStatusRequest>
        for super::TransactionSubintentStatusRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TransactionSubintentStatusRequest,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    subintent_hash: value.subintent_hash?,
                })
            }
        }
        impl From<super::TransactionSubintentStatusRequest>
        for TransactionSubintentStatusRequest {
            fn from(value: super::TransactionSubintentStatusRequest) -> Self {
                Self {
                    subintent_hash: Ok(value.subintent_hash),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TransactionSubintentStatusResponse {
            finalized_at_state_version: Result<Option<i64>, String>,
            finalized_at_transaction_intent_hash: Result<
                Option<super::HashBech32mString>,
                String,
            >,
            ledger_state: Result<super::LedgerState, String>,
            subintent_status: Result<super::SubintentStatus, String>,
            subintent_status_description: Result<String, String>,
        }
        impl Default for TransactionSubintentStatusResponse {
            fn default() -> Self {
                Self {
                    finalized_at_state_version: Ok(Default::default()),
                    finalized_at_transaction_intent_hash: Ok(Default::default()),
                    ledger_state: Err("no value supplied for ledger_state".to_string()),
                    subintent_status: Err(
                        "no value supplied for subintent_status".to_string(),
                    ),
                    subintent_status_description: Err(
                        "no value supplied for subintent_status_description".to_string(),
                    ),
                }
            }
        }
        impl TransactionSubintentStatusResponse {
            pub fn finalized_at_state_version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.finalized_at_state_version = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for finalized_at_state_version: {}",
                            e
                        )
                    });
                self
            }
            pub fn finalized_at_transaction_intent_hash<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::HashBech32mString>>,
                T::Error: std::fmt::Display,
            {
                self.finalized_at_transaction_intent_hash = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for finalized_at_transaction_intent_hash: {}",
                            e
                        )
                    });
                self
            }
            pub fn ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::LedgerState>,
                T::Error: std::fmt::Display,
            {
                self.ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn subintent_status<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::SubintentStatus>,
                T::Error: std::fmt::Display,
            {
                self.subintent_status = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for subintent_status: {}", e
                        )
                    });
                self
            }
            pub fn subintent_status_description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.subintent_status_description = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for subintent_status_description: {}",
                            e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<TransactionSubintentStatusResponse>
        for super::TransactionSubintentStatusResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TransactionSubintentStatusResponse,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    finalized_at_state_version: value.finalized_at_state_version?,
                    finalized_at_transaction_intent_hash: value
                        .finalized_at_transaction_intent_hash?,
                    ledger_state: value.ledger_state?,
                    subintent_status: value.subintent_status?,
                    subintent_status_description: value.subintent_status_description?,
                })
            }
        }
        impl From<super::TransactionSubintentStatusResponse>
        for TransactionSubintentStatusResponse {
            fn from(value: super::TransactionSubintentStatusResponse) -> Self {
                Self {
                    finalized_at_state_version: Ok(value.finalized_at_state_version),
                    finalized_at_transaction_intent_hash: Ok(
                        value.finalized_at_transaction_intent_hash,
                    ),
                    ledger_state: Ok(value.ledger_state),
                    subintent_status: Ok(value.subintent_status),
                    subintent_status_description: Ok(value.subintent_status_description),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TransactionSubmitRequest {
            notarized_transaction_hex: Result<
                super::NotarizedTransactionHexString,
                String,
            >,
        }
        impl Default for TransactionSubmitRequest {
            fn default() -> Self {
                Self {
                    notarized_transaction_hex: Err(
                        "no value supplied for notarized_transaction_hex".to_string(),
                    ),
                }
            }
        }
        impl TransactionSubmitRequest {
            pub fn notarized_transaction_hex<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::NotarizedTransactionHexString>,
                T::Error: std::fmt::Display,
            {
                self.notarized_transaction_hex = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for notarized_transaction_hex: {}",
                            e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<TransactionSubmitRequest>
        for super::TransactionSubmitRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TransactionSubmitRequest,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    notarized_transaction_hex: value.notarized_transaction_hex?,
                })
            }
        }
        impl From<super::TransactionSubmitRequest> for TransactionSubmitRequest {
            fn from(value: super::TransactionSubmitRequest) -> Self {
                Self {
                    notarized_transaction_hex: Ok(value.notarized_transaction_hex),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TransactionSubmitResponse {
            duplicate: Result<bool, String>,
        }
        impl Default for TransactionSubmitResponse {
            fn default() -> Self {
                Self {
                    duplicate: Err("no value supplied for duplicate".to_string()),
                }
            }
        }
        impl TransactionSubmitResponse {
            pub fn duplicate<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.duplicate = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for duplicate: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<TransactionSubmitResponse>
        for super::TransactionSubmitResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TransactionSubmitResponse,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    duplicate: value.duplicate?,
                })
            }
        }
        impl From<super::TransactionSubmitResponse> for TransactionSubmitResponse {
            fn from(value: super::TransactionSubmitResponse) -> Self {
                Self {
                    duplicate: Ok(value.duplicate),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TwoWayLinkedDappOnLedgerDetails {
            dapps: Result<Option<super::TwoWayLinkedDappsCollection>, String>,
            entities: Result<Option<super::TwoWayLinkedEntitiesCollection>, String>,
            primary_locker: Result<Option<super::Address>, String>,
        }
        impl Default for TwoWayLinkedDappOnLedgerDetails {
            fn default() -> Self {
                Self {
                    dapps: Ok(Default::default()),
                    entities: Ok(Default::default()),
                    primary_locker: Ok(Default::default()),
                }
            }
        }
        impl TwoWayLinkedDappOnLedgerDetails {
            pub fn dapps<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::TwoWayLinkedDappsCollection>>,
                T::Error: std::fmt::Display,
            {
                self.dapps = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for dapps: {}", e)
                    });
                self
            }
            pub fn entities<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::TwoWayLinkedEntitiesCollection>>,
                T::Error: std::fmt::Display,
            {
                self.entities = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for entities: {}", e)
                    });
                self
            }
            pub fn primary_locker<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::Address>>,
                T::Error: std::fmt::Display,
            {
                self.primary_locker = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for primary_locker: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<TwoWayLinkedDappOnLedgerDetails>
        for super::TwoWayLinkedDappOnLedgerDetails {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TwoWayLinkedDappOnLedgerDetails,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    dapps: value.dapps?,
                    entities: value.entities?,
                    primary_locker: value.primary_locker?,
                })
            }
        }
        impl From<super::TwoWayLinkedDappOnLedgerDetails>
        for TwoWayLinkedDappOnLedgerDetails {
            fn from(value: super::TwoWayLinkedDappOnLedgerDetails) -> Self {
                Self {
                    dapps: Ok(value.dapps),
                    entities: Ok(value.entities),
                    primary_locker: Ok(value.primary_locker),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TwoWayLinkedDappsCollection {
            items: Result<Vec<super::TwoWayLinkedDappsCollectionItem>, String>,
        }
        impl Default for TwoWayLinkedDappsCollection {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                }
            }
        }
        impl TwoWayLinkedDappsCollection {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::TwoWayLinkedDappsCollectionItem>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<TwoWayLinkedDappsCollection>
        for super::TwoWayLinkedDappsCollection {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TwoWayLinkedDappsCollection,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self { items: value.items? })
            }
        }
        impl From<super::TwoWayLinkedDappsCollection> for TwoWayLinkedDappsCollection {
            fn from(value: super::TwoWayLinkedDappsCollection) -> Self {
                Self { items: Ok(value.items) }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TwoWayLinkedDappsCollectionItem {
            dapp_address: Result<super::Address, String>,
        }
        impl Default for TwoWayLinkedDappsCollectionItem {
            fn default() -> Self {
                Self {
                    dapp_address: Err("no value supplied for dapp_address".to_string()),
                }
            }
        }
        impl TwoWayLinkedDappsCollectionItem {
            pub fn dapp_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.dapp_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for dapp_address: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<TwoWayLinkedDappsCollectionItem>
        for super::TwoWayLinkedDappsCollectionItem {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TwoWayLinkedDappsCollectionItem,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    dapp_address: value.dapp_address?,
                })
            }
        }
        impl From<super::TwoWayLinkedDappsCollectionItem>
        for TwoWayLinkedDappsCollectionItem {
            fn from(value: super::TwoWayLinkedDappsCollectionItem) -> Self {
                Self {
                    dapp_address: Ok(value.dapp_address),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TwoWayLinkedEntitiesCollection {
            items: Result<Vec<super::TwoWayLinkedEntitiesCollectionItem>, String>,
        }
        impl Default for TwoWayLinkedEntitiesCollection {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                }
            }
        }
        impl TwoWayLinkedEntitiesCollection {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::TwoWayLinkedEntitiesCollectionItem>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<TwoWayLinkedEntitiesCollection>
        for super::TwoWayLinkedEntitiesCollection {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TwoWayLinkedEntitiesCollection,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self { items: value.items? })
            }
        }
        impl From<super::TwoWayLinkedEntitiesCollection>
        for TwoWayLinkedEntitiesCollection {
            fn from(value: super::TwoWayLinkedEntitiesCollection) -> Self {
                Self { items: Ok(value.items) }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TwoWayLinkedEntitiesCollectionItem {
            entity_address: Result<super::Address, String>,
        }
        impl Default for TwoWayLinkedEntitiesCollectionItem {
            fn default() -> Self {
                Self {
                    entity_address: Err(
                        "no value supplied for entity_address".to_string(),
                    ),
                }
            }
        }
        impl TwoWayLinkedEntitiesCollectionItem {
            pub fn entity_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.entity_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for entity_address: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<TwoWayLinkedEntitiesCollectionItem>
        for super::TwoWayLinkedEntitiesCollectionItem {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TwoWayLinkedEntitiesCollectionItem,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    entity_address: value.entity_address?,
                })
            }
        }
        impl From<super::TwoWayLinkedEntitiesCollectionItem>
        for TwoWayLinkedEntitiesCollectionItem {
            fn from(value: super::TwoWayLinkedEntitiesCollectionItem) -> Self {
                Self {
                    entity_address: Ok(value.entity_address),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ValidationErrorsAtPath {
            errors: Result<Vec<String>, String>,
            path: Result<String, String>,
        }
        impl Default for ValidationErrorsAtPath {
            fn default() -> Self {
                Self {
                    errors: Err("no value supplied for errors".to_string()),
                    path: Err("no value supplied for path".to_string()),
                }
            }
        }
        impl ValidationErrorsAtPath {
            pub fn errors<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<String>>,
                T::Error: std::fmt::Display,
            {
                self.errors = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for errors: {}", e)
                    });
                self
            }
            pub fn path<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.path = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for path: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<ValidationErrorsAtPath>
        for super::ValidationErrorsAtPath {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ValidationErrorsAtPath,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    errors: value.errors?,
                    path: value.path?,
                })
            }
        }
        impl From<super::ValidationErrorsAtPath> for ValidationErrorsAtPath {
            fn from(value: super::ValidationErrorsAtPath) -> Self {
                Self {
                    errors: Ok(value.errors),
                    path: Ok(value.path),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ValidatorCollection {
            items: Result<Vec<super::ValidatorCollectionItem>, String>,
            next_cursor: Result<Option<String>, String>,
            total_count: Result<Option<i64>, String>,
        }
        impl Default for ValidatorCollection {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_cursor: Ok(Default::default()),
                    total_count: Ok(Default::default()),
                }
            }
        }
        impl ValidatorCollection {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::ValidatorCollectionItem>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {}", e)
                    });
                self
            }
            pub fn next_cursor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for next_cursor: {}", e)
                    });
                self
            }
            pub fn total_count<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.total_count = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for total_count: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<ValidatorCollection> for super::ValidatorCollection {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ValidatorCollection,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_cursor: value.next_cursor?,
                    total_count: value.total_count?,
                })
            }
        }
        impl From<super::ValidatorCollection> for ValidatorCollection {
            fn from(value: super::ValidatorCollection) -> Self {
                Self {
                    items: Ok(value.items),
                    next_cursor: Ok(value.next_cursor),
                    total_count: Ok(value.total_count),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ValidatorCollectionItem {
            active_in_epoch: Result<
                Option<super::ValidatorCollectionItemActiveInEpoch>,
                String,
            >,
            address: Result<super::Address, String>,
            effective_fee_factor: Result<
                super::ValidatorCollectionItemEffectiveFeeFactor,
                String,
            >,
            locked_owner_stake_unit_vault: Result<super::ValidatorVaultItem, String>,
            metadata: Result<super::EntityMetadataCollection, String>,
            pending_owner_stake_unit_unlock_vault: Result<
                super::ValidatorVaultItem,
                String,
            >,
            pending_xrd_withdraw_vault: Result<super::ValidatorVaultItem, String>,
            stake_vault: Result<super::ValidatorVaultItem, String>,
            state: Result<
                Option<::serde_json::Map<String, ::serde_json::Value>>,
                String,
            >,
        }
        impl Default for ValidatorCollectionItem {
            fn default() -> Self {
                Self {
                    active_in_epoch: Ok(Default::default()),
                    address: Err("no value supplied for address".to_string()),
                    effective_fee_factor: Err(
                        "no value supplied for effective_fee_factor".to_string(),
                    ),
                    locked_owner_stake_unit_vault: Err(
                        "no value supplied for locked_owner_stake_unit_vault".to_string(),
                    ),
                    metadata: Err("no value supplied for metadata".to_string()),
                    pending_owner_stake_unit_unlock_vault: Err(
                        "no value supplied for pending_owner_stake_unit_unlock_vault"
                            .to_string(),
                    ),
                    pending_xrd_withdraw_vault: Err(
                        "no value supplied for pending_xrd_withdraw_vault".to_string(),
                    ),
                    stake_vault: Err("no value supplied for stake_vault".to_string()),
                    state: Err("no value supplied for state".to_string()),
                }
            }
        }
        impl ValidatorCollectionItem {
            pub fn active_in_epoch<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    Option<super::ValidatorCollectionItemActiveInEpoch>,
                >,
                T::Error: std::fmt::Display,
            {
                self.active_in_epoch = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for active_in_epoch: {}", e
                        )
                    });
                self
            }
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for address: {}", e)
                    });
                self
            }
            pub fn effective_fee_factor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::ValidatorCollectionItemEffectiveFeeFactor,
                >,
                T::Error: std::fmt::Display,
            {
                self.effective_fee_factor = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for effective_fee_factor: {}",
                            e
                        )
                    });
                self
            }
            pub fn locked_owner_stake_unit_vault<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ValidatorVaultItem>,
                T::Error: std::fmt::Display,
            {
                self.locked_owner_stake_unit_vault = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for locked_owner_stake_unit_vault: {}",
                            e
                        )
                    });
                self
            }
            pub fn metadata<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::EntityMetadataCollection>,
                T::Error: std::fmt::Display,
            {
                self.metadata = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for metadata: {}", e)
                    });
                self
            }
            pub fn pending_owner_stake_unit_unlock_vault<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ValidatorVaultItem>,
                T::Error: std::fmt::Display,
            {
                self.pending_owner_stake_unit_unlock_vault = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for pending_owner_stake_unit_unlock_vault: {}",
                            e
                        )
                    });
                self
            }
            pub fn pending_xrd_withdraw_vault<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ValidatorVaultItem>,
                T::Error: std::fmt::Display,
            {
                self.pending_xrd_withdraw_vault = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for pending_xrd_withdraw_vault: {}",
                            e
                        )
                    });
                self
            }
            pub fn stake_vault<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ValidatorVaultItem>,
                T::Error: std::fmt::Display,
            {
                self.stake_vault = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for stake_vault: {}", e)
                    });
                self
            }
            pub fn state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    Option<::serde_json::Map<String, ::serde_json::Value>>,
                >,
                T::Error: std::fmt::Display,
            {
                self.state = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for state: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<ValidatorCollectionItem>
        for super::ValidatorCollectionItem {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ValidatorCollectionItem,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    active_in_epoch: value.active_in_epoch?,
                    address: value.address?,
                    effective_fee_factor: value.effective_fee_factor?,
                    locked_owner_stake_unit_vault: value.locked_owner_stake_unit_vault?,
                    metadata: value.metadata?,
                    pending_owner_stake_unit_unlock_vault: value
                        .pending_owner_stake_unit_unlock_vault?,
                    pending_xrd_withdraw_vault: value.pending_xrd_withdraw_vault?,
                    stake_vault: value.stake_vault?,
                    state: value.state?,
                })
            }
        }
        impl From<super::ValidatorCollectionItem> for ValidatorCollectionItem {
            fn from(value: super::ValidatorCollectionItem) -> Self {
                Self {
                    active_in_epoch: Ok(value.active_in_epoch),
                    address: Ok(value.address),
                    effective_fee_factor: Ok(value.effective_fee_factor),
                    locked_owner_stake_unit_vault: Ok(
                        value.locked_owner_stake_unit_vault,
                    ),
                    metadata: Ok(value.metadata),
                    pending_owner_stake_unit_unlock_vault: Ok(
                        value.pending_owner_stake_unit_unlock_vault,
                    ),
                    pending_xrd_withdraw_vault: Ok(value.pending_xrd_withdraw_vault),
                    stake_vault: Ok(value.stake_vault),
                    state: Ok(value.state),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ValidatorCollectionItemActiveInEpoch {
            key: Result<super::PublicKey, String>,
            stake: Result<super::BigDecimal, String>,
            stake_percentage: Result<f64, String>,
        }
        impl Default for ValidatorCollectionItemActiveInEpoch {
            fn default() -> Self {
                Self {
                    key: Err("no value supplied for key".to_string()),
                    stake: Err("no value supplied for stake".to_string()),
                    stake_percentage: Err(
                        "no value supplied for stake_percentage".to_string(),
                    ),
                }
            }
        }
        impl ValidatorCollectionItemActiveInEpoch {
            pub fn key<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::PublicKey>,
                T::Error: std::fmt::Display,
            {
                self.key = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for key: {}", e)
                    });
                self
            }
            pub fn stake<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::BigDecimal>,
                T::Error: std::fmt::Display,
            {
                self.stake = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for stake: {}", e)
                    });
                self
            }
            pub fn stake_percentage<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<f64>,
                T::Error: std::fmt::Display,
            {
                self.stake_percentage = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for stake_percentage: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<ValidatorCollectionItemActiveInEpoch>
        for super::ValidatorCollectionItemActiveInEpoch {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ValidatorCollectionItemActiveInEpoch,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    key: value.key?,
                    stake: value.stake?,
                    stake_percentage: value.stake_percentage?,
                })
            }
        }
        impl From<super::ValidatorCollectionItemActiveInEpoch>
        for ValidatorCollectionItemActiveInEpoch {
            fn from(value: super::ValidatorCollectionItemActiveInEpoch) -> Self {
                Self {
                    key: Ok(value.key),
                    stake: Ok(value.stake),
                    stake_percentage: Ok(value.stake_percentage),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ValidatorCollectionItemEffectiveFeeFactor {
            current: Result<
                super::ValidatorCollectionItemEffectiveFeeFactorCurrent,
                String,
            >,
            pending: Result<
                Option<super::ValidatorCollectionItemEffectiveFeeFactorPending>,
                String,
            >,
        }
        impl Default for ValidatorCollectionItemEffectiveFeeFactor {
            fn default() -> Self {
                Self {
                    current: Err("no value supplied for current".to_string()),
                    pending: Ok(Default::default()),
                }
            }
        }
        impl ValidatorCollectionItemEffectiveFeeFactor {
            pub fn current<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    super::ValidatorCollectionItemEffectiveFeeFactorCurrent,
                >,
                T::Error: std::fmt::Display,
            {
                self.current = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for current: {}", e)
                    });
                self
            }
            pub fn pending<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    Option<super::ValidatorCollectionItemEffectiveFeeFactorPending>,
                >,
                T::Error: std::fmt::Display,
            {
                self.pending = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for pending: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<ValidatorCollectionItemEffectiveFeeFactor>
        for super::ValidatorCollectionItemEffectiveFeeFactor {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ValidatorCollectionItemEffectiveFeeFactor,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    current: value.current?,
                    pending: value.pending?,
                })
            }
        }
        impl From<super::ValidatorCollectionItemEffectiveFeeFactor>
        for ValidatorCollectionItemEffectiveFeeFactor {
            fn from(value: super::ValidatorCollectionItemEffectiveFeeFactor) -> Self {
                Self {
                    current: Ok(value.current),
                    pending: Ok(value.pending),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ValidatorCollectionItemEffectiveFeeFactorCurrent {
            fee_factor: Result<super::BigDecimal, String>,
        }
        impl Default for ValidatorCollectionItemEffectiveFeeFactorCurrent {
            fn default() -> Self {
                Self {
                    fee_factor: Err("no value supplied for fee_factor".to_string()),
                }
            }
        }
        impl ValidatorCollectionItemEffectiveFeeFactorCurrent {
            pub fn fee_factor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::BigDecimal>,
                T::Error: std::fmt::Display,
            {
                self.fee_factor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for fee_factor: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<ValidatorCollectionItemEffectiveFeeFactorCurrent>
        for super::ValidatorCollectionItemEffectiveFeeFactorCurrent {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ValidatorCollectionItemEffectiveFeeFactorCurrent,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    fee_factor: value.fee_factor?,
                })
            }
        }
        impl From<super::ValidatorCollectionItemEffectiveFeeFactorCurrent>
        for ValidatorCollectionItemEffectiveFeeFactorCurrent {
            fn from(
                value: super::ValidatorCollectionItemEffectiveFeeFactorCurrent,
            ) -> Self {
                Self {
                    fee_factor: Ok(value.fee_factor),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ValidatorCollectionItemEffectiveFeeFactorPending {
            effective_at_epoch: Result<i64, String>,
            fee_factor: Result<super::BigDecimal, String>,
        }
        impl Default for ValidatorCollectionItemEffectiveFeeFactorPending {
            fn default() -> Self {
                Self {
                    effective_at_epoch: Err(
                        "no value supplied for effective_at_epoch".to_string(),
                    ),
                    fee_factor: Err("no value supplied for fee_factor".to_string()),
                }
            }
        }
        impl ValidatorCollectionItemEffectiveFeeFactorPending {
            pub fn effective_at_epoch<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<i64>,
                T::Error: std::fmt::Display,
            {
                self.effective_at_epoch = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for effective_at_epoch: {}",
                            e
                        )
                    });
                self
            }
            pub fn fee_factor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::BigDecimal>,
                T::Error: std::fmt::Display,
            {
                self.fee_factor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for fee_factor: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<ValidatorCollectionItemEffectiveFeeFactorPending>
        for super::ValidatorCollectionItemEffectiveFeeFactorPending {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ValidatorCollectionItemEffectiveFeeFactorPending,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    effective_at_epoch: value.effective_at_epoch?,
                    fee_factor: value.fee_factor?,
                })
            }
        }
        impl From<super::ValidatorCollectionItemEffectiveFeeFactorPending>
        for ValidatorCollectionItemEffectiveFeeFactorPending {
            fn from(
                value: super::ValidatorCollectionItemEffectiveFeeFactorPending,
            ) -> Self {
                Self {
                    effective_at_epoch: Ok(value.effective_at_epoch),
                    fee_factor: Ok(value.fee_factor),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ValidatorUptimeCollection {
            items: Result<Vec<super::ValidatorUptimeCollectionItem>, String>,
        }
        impl Default for ValidatorUptimeCollection {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                }
            }
        }
        impl ValidatorUptimeCollection {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::ValidatorUptimeCollectionItem>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<ValidatorUptimeCollection>
        for super::ValidatorUptimeCollection {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ValidatorUptimeCollection,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self { items: value.items? })
            }
        }
        impl From<super::ValidatorUptimeCollection> for ValidatorUptimeCollection {
            fn from(value: super::ValidatorUptimeCollection) -> Self {
                Self { items: Ok(value.items) }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ValidatorUptimeCollectionItem {
            address: Result<super::Address, String>,
            epochs_active_in: Result<i64, String>,
            proposals_made: Result<Option<i64>, String>,
            proposals_missed: Result<Option<i64>, String>,
        }
        impl Default for ValidatorUptimeCollectionItem {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    epochs_active_in: Err(
                        "no value supplied for epochs_active_in".to_string(),
                    ),
                    proposals_made: Ok(Default::default()),
                    proposals_missed: Ok(Default::default()),
                }
            }
        }
        impl ValidatorUptimeCollectionItem {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for address: {}", e)
                    });
                self
            }
            pub fn epochs_active_in<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<i64>,
                T::Error: std::fmt::Display,
            {
                self.epochs_active_in = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for epochs_active_in: {}", e
                        )
                    });
                self
            }
            pub fn proposals_made<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.proposals_made = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for proposals_made: {}", e
                        )
                    });
                self
            }
            pub fn proposals_missed<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<i64>>,
                T::Error: std::fmt::Display,
            {
                self.proposals_missed = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for proposals_missed: {}", e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<ValidatorUptimeCollectionItem>
        for super::ValidatorUptimeCollectionItem {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ValidatorUptimeCollectionItem,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    epochs_active_in: value.epochs_active_in?,
                    proposals_made: value.proposals_made?,
                    proposals_missed: value.proposals_missed?,
                })
            }
        }
        impl From<super::ValidatorUptimeCollectionItem>
        for ValidatorUptimeCollectionItem {
            fn from(value: super::ValidatorUptimeCollectionItem) -> Self {
                Self {
                    address: Ok(value.address),
                    epochs_active_in: Ok(value.epochs_active_in),
                    proposals_made: Ok(value.proposals_made),
                    proposals_missed: Ok(value.proposals_missed),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ValidatorVaultItem {
            address: Result<super::Address, String>,
            balance: Result<super::BigDecimal, String>,
            last_changed_at_state_version: Result<i64, String>,
        }
        impl Default for ValidatorVaultItem {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    balance: Err("no value supplied for balance".to_string()),
                    last_changed_at_state_version: Err(
                        "no value supplied for last_changed_at_state_version".to_string(),
                    ),
                }
            }
        }
        impl ValidatorVaultItem {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Address>,
                T::Error: std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for address: {}", e)
                    });
                self
            }
            pub fn balance<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::BigDecimal>,
                T::Error: std::fmt::Display,
            {
                self.balance = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for balance: {}", e)
                    });
                self
            }
            pub fn last_changed_at_state_version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<i64>,
                T::Error: std::fmt::Display,
            {
                self.last_changed_at_state_version = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for last_changed_at_state_version: {}",
                            e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<ValidatorVaultItem> for super::ValidatorVaultItem {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ValidatorVaultItem,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    balance: value.balance?,
                    last_changed_at_state_version: value.last_changed_at_state_version?,
                })
            }
        }
        impl From<super::ValidatorVaultItem> for ValidatorVaultItem {
            fn from(value: super::ValidatorVaultItem) -> Self {
                Self {
                    address: Ok(value.address),
                    balance: Ok(value.balance),
                    last_changed_at_state_version: Ok(
                        value.last_changed_at_state_version,
                    ),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ValidatorsUptimeRequest {
            at_ledger_state: Result<Option<super::LedgerStateSelector>, String>,
            from_ledger_state: Result<Option<super::LedgerStateSelector>, String>,
            validator_addresses: Result<Vec<super::Address>, String>,
        }
        impl Default for ValidatorsUptimeRequest {
            fn default() -> Self {
                Self {
                    at_ledger_state: Ok(Default::default()),
                    from_ledger_state: Ok(Default::default()),
                    validator_addresses: Ok(Default::default()),
                }
            }
        }
        impl ValidatorsUptimeRequest {
            pub fn at_ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::LedgerStateSelector>>,
                T::Error: std::fmt::Display,
            {
                self.at_ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for at_ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn from_ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::LedgerStateSelector>>,
                T::Error: std::fmt::Display,
            {
                self.from_ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for from_ledger_state: {}",
                            e
                        )
                    });
                self
            }
            pub fn validator_addresses<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Address>>,
                T::Error: std::fmt::Display,
            {
                self.validator_addresses = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for validator_addresses: {}",
                            e
                        )
                    });
                self
            }
        }
        impl std::convert::TryFrom<ValidatorsUptimeRequest>
        for super::ValidatorsUptimeRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ValidatorsUptimeRequest,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    at_ledger_state: value.at_ledger_state?,
                    from_ledger_state: value.from_ledger_state?,
                    validator_addresses: value.validator_addresses?,
                })
            }
        }
        impl From<super::ValidatorsUptimeRequest> for ValidatorsUptimeRequest {
            fn from(value: super::ValidatorsUptimeRequest) -> Self {
                Self {
                    at_ledger_state: Ok(value.at_ledger_state),
                    from_ledger_state: Ok(value.from_ledger_state),
                    validator_addresses: Ok(value.validator_addresses),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ValidatorsUptimeResponse {
            ledger_state: Result<super::LedgerState, String>,
            validators: Result<super::ValidatorUptimeCollection, String>,
        }
        impl Default for ValidatorsUptimeResponse {
            fn default() -> Self {
                Self {
                    ledger_state: Err("no value supplied for ledger_state".to_string()),
                    validators: Err("no value supplied for validators".to_string()),
                }
            }
        }
        impl ValidatorsUptimeResponse {
            pub fn ledger_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::LedgerState>,
                T::Error: std::fmt::Display,
            {
                self.ledger_state = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for ledger_state: {}", e
                        )
                    });
                self
            }
            pub fn validators<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ValidatorUptimeCollection>,
                T::Error: std::fmt::Display,
            {
                self.validators = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for validators: {}", e)
                    });
                self
            }
        }
        impl std::convert::TryFrom<ValidatorsUptimeResponse>
        for super::ValidatorsUptimeResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ValidatorsUptimeResponse,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    ledger_state: value.ledger_state?,
                    validators: value.validators?,
                })
            }
        }
        impl From<super::ValidatorsUptimeResponse> for ValidatorsUptimeResponse {
            fn from(value: super::ValidatorsUptimeResponse) -> Self {
                Self {
                    ledger_state: Ok(value.ledger_state),
                    validators: Ok(value.validators),
                }
            }
        }
    }
    /// Generation of default values for serde.
    pub mod defaults {
        pub(super) fn default_bool<const V: bool>() -> bool {
            V
        }
    }
}
#[derive(Clone, Debug)]
/**Client for Radix Gateway API - Babylon

This API is exposed by the Babylon Radix Gateway to enable clients to efficiently query current and historic
state on the RadixDLT ledger, and intelligently handle transaction submission.

It is designed for use by wallets and explorers, and for light queries from front-end dApps.
For exchange/asset integrations, back-end dApp integrations, or simple use cases, you should consider using
the Core API on a Node. A Gateway is only needed for reading historic snapshots of ledger states or a more robust set-up.

The Gateway API is implemented by the [Network Gateway](https://github.com/radixdlt/babylon-gateway),
which is configured to read from [full node(s)](https://github.com/radixdlt/babylon-node) to extract
and index data from the network.

This document is an API reference documentation, visit [User Guide](https://docs.radixdlt.com/) to learn more
about how to run a Gateway of your own.

## Migration guide

Please see [the latest release notes](https://github.com/radixdlt/babylon-gateway/releases).

## Integration and forward compatibility guarantees

All responses may have additional fields added at any release, so clients are advised to use JSON parsers which
ignore unknown fields on JSON objects.

When the Radix protocol is updated, new functionality may be added, and so discriminated unions returned by the
API may need to be updated to have new variants added, corresponding to the updated data. Clients may need to update
in advance to be able to handle these new variants when a protocol update comes out.

On the very rare occasions we need to make breaking changes to the API, these will be warned in advance with
deprecation notices on previous versions. These deprecation notices will include a safe migration path.
Deprecation notes or breaking changes will be flagged clearly in release notes for new versions of the Gateway.

The Gateway DB schema is not subject to any compatibility guarantees, and may be changed at any release. DB changes
will be flagged in the release notes so clients doing custom DB integrations can prepare.


Version: v1.9.0*/
pub struct Client {
    pub(crate) baseurl: String,
    pub(crate) client: reqwest::Client,
}
impl Client {
    /// Create a new client.
    ///
    /// `baseurl` is the base URL provided to the internal
    /// `reqwest::Client`, and should include a scheme and hostname,
    /// as well as port and a path stem if applicable.
    pub fn new(baseurl: &str) -> Self {
        #[cfg(not(target_arch = "wasm32"))]
        let client = {
            let dur = std::time::Duration::from_secs(15);
            reqwest::ClientBuilder::new().connect_timeout(dur).timeout(dur)
        };
        #[cfg(target_arch = "wasm32")]
        let client = reqwest::ClientBuilder::new();
        Self::new_with_client(baseurl, client.build().unwrap())
    }
    /// Construct a new client with an existing `reqwest::Client`,
    /// allowing more control over its configuration.
    ///
    /// `baseurl` is the base URL provided to the internal
    /// `reqwest::Client`, and should include a scheme and hostname,
    /// as well as port and a path stem if applicable.
    pub fn new_with_client(baseurl: &str, client: reqwest::Client) -> Self {
        Self {
            baseurl: baseurl.to_string(),
            client,
        }
    }
    /// Get the base URL to which requests are made.
    pub fn baseurl(&self) -> &String {
        &self.baseurl
    }
    /// Get the internal `reqwest::Client` used to make requests.
    pub fn client(&self) -> &reqwest::Client {
        &self.client
    }
    /// Get the version of this API.
    ///
    /// This string is pulled directly from the source OpenAPI
    /// document and may be in any format the API selects.
    pub fn api_version(&self) -> &'static str {
        "v1.9.0"
    }
}
impl Client {
    /**Get Gateway Status

Returns the Gateway API version and current ledger state.


Sends a `POST` request to `/status/gateway-status`

```ignore
let response = client.gateway_status()
    .send()
    .await;
```*/
    pub fn gateway_status(&self) -> builder::GatewayStatus {
        builder::GatewayStatus::new(self)
    }
    /**Get Network Configuration

Returns network identifier, network name and well-known network addresses.


Sends a `POST` request to `/status/network-configuration`

```ignore
let response = client.network_configuration()
    .send()
    .await;
```*/
    pub fn network_configuration(&self) -> builder::NetworkConfiguration {
        builder::NetworkConfiguration::new(self)
    }
    /**Get Construction Metadata

Returns information needed to construct a new transaction including current `epoch` number.


Sends a `POST` request to `/transaction/construction`

```ignore
let response = client.transaction_construction()
    .send()
    .await;
```*/
    pub fn transaction_construction(&self) -> builder::TransactionConstruction {
        builder::TransactionConstruction::new(self)
    }
    /**Preview Transaction

Preview a transaction against the latest network state, and returns the preview receipt.
If the node has enabled it, you may be able to also preview against recent network state.

For V2 transactions (and beyond) the `/preview-v2` endpoint should be used instead.

This endpoint is effectively a proxy towards the Core API `/transaction/preview` endpoint. See the Core API documentation for more details.


Sends a `POST` request to `/transaction/preview`

```ignore
let response = client.transaction_preview()
    .body(body)
    .send()
    .await;
```*/
    pub fn transaction_preview(&self) -> builder::TransactionPreview {
        builder::TransactionPreview::new(self)
    }
    /**Preview Transaction V2

Previews a transaction against the latest network state, and returns the preview receipt.
If the node has enabled it, you may be able to also preview against recent network state.

This endpoint supports V2 transactions (and beyond). If you still need to preview V1
transactions, you should use the `/preview` endpoint instead.

This endpoint is effectively a proxy towards the Core API `/transaction/preview-v2` endpoint. See the Core API documentation for more details.


Sends a `POST` request to `/transaction/preview-v2`

```ignore
let response = client.transaction_preview_v2()
    .body(body)
    .send()
    .await;
```*/
    pub fn transaction_preview_v2(&self) -> builder::TransactionPreviewV2 {
        builder::TransactionPreviewV2::new(self)
    }
    /**Submit Transaction

Submits a signed transaction payload to the network.


Sends a `POST` request to `/transaction/submit`

```ignore
let response = client.transaction_submit()
    .body(body)
    .send()
    .await;
```*/
    pub fn transaction_submit(&self) -> builder::TransactionSubmit {
        builder::TransactionSubmit::new(self)
    }
    /**Get Committed Transaction Details

Returns the committed details and receipt of the transaction for a given transaction identifier.
Transaction identifiers which don't correspond to a committed transaction will return a `TransactionNotFoundError`.


Sends a `POST` request to `/transaction/committed-details`

```ignore
let response = client.transaction_committed_details()
    .body(body)
    .send()
    .await;
```*/
    pub fn transaction_committed_details(&self) -> builder::TransactionCommittedDetails {
        builder::TransactionCommittedDetails::new(self)
    }
    /**Get Transaction Status

Returns overall transaction status and all of its known payloads based on supplied intent hash.


Sends a `POST` request to `/transaction/status`

```ignore
let response = client.transaction_status()
    .body(body)
    .send()
    .await;
```*/
    pub fn transaction_status(&self) -> builder::TransactionStatus {
        builder::TransactionStatus::new(self)
    }
    /**Get Subintent Status

Returns if the given subintent has been finalized.


Sends a `POST` request to `/transaction/subintent-status`

```ignore
let response = client.transaction_subintent_status()
    .body(body)
    .send()
    .await;
```*/
    pub fn transaction_subintent_status(&self) -> builder::TransactionSubintentStatus {
        builder::TransactionSubintentStatus::new(self)
    }
    /**PreValidate deposit of resources to an account

Helper endpoint that allows pre-validation if a deposit of certain resources to a given account can succeed or not. It is only meant for pre-validation usage, it does not guarantee that execution will succeed.


Sends a `POST` request to `/transaction/account-deposit-pre-validation`

```ignore
let response = client.account_deposit_pre_validation()
    .body(body)
    .send()
    .await;
```*/
    pub fn account_deposit_pre_validation(
        &self,
    ) -> builder::AccountDepositPreValidation {
        builder::AccountDepositPreValidation::new(self)
    }
    /**Get Transactions Stream

Returns transactions which have been committed to the ledger.
[Check detailed documentation for brief explanation](#section/Using-the-streamtransactions-endpoint)


Sends a `POST` request to `/stream/transactions`

```ignore
let response = client.stream_transactions()
    .body(body)
    .send()
    .await;
```*/
    pub fn stream_transactions(&self) -> builder::StreamTransactions {
        builder::StreamTransactions::new(self)
    }
    /**Get Entity Details

Returns detailed information for collection of entities. Aggregate resources globally by default.


Sends a `POST` request to `/state/entity/details`

```ignore
let response = client.state_entity_details()
    .body(body)
    .send()
    .await;
```*/
    pub fn state_entity_details(&self) -> builder::StateEntityDetails {
        builder::StateEntityDetails::new(self)
    }
    /**Get Entity Metadata Page

Returns all the metadata properties associated with a given global entity.
The returned response is in a paginated format, ordered by first appearance on the ledger.


Sends a `POST` request to `/state/entity/page/metadata`

```ignore
let response = client.entity_metadata_page()
    .body(body)
    .send()
    .await;
```*/
    pub fn entity_metadata_page(&self) -> builder::EntityMetadataPage {
        builder::EntityMetadataPage::new(self)
    }
    /**Get Entity Schema Page

Returns all the schemas associated with a given global entity.
The returned response is in a paginated format, ordered by first appearance on the ledger.


Sends a `POST` request to `/state/entity/page/schemas`

```ignore
let response = client.entity_schema_page()
    .body(body)
    .send()
    .await;
```*/
    pub fn entity_schema_page(&self) -> builder::EntitySchemaPage {
        builder::EntitySchemaPage::new(self)
    }
    /**Get page of Global Entity Fungible Resource Balances

Returns the total amount of each fungible resource owned by a given global entity.
Result can be aggregated globally or per vault.
The returned response is in a paginated format, ordered by the resource's first appearance on the ledger.


Sends a `POST` request to `/state/entity/page/fungibles/`

```ignore
let response = client.entity_fungibles_page()
    .body(body)
    .send()
    .await;
```*/
    pub fn entity_fungibles_page(&self) -> builder::EntityFungiblesPage {
        builder::EntityFungiblesPage::new(self)
    }
    /**Get page of Global Entity Fungible Resource Vaults

Returns vaults for fungible resource owned by a given global entity.
The returned response is in a paginated format, ordered by the resource's first appearance on the ledger.


Sends a `POST` request to `/state/entity/page/fungible-vaults/`

```ignore
let response = client.entity_fungible_resource_vault_page()
    .body(body)
    .send()
    .await;
```*/
    pub fn entity_fungible_resource_vault_page(
        &self,
    ) -> builder::EntityFungibleResourceVaultPage {
        builder::EntityFungibleResourceVaultPage::new(self)
    }
    /**Get page of Global Entity Non-Fungible Resource Balances

Returns the total amount of each non-fungible resource owned by a given global entity.
Result can be aggregated globally or per vault.
The returned response is in a paginated format, ordered by the resource's first appearance on the ledger.


Sends a `POST` request to `/state/entity/page/non-fungibles/`

```ignore
let response = client.entity_non_fungibles_page()
    .body(body)
    .send()
    .await;
```*/
    pub fn entity_non_fungibles_page(&self) -> builder::EntityNonFungiblesPage {
        builder::EntityNonFungiblesPage::new(self)
    }
    /**Get page of Global Entity Non-Fungible Resource Vaults

Returns vaults for non fungible resource owned by a given global entity.
The returned response is in a paginated format, ordered by the resource's first appearance on the ledger.


Sends a `POST` request to `/state/entity/page/non-fungible-vaults/`

```ignore
let response = client.entity_non_fungible_resource_vault_page()
    .body(body)
    .send()
    .await;
```*/
    pub fn entity_non_fungible_resource_vault_page(
        &self,
    ) -> builder::EntityNonFungibleResourceVaultPage {
        builder::EntityNonFungibleResourceVaultPage::new(self)
    }
    /**Get page of Non-Fungibles in Vault

Returns all non-fungible IDs of a given non-fungible resource owned by a given entity.
The returned response is in a paginated format, ordered by the resource's first appearence on the ledger.


Sends a `POST` request to `/state/entity/page/non-fungible-vault/ids`

```ignore
let response = client.entity_non_fungible_ids_page()
    .body(body)
    .send()
    .await;
```*/
    pub fn entity_non_fungible_ids_page(&self) -> builder::EntityNonFungibleIdsPage {
        builder::EntityNonFungibleIdsPage::new(self)
    }
    /**Get page of Non-Fungible Ids in Resource Collection

Returns the non-fungible IDs of a given non-fungible resource.
Returned response is in a paginated format, ordered by their first appearance on the ledger.


Sends a `POST` request to `/state/non-fungible/ids`

```ignore
let response = client.non_fungible_ids()
    .body(body)
    .send()
    .await;
```*/
    pub fn non_fungible_ids(&self) -> builder::NonFungibleIds {
        builder::NonFungibleIds::new(self)
    }
    /**Get Non-Fungible Data

Returns data associated with a given non-fungible ID of a given non-fungible resource.


Sends a `POST` request to `/state/non-fungible/data`

```ignore
let response = client.non_fungible_data()
    .body(body)
    .send()
    .await;
```*/
    pub fn non_fungible_data(&self) -> builder::NonFungibleData {
        builder::NonFungibleData::new(self)
    }
    /**Get Non-Fungible Location

Returns location of a given non-fungible ID.


Sends a `POST` request to `/state/non-fungible/location`

```ignore
let response = client.non_fungible_location()
    .body(body)
    .send()
    .await;
```*/
    pub fn non_fungible_location(&self) -> builder::NonFungibleLocation {
        builder::NonFungibleLocation::new(self)
    }
    /**Get KeyValueStore Keys

Allows to iterate over key value store keys.

Sends a `POST` request to `/state/key-value-store/keys`

```ignore
let response = client.key_value_store_keys()
    .body(body)
    .send()
    .await;
```*/
    pub fn key_value_store_keys(&self) -> builder::KeyValueStoreKeys {
        builder::KeyValueStoreKeys::new(self)
    }
    /**Get KeyValueStore Data

Returns data (value) associated with a given key of a given key-value store.
[Check detailed documentation for explanation](#section/How-to-query-the-content-of-a-key-value-store-inside-a-component)


Sends a `POST` request to `/state/key-value-store/data`

```ignore
let response = client.key_value_store_data()
    .body(body)
    .send()
    .await;
```*/
    pub fn key_value_store_data(&self) -> builder::KeyValueStoreData {
        builder::KeyValueStoreData::new(self)
    }
    /**Get Validators List

Sends a `POST` request to `/state/validators/list`

```ignore
let response = client.state_validators_list()
    .body(body)
    .send()
    .await;
```*/
    pub fn state_validators_list(&self) -> builder::StateValidatorsList {
        builder::StateValidatorsList::new(self)
    }
    /**Get Account resource preferences

Returns paginable collection of resource preference rules for given account.


Sends a `POST` request to `/state/account/page/resource-preferences`

```ignore
let response = client.account_resource_preferences_page()
    .body(body)
    .send()
    .await;
```*/
    pub fn account_resource_preferences_page(
        &self,
    ) -> builder::AccountResourcePreferencesPage {
        builder::AccountResourcePreferencesPage::new(self)
    }
    /**Get Account authorized depositors

Returns paginable collection of authorized depositors for given account.


Sends a `POST` request to `/state/account/page/authorized-depositors`

```ignore
let response = client.account_authorized_depositors_page()
    .body(body)
    .send()
    .await;
```*/
    pub fn account_authorized_depositors_page(
        &self,
    ) -> builder::AccountAuthorizedDepositorsPage {
        builder::AccountAuthorizedDepositorsPage::new(self)
    }
    /**Get Package Blueprints Page

Returns all the blueprints associated with a given package entity.
The returned response is in a paginated format, ordered by first appearance on the ledger.


Sends a `POST` request to `/state/package/page/blueprints`

```ignore
let response = client.package_blueprint_page()
    .body(body)
    .send()
    .await;
```*/
    pub fn package_blueprint_page(&self) -> builder::PackageBlueprintPage {
        builder::PackageBlueprintPage::new(self)
    }
    /**Get Package Codes Page

Returns all the codes associated with a given package entity.
The returned response is in a paginated format, ordered by first appearance on the ledger.


Sends a `POST` request to `/state/package/page/codes`

```ignore
let response = client.package_code_page()
    .body(body)
    .send()
    .await;
```*/
    pub fn package_code_page(&self) -> builder::PackageCodePage {
        builder::PackageCodePage::new(self)
    }
    /**Get Account Locker Vaults Page

Returns all the resource vaults associated with a given account locker.
The returned response is in a paginated format, ordered by the most recent resource vault creation on the ledger.


Sends a `POST` request to `/state/account-locker/page/vaults`

```ignore
let response = client.account_locker_vaults_page()
    .body(body)
    .send()
    .await;
```*/
    pub fn account_locker_vaults_page(&self) -> builder::AccountLockerVaultsPage {
        builder::AccountLockerVaultsPage::new(self)
    }
    /**Get Most Recent Touch of Account Lockers

Returns most recent state version given account locker has been touched. Touch refers to the creation of the account locker itself as well as any modification to its contents, such as
resource claim, airdrop or store.


Sends a `POST` request to `/state/account-lockers/touched-at`

```ignore
let response = client.account_lockers_touched_at()
    .body(body)
    .send()
    .await;
```*/
    pub fn account_lockers_touched_at(&self) -> builder::AccountLockersTouchedAt {
        builder::AccountLockersTouchedAt::new(self)
    }
    /**Get Validators Uptime

Returns validators uptime data for time range limited by `from_state_version` and `at_state_version`.


Sends a `POST` request to `/statistics/validators/uptime`

```ignore
let response = client.validators_uptime()
    .body(body)
    .send()
    .await;
```*/
    pub fn validators_uptime(&self) -> builder::ValidatorsUptime {
        builder::ValidatorsUptime::new(self)
    }
    /**Get Resource Holders Page

A paginated endpoint to discover which global entities hold the most of a given resource.
More specifically, it returns a page of global entities which hold the given resource, ordered descending by the total fungible balance / total count of non-fungibles stored in vaults in the state tree of that entity (excluding unclaimed royalty balances).
This endpoint operates only at the **current state version**, it is not possible to browse historical data.
Because of that, it is not possible to offer stable pagination as data constantly changes. Balances might change between pages being read, which might result in gaps or some entries being returned twice.
Under default Gateway configuration, up to 100 entries are returned per response. This can be increased up to 1000 entries per page with the `limit_per_page` parameter.


Sends a `POST` request to `/extensions/resource-holders/page`

```ignore
let response = client.resource_holders_page()
    .body(body)
    .send()
    .await;
```*/
    pub fn resource_holders_page(&self) -> builder::ResourceHoldersPage {
        builder::ResourceHoldersPage::new(self)
    }
}
/// Types for composing operation parameters.
#[allow(clippy::all)]
pub mod builder {
    use super::types;
    #[allow(unused_imports)]
    use super::{
        encode_path, ByteStream, Error, HeaderMap, HeaderValue, RequestBuilderExt,
        ResponseValue,
    };
    /**Builder for [`Client::gateway_status`]

[`Client::gateway_status`]: super::Client::gateway_status*/
    #[derive(Debug, Clone)]
    pub struct GatewayStatus<'a> {
        client: &'a super::Client,
    }
    impl<'a> GatewayStatus<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }
        ///Sends a `POST` request to `/status/gateway-status`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::GatewayStatusResponse>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/status/gateway-status", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::network_configuration`]

[`Client::network_configuration`]: super::Client::network_configuration*/
    #[derive(Debug, Clone)]
    pub struct NetworkConfiguration<'a> {
        client: &'a super::Client,
    }
    impl<'a> NetworkConfiguration<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }
        ///Sends a `POST` request to `/status/network-configuration`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::NetworkConfigurationResponse>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/status/network-configuration", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::transaction_construction`]

[`Client::transaction_construction`]: super::Client::transaction_construction*/
    #[derive(Debug, Clone)]
    pub struct TransactionConstruction<'a> {
        client: &'a super::Client,
    }
    impl<'a> TransactionConstruction<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }
        ///Sends a `POST` request to `/transaction/construction`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::TransactionConstructionResponse>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/transaction/construction", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::transaction_preview`]

[`Client::transaction_preview`]: super::Client::transaction_preview*/
    #[derive(Debug, Clone)]
    pub struct TransactionPreview<'a> {
        client: &'a super::Client,
        body: Result<types::builder::TransactionPreviewRequest, String>,
    }
    impl<'a> TransactionPreview<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::TransactionPreviewRequest::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::TransactionPreviewRequest>,
            <V as std::convert::TryInto<
                types::TransactionPreviewRequest,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `TransactionPreviewRequest` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::TransactionPreviewRequest,
            ) -> types::builder::TransactionPreviewRequest,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/transaction/preview`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::TransactionPreviewResponse>,
            Error<types::ErrorResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::TransactionPreviewRequest::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/transaction/preview", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::transaction_preview_v2`]

[`Client::transaction_preview_v2`]: super::Client::transaction_preview_v2*/
    #[derive(Debug, Clone)]
    pub struct TransactionPreviewV2<'a> {
        client: &'a super::Client,
        body: Result<types::builder::TransactionPreviewV2Request, String>,
    }
    impl<'a> TransactionPreviewV2<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::TransactionPreviewV2Request::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::TransactionPreviewV2Request>,
            <V as std::convert::TryInto<
                types::TransactionPreviewV2Request,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `TransactionPreviewV2Request` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::TransactionPreviewV2Request,
            ) -> types::builder::TransactionPreviewV2Request,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/transaction/preview-v2`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::TransactionPreviewV2Response>,
            Error<types::ErrorResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::TransactionPreviewV2Request::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/transaction/preview-v2", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::transaction_submit`]

[`Client::transaction_submit`]: super::Client::transaction_submit*/
    #[derive(Debug, Clone)]
    pub struct TransactionSubmit<'a> {
        client: &'a super::Client,
        body: Result<types::builder::TransactionSubmitRequest, String>,
    }
    impl<'a> TransactionSubmit<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::TransactionSubmitRequest::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::TransactionSubmitRequest>,
            <V as std::convert::TryInto<
                types::TransactionSubmitRequest,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `TransactionSubmitRequest` for body failed: {}", s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::TransactionSubmitRequest,
            ) -> types::builder::TransactionSubmitRequest,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/transaction/submit`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::TransactionSubmitResponse>,
            Error<types::ErrorResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::TransactionSubmitRequest::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/transaction/submit", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::transaction_committed_details`]

[`Client::transaction_committed_details`]: super::Client::transaction_committed_details*/
    #[derive(Debug, Clone)]
    pub struct TransactionCommittedDetails<'a> {
        client: &'a super::Client,
        body: Result<types::builder::TransactionCommittedDetailsRequest, String>,
    }
    impl<'a> TransactionCommittedDetails<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::TransactionCommittedDetailsRequest::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::TransactionCommittedDetailsRequest>,
            <V as std::convert::TryInto<
                types::TransactionCommittedDetailsRequest,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `TransactionCommittedDetailsRequest` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::TransactionCommittedDetailsRequest,
            ) -> types::builder::TransactionCommittedDetailsRequest,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/transaction/committed-details`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::TransactionCommittedDetailsResponse>,
            Error<types::ErrorResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::TransactionCommittedDetailsRequest::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/transaction/committed-details", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::transaction_status`]

[`Client::transaction_status`]: super::Client::transaction_status*/
    #[derive(Debug, Clone)]
    pub struct TransactionStatus<'a> {
        client: &'a super::Client,
        body: Result<types::builder::TransactionStatusRequest, String>,
    }
    impl<'a> TransactionStatus<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::TransactionStatusRequest::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::TransactionStatusRequest>,
            <V as std::convert::TryInto<
                types::TransactionStatusRequest,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `TransactionStatusRequest` for body failed: {}", s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::TransactionStatusRequest,
            ) -> types::builder::TransactionStatusRequest,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/transaction/status`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::TransactionStatusResponse>,
            Error<types::ErrorResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::TransactionStatusRequest::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/transaction/status", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::transaction_subintent_status`]

[`Client::transaction_subintent_status`]: super::Client::transaction_subintent_status*/
    #[derive(Debug, Clone)]
    pub struct TransactionSubintentStatus<'a> {
        client: &'a super::Client,
        body: Result<types::builder::TransactionSubintentStatusRequest, String>,
    }
    impl<'a> TransactionSubintentStatus<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::TransactionSubintentStatusRequest::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::TransactionSubintentStatusRequest>,
            <V as std::convert::TryInto<
                types::TransactionSubintentStatusRequest,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `TransactionSubintentStatusRequest` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::TransactionSubintentStatusRequest,
            ) -> types::builder::TransactionSubintentStatusRequest,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/transaction/subintent-status`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::TransactionSubintentStatusResponse>,
            Error<types::ErrorResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::TransactionSubintentStatusRequest::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/transaction/subintent-status", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::account_deposit_pre_validation`]

[`Client::account_deposit_pre_validation`]: super::Client::account_deposit_pre_validation*/
    #[derive(Debug, Clone)]
    pub struct AccountDepositPreValidation<'a> {
        client: &'a super::Client,
        body: Result<types::builder::AccountDepositPreValidationRequest, String>,
    }
    impl<'a> AccountDepositPreValidation<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::AccountDepositPreValidationRequest::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::AccountDepositPreValidationRequest>,
            <V as std::convert::TryInto<
                types::AccountDepositPreValidationRequest,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `AccountDepositPreValidationRequest` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::AccountDepositPreValidationRequest,
            ) -> types::builder::AccountDepositPreValidationRequest,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/transaction/account-deposit-pre-validation`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::AccountDepositPreValidationResponse>,
            Error<types::ErrorResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::AccountDepositPreValidationRequest::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/transaction/account-deposit-pre-validation", client.baseurl,
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::stream_transactions`]

[`Client::stream_transactions`]: super::Client::stream_transactions*/
    #[derive(Debug, Clone)]
    pub struct StreamTransactions<'a> {
        client: &'a super::Client,
        body: Result<types::builder::StreamTransactionsRequest, String>,
    }
    impl<'a> StreamTransactions<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::StreamTransactionsRequest::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::StreamTransactionsRequest>,
            <V as std::convert::TryInto<
                types::StreamTransactionsRequest,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `StreamTransactionsRequest` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::StreamTransactionsRequest,
            ) -> types::builder::StreamTransactionsRequest,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/stream/transactions`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::StreamTransactionsResponse>,
            Error<types::ErrorResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::StreamTransactionsRequest::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/stream/transactions", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::state_entity_details`]

[`Client::state_entity_details`]: super::Client::state_entity_details*/
    #[derive(Debug, Clone)]
    pub struct StateEntityDetails<'a> {
        client: &'a super::Client,
        body: Result<types::builder::StateEntityDetailsRequest, String>,
    }
    impl<'a> StateEntityDetails<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::StateEntityDetailsRequest::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::StateEntityDetailsRequest>,
            <V as std::convert::TryInto<
                types::StateEntityDetailsRequest,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `StateEntityDetailsRequest` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::StateEntityDetailsRequest,
            ) -> types::builder::StateEntityDetailsRequest,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/state/entity/details`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::StateEntityDetailsResponse>,
            Error<types::ErrorResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::StateEntityDetailsRequest::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/state/entity/details", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::entity_metadata_page`]

[`Client::entity_metadata_page`]: super::Client::entity_metadata_page*/
    #[derive(Debug, Clone)]
    pub struct EntityMetadataPage<'a> {
        client: &'a super::Client,
        body: Result<types::builder::StateEntityMetadataPageRequest, String>,
    }
    impl<'a> EntityMetadataPage<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::StateEntityMetadataPageRequest::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::StateEntityMetadataPageRequest>,
            <V as std::convert::TryInto<
                types::StateEntityMetadataPageRequest,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `StateEntityMetadataPageRequest` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::StateEntityMetadataPageRequest,
            ) -> types::builder::StateEntityMetadataPageRequest,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/state/entity/page/metadata`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::StateEntityMetadataPageResponse>,
            Error<types::ErrorResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::StateEntityMetadataPageRequest::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/state/entity/page/metadata", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::entity_schema_page`]

[`Client::entity_schema_page`]: super::Client::entity_schema_page*/
    #[derive(Debug, Clone)]
    pub struct EntitySchemaPage<'a> {
        client: &'a super::Client,
        body: Result<types::builder::StateEntitySchemaPageRequest, String>,
    }
    impl<'a> EntitySchemaPage<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::StateEntitySchemaPageRequest::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::StateEntitySchemaPageRequest>,
            <V as std::convert::TryInto<
                types::StateEntitySchemaPageRequest,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `StateEntitySchemaPageRequest` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::StateEntitySchemaPageRequest,
            ) -> types::builder::StateEntitySchemaPageRequest,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/state/entity/page/schemas`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::StateEntitySchemaPageResponse>,
            Error<types::ErrorResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::StateEntitySchemaPageRequest::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/state/entity/page/schemas", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::entity_fungibles_page`]

[`Client::entity_fungibles_page`]: super::Client::entity_fungibles_page*/
    #[derive(Debug, Clone)]
    pub struct EntityFungiblesPage<'a> {
        client: &'a super::Client,
        body: Result<types::builder::StateEntityFungiblesPageRequest, String>,
    }
    impl<'a> EntityFungiblesPage<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::StateEntityFungiblesPageRequest::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::StateEntityFungiblesPageRequest>,
            <V as std::convert::TryInto<
                types::StateEntityFungiblesPageRequest,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `StateEntityFungiblesPageRequest` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::StateEntityFungiblesPageRequest,
            ) -> types::builder::StateEntityFungiblesPageRequest,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/state/entity/page/fungibles/`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::StateEntityFungiblesPageResponse>,
            Error<types::ErrorResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::StateEntityFungiblesPageRequest::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/state/entity/page/fungibles/", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::entity_fungible_resource_vault_page`]

[`Client::entity_fungible_resource_vault_page`]: super::Client::entity_fungible_resource_vault_page*/
    #[derive(Debug, Clone)]
    pub struct EntityFungibleResourceVaultPage<'a> {
        client: &'a super::Client,
        body: Result<
            types::builder::StateEntityFungibleResourceVaultsPageRequest,
            String,
        >,
    }
    impl<'a> EntityFungibleResourceVaultPage<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(
                    types::builder::StateEntityFungibleResourceVaultsPageRequest::default(),
                ),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<
                types::StateEntityFungibleResourceVaultsPageRequest,
            >,
            <V as std::convert::TryInto<
                types::StateEntityFungibleResourceVaultsPageRequest,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `StateEntityFungibleResourceVaultsPageRequest` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::StateEntityFungibleResourceVaultsPageRequest,
            ) -> types::builder::StateEntityFungibleResourceVaultsPageRequest,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/state/entity/page/fungible-vaults/`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::StateEntityFungibleResourceVaultsPageResponse>,
            Error<types::ErrorResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::StateEntityFungibleResourceVaultsPageRequest::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/state/entity/page/fungible-vaults/", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::entity_non_fungibles_page`]

[`Client::entity_non_fungibles_page`]: super::Client::entity_non_fungibles_page*/
    #[derive(Debug, Clone)]
    pub struct EntityNonFungiblesPage<'a> {
        client: &'a super::Client,
        body: Result<types::builder::StateEntityNonFungiblesPageRequest, String>,
    }
    impl<'a> EntityNonFungiblesPage<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::StateEntityNonFungiblesPageRequest::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::StateEntityNonFungiblesPageRequest>,
            <V as std::convert::TryInto<
                types::StateEntityNonFungiblesPageRequest,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `StateEntityNonFungiblesPageRequest` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::StateEntityNonFungiblesPageRequest,
            ) -> types::builder::StateEntityNonFungiblesPageRequest,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/state/entity/page/non-fungibles/`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::StateEntityNonFungiblesPageResponse>,
            Error<types::ErrorResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::StateEntityNonFungiblesPageRequest::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/state/entity/page/non-fungibles/", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::entity_non_fungible_resource_vault_page`]

[`Client::entity_non_fungible_resource_vault_page`]: super::Client::entity_non_fungible_resource_vault_page*/
    #[derive(Debug, Clone)]
    pub struct EntityNonFungibleResourceVaultPage<'a> {
        client: &'a super::Client,
        body: Result<
            types::builder::StateEntityNonFungibleResourceVaultsPageRequest,
            String,
        >,
    }
    impl<'a> EntityNonFungibleResourceVaultPage<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(
                    types::builder::StateEntityNonFungibleResourceVaultsPageRequest::default(),
                ),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<
                types::StateEntityNonFungibleResourceVaultsPageRequest,
            >,
            <V as std::convert::TryInto<
                types::StateEntityNonFungibleResourceVaultsPageRequest,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `StateEntityNonFungibleResourceVaultsPageRequest` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::StateEntityNonFungibleResourceVaultsPageRequest,
            ) -> types::builder::StateEntityNonFungibleResourceVaultsPageRequest,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/state/entity/page/non-fungible-vaults/`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::StateEntityNonFungibleResourceVaultsPageResponse>,
            Error<types::ErrorResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::StateEntityNonFungibleResourceVaultsPageRequest::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/state/entity/page/non-fungible-vaults/", client.baseurl,
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::entity_non_fungible_ids_page`]

[`Client::entity_non_fungible_ids_page`]: super::Client::entity_non_fungible_ids_page*/
    #[derive(Debug, Clone)]
    pub struct EntityNonFungibleIdsPage<'a> {
        client: &'a super::Client,
        body: Result<types::builder::StateEntityNonFungibleIdsPageRequest, String>,
    }
    impl<'a> EntityNonFungibleIdsPage<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::StateEntityNonFungibleIdsPageRequest::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::StateEntityNonFungibleIdsPageRequest>,
            <V as std::convert::TryInto<
                types::StateEntityNonFungibleIdsPageRequest,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `StateEntityNonFungibleIdsPageRequest` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::StateEntityNonFungibleIdsPageRequest,
            ) -> types::builder::StateEntityNonFungibleIdsPageRequest,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/state/entity/page/non-fungible-vault/ids`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::StateEntityNonFungibleIdsPageResponse>,
            Error<types::ErrorResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::StateEntityNonFungibleIdsPageRequest::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/state/entity/page/non-fungible-vault/ids", client.baseurl,
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::non_fungible_ids`]

[`Client::non_fungible_ids`]: super::Client::non_fungible_ids*/
    #[derive(Debug, Clone)]
    pub struct NonFungibleIds<'a> {
        client: &'a super::Client,
        body: Result<types::builder::StateNonFungibleIdsRequest, String>,
    }
    impl<'a> NonFungibleIds<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::StateNonFungibleIdsRequest::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::StateNonFungibleIdsRequest>,
            <V as std::convert::TryInto<
                types::StateNonFungibleIdsRequest,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `StateNonFungibleIdsRequest` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::StateNonFungibleIdsRequest,
            ) -> types::builder::StateNonFungibleIdsRequest,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/state/non-fungible/ids`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::StateNonFungibleIdsResponse>,
            Error<types::ErrorResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::StateNonFungibleIdsRequest::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/state/non-fungible/ids", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::non_fungible_data`]

[`Client::non_fungible_data`]: super::Client::non_fungible_data*/
    #[derive(Debug, Clone)]
    pub struct NonFungibleData<'a> {
        client: &'a super::Client,
        body: Result<types::builder::StateNonFungibleDataRequest, String>,
    }
    impl<'a> NonFungibleData<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::StateNonFungibleDataRequest::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::StateNonFungibleDataRequest>,
            <V as std::convert::TryInto<
                types::StateNonFungibleDataRequest,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `StateNonFungibleDataRequest` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::StateNonFungibleDataRequest,
            ) -> types::builder::StateNonFungibleDataRequest,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/state/non-fungible/data`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::StateNonFungibleDataResponse>,
            Error<types::ErrorResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::StateNonFungibleDataRequest::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/state/non-fungible/data", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::non_fungible_location`]

[`Client::non_fungible_location`]: super::Client::non_fungible_location*/
    #[derive(Debug, Clone)]
    pub struct NonFungibleLocation<'a> {
        client: &'a super::Client,
        body: Result<types::builder::StateNonFungibleLocationRequest, String>,
    }
    impl<'a> NonFungibleLocation<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::StateNonFungibleLocationRequest::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::StateNonFungibleLocationRequest>,
            <V as std::convert::TryInto<
                types::StateNonFungibleLocationRequest,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `StateNonFungibleLocationRequest` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::StateNonFungibleLocationRequest,
            ) -> types::builder::StateNonFungibleLocationRequest,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/state/non-fungible/location`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::StateNonFungibleLocationResponse>,
            Error<types::ErrorResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::StateNonFungibleLocationRequest::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/state/non-fungible/location", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::key_value_store_keys`]

[`Client::key_value_store_keys`]: super::Client::key_value_store_keys*/
    #[derive(Debug, Clone)]
    pub struct KeyValueStoreKeys<'a> {
        client: &'a super::Client,
        body: Result<types::builder::StateKeyValueStoreKeysRequest, String>,
    }
    impl<'a> KeyValueStoreKeys<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::StateKeyValueStoreKeysRequest::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::StateKeyValueStoreKeysRequest>,
            <V as std::convert::TryInto<
                types::StateKeyValueStoreKeysRequest,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `StateKeyValueStoreKeysRequest` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::StateKeyValueStoreKeysRequest,
            ) -> types::builder::StateKeyValueStoreKeysRequest,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/state/key-value-store/keys`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::StateKeyValueStoreKeysResponse>,
            Error<types::ErrorResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::StateKeyValueStoreKeysRequest::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/state/key-value-store/keys", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::key_value_store_data`]

[`Client::key_value_store_data`]: super::Client::key_value_store_data*/
    #[derive(Debug, Clone)]
    pub struct KeyValueStoreData<'a> {
        client: &'a super::Client,
        body: Result<types::builder::StateKeyValueStoreDataRequest, String>,
    }
    impl<'a> KeyValueStoreData<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::StateKeyValueStoreDataRequest::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::StateKeyValueStoreDataRequest>,
            <V as std::convert::TryInto<
                types::StateKeyValueStoreDataRequest,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `StateKeyValueStoreDataRequest` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::StateKeyValueStoreDataRequest,
            ) -> types::builder::StateKeyValueStoreDataRequest,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/state/key-value-store/data`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::StateKeyValueStoreDataResponse>,
            Error<types::ErrorResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::StateKeyValueStoreDataRequest::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/state/key-value-store/data", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::state_validators_list`]

[`Client::state_validators_list`]: super::Client::state_validators_list*/
    #[derive(Debug, Clone)]
    pub struct StateValidatorsList<'a> {
        client: &'a super::Client,
        body: Result<types::builder::StateValidatorsListRequest, String>,
    }
    impl<'a> StateValidatorsList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::StateValidatorsListRequest::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::StateValidatorsListRequest>,
            <V as std::convert::TryInto<
                types::StateValidatorsListRequest,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `StateValidatorsListRequest` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::StateValidatorsListRequest,
            ) -> types::builder::StateValidatorsListRequest,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/state/validators/list`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::StateValidatorsListResponse>,
            Error<types::ErrorResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::StateValidatorsListRequest::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/state/validators/list", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::account_resource_preferences_page`]

[`Client::account_resource_preferences_page`]: super::Client::account_resource_preferences_page*/
    #[derive(Debug, Clone)]
    pub struct AccountResourcePreferencesPage<'a> {
        client: &'a super::Client,
        body: Result<types::builder::StateAccountResourcePreferencesPageRequest, String>,
    }
    impl<'a> AccountResourcePreferencesPage<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(
                    types::builder::StateAccountResourcePreferencesPageRequest::default(),
                ),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::StateAccountResourcePreferencesPageRequest>,
            <V as std::convert::TryInto<
                types::StateAccountResourcePreferencesPageRequest,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `StateAccountResourcePreferencesPageRequest` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::StateAccountResourcePreferencesPageRequest,
            ) -> types::builder::StateAccountResourcePreferencesPageRequest,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/state/account/page/resource-preferences`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::StateAccountResourcePreferencesPageResponse>,
            Error<types::ErrorResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::StateAccountResourcePreferencesPageRequest::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/state/account/page/resource-preferences", client.baseurl,
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::account_authorized_depositors_page`]

[`Client::account_authorized_depositors_page`]: super::Client::account_authorized_depositors_page*/
    #[derive(Debug, Clone)]
    pub struct AccountAuthorizedDepositorsPage<'a> {
        client: &'a super::Client,
        body: Result<
            types::builder::StateAccountAuthorizedDepositorsPageRequest,
            String,
        >,
    }
    impl<'a> AccountAuthorizedDepositorsPage<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(
                    types::builder::StateAccountAuthorizedDepositorsPageRequest::default(),
                ),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::StateAccountAuthorizedDepositorsPageRequest>,
            <V as std::convert::TryInto<
                types::StateAccountAuthorizedDepositorsPageRequest,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `StateAccountAuthorizedDepositorsPageRequest` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::StateAccountAuthorizedDepositorsPageRequest,
            ) -> types::builder::StateAccountAuthorizedDepositorsPageRequest,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/state/account/page/authorized-depositors`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::StateAccountAuthorizedDepositorsPageResponse>,
            Error<types::ErrorResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::StateAccountAuthorizedDepositorsPageRequest::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/state/account/page/authorized-depositors", client.baseurl,
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::package_blueprint_page`]

[`Client::package_blueprint_page`]: super::Client::package_blueprint_page*/
    #[derive(Debug, Clone)]
    pub struct PackageBlueprintPage<'a> {
        client: &'a super::Client,
        body: Result<types::builder::StatePackageBlueprintPageRequest, String>,
    }
    impl<'a> PackageBlueprintPage<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::StatePackageBlueprintPageRequest::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::StatePackageBlueprintPageRequest>,
            <V as std::convert::TryInto<
                types::StatePackageBlueprintPageRequest,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `StatePackageBlueprintPageRequest` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::StatePackageBlueprintPageRequest,
            ) -> types::builder::StatePackageBlueprintPageRequest,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/state/package/page/blueprints`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::StatePackageBlueprintPageResponse>,
            Error<types::ErrorResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::StatePackageBlueprintPageRequest::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/state/package/page/blueprints", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::package_code_page`]

[`Client::package_code_page`]: super::Client::package_code_page*/
    #[derive(Debug, Clone)]
    pub struct PackageCodePage<'a> {
        client: &'a super::Client,
        body: Result<types::builder::StatePackageCodePageRequest, String>,
    }
    impl<'a> PackageCodePage<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::StatePackageCodePageRequest::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::StatePackageCodePageRequest>,
            <V as std::convert::TryInto<
                types::StatePackageCodePageRequest,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `StatePackageCodePageRequest` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::StatePackageCodePageRequest,
            ) -> types::builder::StatePackageCodePageRequest,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/state/package/page/codes`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::StatePackageCodePageResponse>,
            Error<types::ErrorResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::StatePackageCodePageRequest::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/state/package/page/codes", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::account_locker_vaults_page`]

[`Client::account_locker_vaults_page`]: super::Client::account_locker_vaults_page*/
    #[derive(Debug, Clone)]
    pub struct AccountLockerVaultsPage<'a> {
        client: &'a super::Client,
        body: Result<types::builder::StateAccountLockerPageVaultsRequest, String>,
    }
    impl<'a> AccountLockerVaultsPage<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::StateAccountLockerPageVaultsRequest::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::StateAccountLockerPageVaultsRequest>,
            <V as std::convert::TryInto<
                types::StateAccountLockerPageVaultsRequest,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `StateAccountLockerPageVaultsRequest` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::StateAccountLockerPageVaultsRequest,
            ) -> types::builder::StateAccountLockerPageVaultsRequest,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/state/account-locker/page/vaults`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::StateAccountLockerPageVaultsResponse>,
            Error<types::ErrorResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::StateAccountLockerPageVaultsRequest::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/state/account-locker/page/vaults", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::account_lockers_touched_at`]

[`Client::account_lockers_touched_at`]: super::Client::account_lockers_touched_at*/
    #[derive(Debug, Clone)]
    pub struct AccountLockersTouchedAt<'a> {
        client: &'a super::Client,
        body: Result<types::builder::StateAccountLockersTouchedAtRequest, String>,
    }
    impl<'a> AccountLockersTouchedAt<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::StateAccountLockersTouchedAtRequest::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::StateAccountLockersTouchedAtRequest>,
            <V as std::convert::TryInto<
                types::StateAccountLockersTouchedAtRequest,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `StateAccountLockersTouchedAtRequest` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::StateAccountLockersTouchedAtRequest,
            ) -> types::builder::StateAccountLockersTouchedAtRequest,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/state/account-lockers/touched-at`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::StateAccountLockersTouchedAtResponse>,
            Error<types::ErrorResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::StateAccountLockersTouchedAtRequest::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/state/account-lockers/touched-at", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::validators_uptime`]

[`Client::validators_uptime`]: super::Client::validators_uptime*/
    #[derive(Debug, Clone)]
    pub struct ValidatorsUptime<'a> {
        client: &'a super::Client,
        body: Result<types::builder::ValidatorsUptimeRequest, String>,
    }
    impl<'a> ValidatorsUptime<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::ValidatorsUptimeRequest::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ValidatorsUptimeRequest>,
            <V as std::convert::TryInto<
                types::ValidatorsUptimeRequest,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `ValidatorsUptimeRequest` for body failed: {}", s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::ValidatorsUptimeRequest,
            ) -> types::builder::ValidatorsUptimeRequest,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/statistics/validators/uptime`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::ValidatorsUptimeResponse>,
            Error<types::ErrorResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::ValidatorsUptimeRequest::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/statistics/validators/uptime", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::resource_holders_page`]

[`Client::resource_holders_page`]: super::Client::resource_holders_page*/
    #[derive(Debug, Clone)]
    pub struct ResourceHoldersPage<'a> {
        client: &'a super::Client,
        body: Result<types::builder::ResourceHoldersRequest, String>,
    }
    impl<'a> ResourceHoldersPage<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::ResourceHoldersRequest::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ResourceHoldersRequest>,
            <V as std::convert::TryInto<
                types::ResourceHoldersRequest,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `ResourceHoldersRequest` for body failed: {}", s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::ResourceHoldersRequest,
            ) -> types::builder::ResourceHoldersRequest,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/extensions/resource-holders/page`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::ResourceHoldersResponse>,
            Error<types::ErrorResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::ResourceHoldersRequest::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/extensions/resource-holders/page", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
}
/// Items consumers will typically use such as the Client.
pub mod prelude {
    pub use self::super::Client;
}
