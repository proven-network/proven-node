// Example of how the app should work with bundler transformation
import { sdk } from './sdk-init';
import { effect } from '@preact/signals-core';

// Import handlers directly - bundler will transform these
import { createTodo, getTodos, updateTodo, deleteTodo, getTodoStats } from './todo-handlers';

// App state
let currentFilter: 'all' | 'pending' | 'completed' = 'all';
let currentSearch = '';

export async function initApp() {
  try {
    console.log('üéØ Initializing Rollup Todo App...');

    // Load and register manifest
    const manifest = await loadManifest();
    sdk.registerManifest(manifest);
    console.log('Manifest registered:', manifest.id);

    // Initialize auth button
    await sdk.initConnectButton('#auth-container');
    console.log('Auth button initialized');

    // Set up reactive authentication state handling
    setupReactiveAuth();

    console.log('‚úÖ Rollup Todo App initialized successfully');
  } catch (error) {
    console.error('Failed to initialize app:', error);
  }
}

async function loadManifest() {
  // Load the real manifest generated by the bundler
  try {
    const response = await fetch('dist/proven-bundle.json');
    if (!response.ok) {
      throw new Error(`Failed to load manifest: ${response.status}`);
    }
    const manifest = await response.json();
    console.log('Loaded generated manifest:', manifest.id);
    return manifest;
  } catch (error) {
    console.error('Failed to load manifest:', error);
    throw error;
  }
}

// Set up reactive authentication state handling
function setupReactiveAuth() {
  console.log('üîÑ Setting up reactive authentication state...');

  // React to authentication state changes
  effect(() => {
    const authState = sdk.authState.value;
    const userInfo = sdk.userInfo.value;
    const isAuthenticated = sdk.isAuthenticated.value;

    console.log('Auth state changed:', { authState, isAuthenticated, userInfo });

    // Update UI based on authentication state
    updateAuthUI(isAuthenticated, userInfo);

    // Load todos and stats when user is authenticated
    if (isAuthenticated) {
      loadTodos().catch(console.error);
      updateStats().catch(console.error);
    }
  });

  // Debug: Print auth signal status every 5 seconds
  setInterval(() => {
    const authState = sdk.authState.value;
    const userInfo = sdk.userInfo.value;
    const isAuthenticated = sdk.isAuthenticated.value;

    console.log('üîÑ Auth Status Check (every 5s):', {
      authState,
      isAuthenticated,
      userInfo,
      timestamp: new Date().toISOString(),
    });
  }, 5000);
}

export async function addTodo(title: string, description?: string) {
  if (!title.trim()) return;

  try {
    // Direct function call - bundler transformation handles the SDK communication
    const newTodo = await createTodo({
      title: title.trim(),
      description: description?.trim(),
    });

    console.log('Created todo:', newTodo);

    // Refresh data
    await loadTodos();
    await updateStats();
  } catch (error) {
    console.error('Error creating todo:', error);
    throw error;
  }
}

export async function loadTodos() {
  try {
    // Build filter
    const filter: any = {};
    if (currentFilter === 'completed') filter.completed = true;
    if (currentFilter === 'pending') filter.completed = false;
    if (currentSearch) filter.search = currentSearch;

    // Direct function call - bundler transformation handles the SDK communication
    const todos = await getTodos(filter);
    renderTodos(todos);
  } catch (error) {
    console.error('Error loading todos:', error);
    renderError('Failed to load todos');
  }
}

export async function toggleTodo(id: string, completed: boolean) {
  try {
    // Direct function call - bundler transformation handles the SDK communication
    await updateTodo({
      id,
      completed,
    });

    await loadTodos();
    await updateStats();
  } catch (error) {
    console.error('Error updating todo:', error);
    throw error;
  }
}

export async function deleteTodoItem(id: string) {
  if (!confirm('Are you sure you want to delete this todo?')) return;

  try {
    // Direct function call - bundler transformation handles the SDK communication
    await deleteTodo(id);

    await loadTodos();
    await updateStats();
  } catch (error) {
    console.error('Error deleting todo:', error);
    throw error;
  }
}

export async function updateStats() {
  try {
    // Direct function call - bundler transformation handles the SDK communication
    const stats = await getTodoStats();

    updateStatsUI(stats);
  } catch (error) {
    console.error('Error updating stats:', error);
  }
}

export function setFilter(filter: 'all' | 'pending' | 'completed') {
  currentFilter = filter;
  loadTodos();
}

export function setSearch(search: string) {
  currentSearch = search;
  loadTodos();
}

// UI update functions (would be in a separate UI module in a real app)
function updateAuthUI(isAuthenticated: boolean, whoAmIResult?: any) {
  const authStatus = document.getElementById('auth-status');
  const authText = document.getElementById('auth-text');
  const todoInterface = document.getElementById('todo-interface');
  const signinPrompt = document.getElementById('signin-prompt');

  if (!authStatus || !authText || !todoInterface || !signinPrompt) return;

  if (isAuthenticated && whoAmIResult) {
    // User is authenticated - show todo interface
    authStatus.className = 'auth-status authenticated';
    if (whoAmIResult.result === 'identified' && whoAmIResult.data?.identity) {
      authText.textContent = `‚úÖ Authenticated as ${whoAmIResult.data.identity} - Managing your private todos`;
    } else {
      authText.textContent = '‚úÖ Authenticated - Managing your private todos';
    }

    // Show todo interface and hide signin prompt
    todoInterface.style.display = 'block';
    signinPrompt.style.display = 'none';
  } else {
    // User is not authenticated - show signin prompt
    authStatus.className = 'auth-status unauthenticated';
    authText.textContent = '‚ùå Not authenticated - Please sign in to access your todos';

    // Hide todo interface and show signin prompt
    todoInterface.style.display = 'none';
    signinPrompt.style.display = 'block';
  }
}

function renderTodos(todos: any[]) {
  const container = document.getElementById('todos-container');
  if (!container) return;

  if (todos.length === 0) {
    container.innerHTML =
      '<p style="text-align: center; color: #666; padding: 20px;">No todos found</p>';
    return;
  }

  container.innerHTML = todos
    .map(
      (todo) => `
      <div class="todo-item ${todo.completed ? 'completed' : ''}">
        <div class="todo-content">
          <div class="todo-title">${escapeHtml(todo.title)}</div>
          ${todo.description ? `<div class="todo-description">${escapeHtml(todo.description)}</div>` : ''}
          <div style="font-size: 0.8em; color: #999;">
            Created: ${new Date(todo.createdAt).toLocaleDateString()}
          </div>
        </div>
        <div class="todo-actions">
          <button class="btn-complete" onclick="window.todoApp.toggleTodo('${todo.id}', ${!todo.completed})">
            ${todo.completed ? 'Undo' : 'Complete'}
          </button>
          <button class="btn-delete" onclick="window.todoApp.deleteTodoItem('${todo.id}')">Delete</button>
        </div>
      </div>
    `
    )
    .join('');
}

function renderError(message: string) {
  const container = document.getElementById('todos-container');
  if (!container) return;

  container.innerHTML = `<p style="text-align: center; color: #dc3545; padding: 20px;">${message}</p>`;
}

function updateStatsUI(stats: any) {
  const elements = {
    total: document.getElementById('total-count'),
    completed: document.getElementById('completed-count'),
    pending: document.getElementById('pending-count'),
    rate: document.getElementById('completion-rate'),
  };

  if (elements.total) elements.total.textContent = stats.total;
  if (elements.completed) elements.completed.textContent = stats.completed;
  if (elements.pending) elements.pending.textContent = stats.pending;
  if (elements.rate) elements.rate.textContent = stats.completionRate + '%';
}

function escapeHtml(text: string): string {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

// HTML form handler functions
export function handleAddTodoForm(event: Event) {
  event.preventDefault();

  const titleElement = document.getElementById('todo-title') as HTMLInputElement;
  const descriptionElement = document.getElementById('todo-description') as HTMLTextAreaElement;

  if (!titleElement || !descriptionElement) {
    console.error('Form elements not found');
    return;
  }

  const title = titleElement.value;
  const description = descriptionElement.value;

  if (!title.trim()) return;

  addTodo(title, description)
    .then(() => {
      // Clear form
      titleElement.value = '';
      descriptionElement.value = '';
    })
    .catch((error) => {
      console.error('Error creating todo:', error);
      alert('Failed to create todo: ' + error.message);
    });
}

export function handleFilterTodos(filter: 'all' | 'pending' | 'completed') {
  setFilter(filter);

  // Update button states
  document
    .querySelectorAll('.filter-buttons button')
    .forEach((btn) => btn.classList.remove('active'));
  const filterButton = document.getElementById('filter-' + filter);
  if (filterButton) {
    filterButton.classList.add('active');
  }
}

export function handleSearchTodos(query: string) {
  setSearch(query);
}

// Set up global functions for HTML onclick handlers
function setupGlobalHandlers() {
  (window as any).addTodo = handleAddTodoForm;
  (window as any).filterTodos = handleFilterTodos;
  (window as any).searchTodos = handleSearchTodos;
}

// Export functions for global access (temporary until we have proper event binding)
(window as any).todoApp = {
  addTodo,
  toggleTodo,
  deleteTodoItem,
  setFilter,
  setSearch,
};

// Initialize global handlers when module loads
setupGlobalHandlers();
